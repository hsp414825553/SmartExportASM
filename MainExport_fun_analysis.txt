// 函数分析报告
// 目标函数: MainExport_fun (0x1800086F0)
// 分析时间: 2025-09-28 20:25:48.917706 
// 总共分析 133 个函数

// ========== 调用图 ==========
函数: MainExport_fun (0x1800086F0)
  调用以下函数:
    - sub_18007C400 (0x18007C400)
    - unknown_libname_1 (0x180004800)
    - sub_180007C00 (0x180007C00)
    - sub_180008090 (0x180008090)
    - AIContextSuite_Out (0x180009C10)
    - _Init_thread_footer (0x180080C98)
    - _CxxThrowException (0x18008189C)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_180065DA0 (0x180065DA0)
    - sub_18004F220 (0x18004F220)
    - sub_180077420 (0x180077420)
    - sub_1800064A0 (0x1800064A0)
    - AIContextSuite_Put (0x180009BB0)
    - sub_1800079B0 (0x1800079B0)
    - sub_180064BB0 (0x180064BB0)
    - sub_180006EC0 (0x180006EC0)
    - sub_180077240 (0x180077240)
    - sub_1800774D0 (0x1800774D0)
    - __security_check_cookie (0x180080B50)
    - sub_180026160 (0x180026160)
    - sub_180070F60 (0x180070F60)
    - sub_180068460 (0x180068460)
    - sub_18004EE60 (0x18004EE60)
    - sub_180007460 (0x180007460)
    - sub_1800517E0 (0x1800517E0)
    - sub_180075970 (0x180075970)
    - sub_1800077F0 (0x1800077F0)
    - GetAssetSelectionPath22 (0x18007C470)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - sub_180007D70 (0x180007D70)
    - sub_180022FF0 (0x180022FF0)
    - _Init_thread_header (0x180080CF8)

函数: sub_18007C400 (0x18007C400)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: unknown_libname_1 (0x180004800)
  被以下函数调用:
    - sub_1800779C0 (0x1800779C0)
    - sub_180065DA0 (0x180065DA0)
    - sub_180077AC0 (0x180077AC0)
    - sub_180067DC0 (0x180067DC0)
    - MainExport_fun (0x1800086F0)
    - sub_180064BB0 (0x180064BB0)
    - sub_180052D30 (0x180052D30)
    - sub_18004C8D0 (0x18004C8D0)
    - GetAssetSelectionPath22 (0x18007C470)

函数: sub_180007C00 (0x180007C00)
  调用以下函数:
    - sub_180007C00 (0x180007C00)
    - sub_180077420 (0x180077420)
    - sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)
    - sub_180007C00 (0x180007C00)
    - sub_180068320 (0x180068320)
    - sub_180065DA0 (0x180065DA0)

函数: sub_180077420 (0x180077420)
  调用以下函数:
    - GetAIFilePathSuite (0x180077E00)
    - _CxxThrowException (0x18008189C)
    - sub_180026160 (0x180026160)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180007C00 (0x180007C00)
    - sub_180065DA0 (0x180065DA0)
    - sub_180067DC0 (0x180067DC0)
    - sub_180064BB0 (0x180064BB0)
    - MainExport_fun (0x1800086F0)

函数: GetAIFilePathSuite (0x180077E00)
  调用以下函数:
    - _Init_thread_header (0x180080CF8)
    - sub_180026160 (0x180026160)
    - _Init_thread_footer (0x180080C98)
  被以下函数调用:
    - sub_180077420 (0x180077420)
    - sub_1800779C0 (0x1800779C0)
    - sub_1800777E0 (0x1800777E0)
    - sub_180077AC0 (0x180077AC0)
    - sub_180077240 (0x180077240)
    - sub_1800775B0 (0x1800775B0)
    - sub_1800774D0 (0x1800774D0)

函数: _Init_thread_header (0x180080CF8)
  调用以下函数:
    - _Init_thread_wait (0x180080DA4)
  被以下函数调用:
    - GetAIFilePathSuite (0x180077E00)
    - sub_180070F60 (0x180070F60)
    - sub_18005C8D0 (0x18005C8D0)
    - sub_180023290 (0x180023290)
    - sub_1800683B0 (0x1800683B0)
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - sub_180052370 (0x180052370)
    - MainExport_fun (0x1800086F0)

函数: _Init_thread_wait (0x180080DA4)
  被以下函数调用:
    - _Init_thread_header (0x180080CF8)

函数: sub_180026160 (0x180026160)
  被以下函数调用:
    - GetAIFilePathSuite (0x180077E00)
    - sub_180023290 (0x180023290)
    - sub_180077420 (0x180077420)
    - sub_180065DA0 (0x180065DA0)
    - sub_1800775B0 (0x1800775B0)
    - sub_1800230B0 (0x1800230B0)
    - sub_1800683B0 (0x1800683B0)
    - sub_1800779C0 (0x1800779C0)
    - sub_180077AC0 (0x180077AC0)
    - InitializeZString_fun_p (0x18001EF40)
    - sub_180077240 (0x180077240)
    - sub_18005C840 (0x18005C840)
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - sub_1800774D0 (0x1800774D0)
    - sub_18005C8D0 (0x18005C8D0)
    - sub_1800777E0 (0x1800777E0)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - MainExport_fun (0x1800086F0)
    - sub_180052370 (0x180052370)

函数: _Init_thread_footer (0x180080C98)
  被以下函数调用:
    - GetAIFilePathSuite (0x180077E00)
    - sub_180070F60 (0x180070F60)
    - MainExport_fun (0x1800086F0)
    - sub_180023290 (0x180023290)
    - sub_1800683B0 (0x1800683B0)
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - sub_18005C8D0 (0x18005C8D0)
    - sub_180052370 (0x180052370)

函数: _CxxThrowException (0x18008189C)
  被以下函数调用:
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
    - sub_18007B580 (0x18007B580)
    - sub_180077420 (0x180077420)
    - sub_180065DA0 (0x180065DA0)
    - sub_18007B0A0 (0x18007B0A0)
    - sub_18004F220 (0x18004F220)
    - sub_1800775B0 (0x1800775B0)
    - sub_1800230B0 (0x1800230B0)
    - CreateUnicodeStringFromCString (0x18007AC30)
    - sub_180053DB0 (0x180053DB0)
    - sub_180052D30 (0x180052D30)
    - sub_1800779C0 (0x1800779C0)
    - sub_180077AC0 (0x180077AC0)
    - InitializeZString_fun_p (0x18001EF40)
    - sub_18007ACC0 (0x18007ACC0)
    - sub_180077240 (0x180077240)
    - sub_18005C840 (0x18005C840)
    - CStr2AIUnicodeString (0x18007B440)
    - sub_18007BCC0 (0x18007BCC0)
    - US_str_InitializeZString (0x18007ADD0)
    - sub_1800774D0 (0x1800774D0)
    - sub_1800777E0 (0x1800777E0)
    - sub_18007AA60 (0x18007AA60)
    - sub_18007B960 (0x18007B960)
    - sub_1800517E0 (0x1800517E0)
    - MainExport_fun (0x1800086F0)
    - sub_180022FF0 (0x180022FF0)
    - CopyUnicodeStr (0x18007A9F0)
    - sub_18007B5F0 (0x18007B5F0)
    - sub_180052C70 (0x180052C70)

函数: sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_18007B580 (0x18007B580)
    - sub_180077420 (0x180077420)
    - sub_180065DA0 (0x180065DA0)
    - sub_18007B0A0 (0x18007B0A0)
    - sub_18004F220 (0x18004F220)
    - sub_1800775B0 (0x1800775B0)
    - sub_1800230B0 (0x1800230B0)
    - CreateUnicodeStringFromCString (0x18007AC30)
    - sub_180052D30 (0x180052D30)
    - sub_180053DB0 (0x180053DB0)
    - sub_1800779C0 (0x1800779C0)
    - InitializeZString_fun_p (0x18001EF40)
    - sub_180077AC0 (0x180077AC0)
    - sub_18007ACC0 (0x18007ACC0)
    - sub_180077240 (0x180077240)
    - sub_18005C840 (0x18005C840)
    - CStr2AIUnicodeString (0x18007B440)
    - sub_18007BCC0 (0x18007BCC0)
    - US_str_InitializeZString (0x18007ADD0)
    - sub_1800774D0 (0x1800774D0)
    - sub_1800777E0 (0x1800777E0)
    - sub_18007AA60 (0x18007AA60)
    - sub_18007B960 (0x18007B960)
    - sub_1800517E0 (0x1800517E0)
    - CopyUnicodeStr (0x18007A9F0)
    - MainExport_fun (0x1800086F0)
    - sub_18007B5F0 (0x18007B5F0)

函数: sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - sub_180007C00 (0x180007C00)
    - sub_180007C80 (0x180007C80)
    - sub_180068710 (0x180068710)
    - sub_180023710 (0x180023710)
    - sub_180065DA0 (0x180065DA0)
    - sub_180064520 (0x180064520)
    - sub_180067D20 (0x180067D20)
    - sub_1800671B0 (0x1800671B0)
    - sub_1800079B0 (0x1800079B0)
    - sub_180064BB0 (0x180064BB0)
    - sub_18006F4B0 (0x18006F4B0)
    - sub_180006EC0 (0x180006EC0)
    - sub_180052F50 (0x180052F50)
    - sub_1800715D0 (0x1800715D0)
    - sub_1800719D0 (0x1800719D0)
    - sub_18006EFD0 (0x18006EFD0)
    - sub_180067660 (0x180067660)
    - sub_180027AE0 (0x180027AE0)
    - sub_180068160 (0x180068160)
    - sub_180070F60 (0x180070F60)
    - MainExport_fun (0x1800086F0)
    - sub_1800077F0 (0x1800077F0)

函数: sub_180008090 (0x180008090)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: AIContextSuite_Out (0x180009C10)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_180065DA0 (0x180065DA0)
  调用以下函数:
    - unknown_libname_1 (0x180004800)
    - sub_180009780 (0x180009780)
    - sub_180068280 (0x180068280)
    - sub_180007C00 (0x180007C00)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180009A00)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18008060D)
    - sub_180067F90 (0x180067F90)
    - _CxxThrowException (0x18008189C)
    - sub_180077420 (0x180077420)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_1800143A0 (0x1800143A0)
    - sub_180068320 (0x180068320)
    - sub_180064520 (0x180064520)
    - sub_180067D20 (0x180067D20)
    - sub_1800064A0 (0x1800064A0)
    - sub_1800671B0 (0x1800671B0)
    - sub_1800775B0 (0x1800775B0)
    - sub_1800230B0 (0x1800230B0)
    - sub_1800683B0 (0x1800683B0)
    - sub_1800779C0 (0x1800779C0)
    - sub_1800774D0 (0x1800774D0)
    - sub_180067950 (0x180067950)
    - sub_180068160 (0x180068160)
    - sub_180026160 (0x180026160)
    - sub_180027AE0 (0x180027AE0)
    - CopyUnicodeStr (0x18007A9F0)
    - sub_180022FF0 (0x180022FF0)
    - sub_180067A70 (0x180067A70)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - sub_18007B870 (0x18007B870)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_180009780 (0x180009780)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - sub_180006EC0 (0x180006EC0)
    - sub_180067DC0 (0x180067DC0)

函数: sub_180068280 (0x180068280)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)

函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180009A00)
  调用以下函数:
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - sub_180006EC0 (0x180006EC0)
    - sub_180067DC0 (0x180067DC0)

函数: ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
  被以下函数调用:
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180009A00)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20)
    - sub_1800537A0 (0x1800537A0)
    - sub_18004D200 (0x18004D200)
    - sub_18004C5C0 (0x18004C5C0)
    - sub_1800533C0 (0x1800533C0)
    - sub_18004CEF0 (0x18004CEF0)
    - sub_1800535B0 (0x1800535B0)
    - sub_18004C8D0 (0x18004C8D0)

函数: ?_Xout_of_range@std@@YAXPEBD@Z (0x18008060D)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - sub_180064BB0 (0x180064BB0)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x1800687A0)

函数: sub_180067F90 (0x180067F90)
  调用以下函数:
    - sub_180077AC0 (0x180077AC0)
    - sub_1800779C0 (0x1800779C0)
    - sub_1800777E0 (0x1800777E0)
    - sub_180067660 (0x180067660)
    - sub_180067560 (0x180067560)
    - sub_18007B870 (0x18007B870)
    - USS_UTF_16_str_buffer (0x18007BDD0)
    - US_str_UnInitIializeZString (0x18007AFF0)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)

函数: sub_180077AC0 (0x180077AC0)
  调用以下函数:
    - unknown_libname_1 (0x180004800)
    - GetAIFilePathSuite (0x180077E00)
    - sub_180026160 (0x180026160)
    - sub_1800064A0 (0x1800064A0)
    - _CxxThrowException (0x18008189C)
  被以下函数调用:
    - sub_180067F90 (0x180067F90)
    - sub_1800517E0 (0x1800517E0)

函数: sub_1800779C0 (0x1800779C0)
  调用以下函数:
    - unknown_libname_1 (0x180004800)
    - GetAIFilePathSuite (0x180077E00)
    - sub_180026160 (0x180026160)
    - sub_1800064A0 (0x1800064A0)
    - _CxxThrowException (0x18008189C)
  被以下函数调用:
    - sub_180067F90 (0x180067F90)
    - sub_180065DA0 (0x180065DA0)

函数: sub_1800777E0 (0x1800777E0)
  调用以下函数:
    - GetAIFilePathSuite (0x180077E00)
    - _CxxThrowException (0x18008189C)
    - sub_180026160 (0x180026160)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180067F90 (0x180067F90)

函数: sub_180067660 (0x180067660)
  调用以下函数:
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_180022FF0 (0x180022FF0)
    - US_str_UnInitIializeZString (0x18007AFF0)
  被以下函数调用:
    - sub_180067F90 (0x180067F90)

函数: ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
  调用以下函数:
    - sub_180006650 (0x180006650)
    - _CxxThrowException (0x18008189C)
  被以下函数调用:
    - sub_180067660 (0x180067660)
    - sub_18002F320 (0x18002F320)
    - sub_18004BB30 (0x18004BB30)
    - sub_180052F50 (0x180052F50)
    - sub_1800079B0 (0x1800079B0)
    - sub_180023710 (0x180023710)
    - sub_1800077F0 (0x1800077F0)

函数: sub_180006650 (0x180006650)
  被以下函数调用:
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)

函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20)
  调用以下函数:
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
  被以下函数调用:
    - sub_180067660 (0x180067660)
    - sub_180064520 (0x180064520)
    - sub_180067560 (0x180067560)
    - sub_1800079B0 (0x1800079B0)
    - sub_1800671B0 (0x1800671B0)
    - sub_1800077F0 (0x1800077F0)

函数: sub_180022FF0 (0x180022FF0)
  调用以下函数:
    - sub_180022FC0 (0x180022FC0)
    - _CxxThrowException (0x18008189C)
    - ?SPBasicAllocateBlock@ai@@YAH_KPEAPEAX@Z (0x18007F9DD)
  被以下函数调用:
    - sub_18004D200 (0x18004D200)
    - sub_180023710 (0x180023710)
    - ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z (0x18008061C)
    - sub_180065DA0 (0x180065DA0)
    - sub_18002F320 (0x18002F320)
    - sub_18004BB30 (0x18004BB30)
    - sub_1800079B0 (0x1800079B0)
    - sub_180064BB0 (0x180064BB0)
    - sub_180067DC0 (0x180067DC0)
    - sub_180006EC0 (0x180006EC0)
    - sub_18006E6C0 (0x18006E6C0)
    - sub_18004C5C0 (0x18004C5C0)
    - sub_1800673D0 (0x1800673D0)
    - sub_180052F50 (0x180052F50)
    - sub_18004C8D0 (0x18004C8D0)
    - sub_180067660 (0x180067660)
    - sub_180007460 (0x180007460)
    - sub_18004CEF0 (0x18004CEF0)
    - sub_1800077F0 (0x1800077F0)
    - MainExport_fun (0x1800086F0)

函数: sub_180022FC0 (0x180022FC0)
  被以下函数调用:
    - sub_180022FF0 (0x180022FF0)

函数: ?SPBasicAllocateBlock@ai@@YAH_KPEAPEAX@Z (0x18007F9DD)
  被以下函数调用:
    - sub_180022FF0 (0x180022FF0)

函数: US_str_UnInitIializeZString (0x18007AFF0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - sub_180026160 (0x180026160)
  被以下函数调用:
    - sub_180067660 (0x180067660)
    - sub_180065DA0 (0x180065DA0)
    - sub_180007C80 (0x180007C80)
    - sub_180006EC0 (0x180006EC0)
    - sub_18004EE60 (0x18004EE60)
    - sub_1800517E0 (0x1800517E0)
    - sub_1800079B0 (0x1800079B0)
    - sub_180067F90 (0x180067F90)
    - sub_1800671B0 (0x1800671B0)
    - sub_180064BB0 (0x180064BB0)
    - sub_18006F4B0 (0x18006F4B0)
    - sub_180053DB0 (0x180053DB0)
    - sub_180052D30 (0x180052D30)
    - MainExport_fun (0x1800086F0)

函数: GetAIUnicodeStringSuite (0x18007B4D0)
  调用以下函数:
    - _Init_thread_header (0x180080CF8)
    - sub_180026160 (0x180026160)
    - _Init_thread_footer (0x180080C98)
  被以下函数调用:
    - sub_18007B0A0 (0x18007B0A0)
    - sub_18007ACC0 (0x18007ACC0)
    - sub_18007B580 (0x18007B580)
    - sub_18007AA60 (0x18007AA60)
    - CStr2AIUnicodeString (0x18007B440)
    - sub_18007B920 (0x18007B920)
    - sub_18007B9E0 (0x18007B9E0)
    - sub_18007B960 (0x18007B960)
    - sub_18007BCC0 (0x18007BCC0)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - CopyUnicodeStr (0x18007A9F0)
    - sub_18007B870 (0x18007B870)
    - USS_UTF_16_str_buffer (0x18007BDD0)
    - US_str_InitializeZString (0x18007ADD0)
    - CreateUnicodeStringFromCString (0x18007AC30)
    - sub_18007BC90 (0x18007BC90)
    - sub_18007B5F0 (0x18007B5F0)

函数: InitializeZString_fun_p (0x18001EF40)
  调用以下函数:
    - sub_180026160 (0x180026160)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_18007B580 (0x18007B580)
    - sub_18007BC90 (0x18007BC90)
    - sub_18007B0A0 (0x18007B0A0)
    - sub_18007B920 (0x18007B920)
    - CreateUnicodeStringFromCString (0x18007AC30)
    - sub_18007ACC0 (0x18007ACC0)
    - CStr2AIUnicodeString (0x18007B440)
    - sub_18007BCC0 (0x18007BCC0)
    - USS_UTF_16_str_buffer (0x18007BDD0)
    - US_str_InitializeZString (0x18007ADD0)
    - sub_18007AA60 (0x18007AA60)
    - sub_18004EE60 (0x18004EE60)
    - sub_18007B9E0 (0x18007B9E0)
    - sub_18007B960 (0x18007B960)
    - sub_1800517E0 (0x1800517E0)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - CopyUnicodeStr (0x18007A9F0)
    - sub_18007B870 (0x18007B870)
    - sub_18007B5F0 (0x18007B5F0)

函数: sub_180067560 (0x180067560)
  调用以下函数:
    - sub_18004BB30 (0x18004BB30)
    - sub_180068710 (0x180068710)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20)
    - memmove (0x1800818B4)
  被以下函数调用:
    - sub_180067F90 (0x180067F90)
    - sub_180064520 (0x180064520)

函数: sub_18004BB30 (0x18004BB30)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
  被以下函数调用:
    - sub_180067560 (0x180067560)
    - sub_180064520 (0x180064520)

函数: sub_180068710 (0x180068710)
  调用以下函数:
    - sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - sub_180067560 (0x180067560)

函数: memmove (0x1800818B4)
  被以下函数调用:
    - sub_180067560 (0x180067560)
    - sub_180023710 (0x180023710)
    - sub_180068460 (0x180068460)
    - sub_1800077F0 (0x1800077F0)

函数: sub_18007B870 (0x18007B870)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
  被以下函数调用:
    - sub_1800537A0 (0x1800537A0)
    - sub_180065DA0 (0x180065DA0)
    - sub_180006EC0 (0x180006EC0)
    - sub_18004D200 (0x18004D200)
    - sub_180067F90 (0x180067F90)
    - sub_180067A70 (0x180067A70)

函数: USS_UTF_16_str_buffer (0x18007BDD0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
  被以下函数调用:
    - sub_180067F90 (0x180067F90)
    - sub_18004D200 (0x18004D200)
    - sub_1800537A0 (0x1800537A0)

函数: sub_1800143A0 (0x1800143A0)
  调用以下函数:
    - sub_1800147E0 (0x1800147E0)
    - sub_180014780 (0x180014780)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)

函数: sub_1800147E0 (0x1800147E0)
  被以下函数调用:
    - sub_1800143A0 (0x1800143A0)

函数: sub_180014780 (0x180014780)
  被以下函数调用:
    - sub_1800143A0 (0x1800143A0)

函数: sub_180068320 (0x180068320)
  调用以下函数:
    - sub_180007C00 (0x180007C00)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)

函数: sub_180064520 (0x180064520)
  调用以下函数:
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x1800687A0)
    - sub_180067560 (0x180067560)
    - sub_18000E0A0 (0x18000E0A0)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20)
    - sub_18004BB30 (0x18004BB30)
    - memset (0x180081896)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)

函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x1800687A0)
  调用以下函数:
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18008060D)
  被以下函数调用:
    - sub_180064520 (0x180064520)

函数: memset (0x180081896)
  被以下函数调用:
    - sub_180064520 (0x180064520)

函数: sub_180067D20 (0x180067D20)
  调用以下函数:
    - sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)

函数: sub_1800671B0 (0x1800671B0)
  调用以下函数:
    - sub_18002F320 (0x18002F320)
    - sub_1800674A0 (0x1800674A0)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_1800679C0 (0x1800679C0)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20)
    - US_str_UnInitIializeZString (0x18007AFF0)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - sub_180064BB0 (0x180064BB0)

函数: sub_18002F320 (0x18002F320)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
  被以下函数调用:
    - sub_1800671B0 (0x1800671B0)

函数: sub_1800674A0 (0x1800674A0)
  调用以下函数:
    - sub_18007B0A0 (0x18007B0A0)
  被以下函数调用:
    - sub_1800671B0 (0x1800671B0)

函数: sub_18007B0A0 (0x18007B0A0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_1800674A0 (0x1800674A0)
    - sub_180053DB0 (0x180053DB0)
    - sub_180006EC0 (0x180006EC0)

函数: sub_1800679C0 (0x1800679C0)
  调用以下函数:
    - CopyUnicodeStr (0x18007A9F0)
  被以下函数调用:
    - sub_1800671B0 (0x1800671B0)

函数: CopyUnicodeStr (0x18007A9F0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_1800679C0 (0x1800679C0)
    - sub_18004EE60 (0x18004EE60)
    - sub_180065DA0 (0x180065DA0)
    - sub_180006EC0 (0x180006EC0)

函数: sub_1800775B0 (0x1800775B0)
  调用以下函数:
    - GetAIFilePathSuite (0x180077E00)
    - _CxxThrowException (0x18008189C)
    - sub_180026160 (0x180026160)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - sub_180067DC0 (0x180067DC0)

函数: sub_1800230B0 (0x1800230B0)
  调用以下函数:
    - sub_18007ACC0 (0x18007ACC0)
    - sub_180026160 (0x180026160)
    - sub_1800065A0 (0x1800065A0)
    - sub_1800064A0 (0x1800064A0)
    - sub_180023290 (0x180023290)
    - US_str_InitializeZString (0x18007ADD0)
    - _CxxThrowException (0x18008189C)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)

函数: sub_18007ACC0 (0x18007ACC0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_1800230B0 (0x1800230B0)

函数: sub_1800065A0 (0x1800065A0)
  被以下函数调用:
    - sub_1800230B0 (0x1800230B0)
    - sub_18004F220 (0x18004F220)
    - sub_180052C70 (0x180052C70)
    - sub_1800517E0 (0x1800517E0)

函数: sub_180023290 (0x180023290)
  调用以下函数:
    - _Init_thread_header (0x180080CF8)
    - sub_180026160 (0x180026160)
    - _Init_thread_footer (0x180080C98)
  被以下函数调用:
    - sub_1800230B0 (0x1800230B0)

函数: US_str_InitializeZString (0x18007ADD0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_1800230B0 (0x1800230B0)
    - sub_18004EE60 (0x18004EE60)

函数: sub_1800683B0 (0x1800683B0)
  调用以下函数:
    - _Init_thread_header (0x180080CF8)
    - sub_180026160 (0x180026160)
    - _Init_thread_footer (0x180080C98)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)

函数: sub_1800774D0 (0x1800774D0)
  调用以下函数:
    - GetAIFilePathSuite (0x180077E00)
    - _CxxThrowException (0x18008189C)
    - sub_180026160 (0x180026160)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - MainExport_fun (0x1800086F0)
    - sub_180064BB0 (0x180064BB0)

函数: sub_180067950 (0x180067950)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - sub_180064BB0 (0x180064BB0)

函数: sub_180068160 (0x180068160)
  调用以下函数:
    - sub_180027AE0 (0x180027AE0)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_1800673D0 (0x1800673D0)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - sub_180064BB0 (0x180064BB0)

函数: sub_180027AE0 (0x180027AE0)
  调用以下函数:
    - sub_180027AE0 (0x180027AE0)
    - sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - sub_180068160 (0x180068160)
    - sub_180064BB0 (0x180064BB0)
    - sub_180065DA0 (0x180065DA0)
    - sub_180027AE0 (0x180027AE0)

函数: sub_1800673D0 (0x1800673D0)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
    - sub_1800673D0 (0x1800673D0)
  被以下函数调用:
    - sub_180068160 (0x180068160)
    - sub_1800673D0 (0x1800673D0)

函数: sub_180067A70 (0x180067A70)
  调用以下函数:
    - sub_18007B870 (0x18007B870)
  被以下函数调用:
    - sub_180065DA0 (0x180065DA0)
    - sub_180064BB0 (0x180064BB0)

函数: sub_18004F220 (0x18004F220)
  调用以下函数:
    - sub_18004CEF0 (0x18004CEF0)
    - sub_1800065A0 (0x1800065A0)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_18004CEF0 (0x18004CEF0)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
    - ceilf (0x1800818D2)
    - sub_1800535B0 (0x1800535B0)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
  被以下函数调用:
    - sub_18004F220 (0x18004F220)
    - sub_1800517E0 (0x1800517E0)

函数: ceilf (0x1800818D2)
  被以下函数调用:
    - sub_18004CEF0 (0x18004CEF0)
    - sub_18004D200 (0x18004D200)
    - sub_18004C8D0 (0x18004C8D0)
    - sub_18004C5C0 (0x18004C5C0)

函数: sub_1800535B0 (0x1800535B0)
  调用以下函数:
    - sub_180052F50 (0x180052F50)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
  被以下函数调用:
    - sub_18004CEF0 (0x18004CEF0)
    - sub_18004C8D0 (0x18004C8D0)

函数: sub_180052F50 (0x180052F50)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
    - sub_18004D530 (0x18004D530)
    - sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - sub_1800535B0 (0x1800535B0)
    - sub_1800537A0 (0x1800537A0)
    - sub_1800533C0 (0x1800533C0)

函数: sub_18004D530 (0x18004D530)
  被以下函数调用:
    - sub_180052F50 (0x180052F50)

函数: AIContextSuite_Put (0x180009BB0)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_1800079B0 (0x1800079B0)
  调用以下函数:
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_180022FF0 (0x180022FF0)
    - US_str_UnInitIializeZString (0x18007AFF0)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_180064BB0 (0x180064BB0)
  调用以下函数:
    - unknown_libname_1 (0x180004800)
    - sub_180068160 (0x180068160)
    - sub_180077420 (0x180077420)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_180067DC0 (0x180067DC0)
    - sub_180027AE0 (0x180027AE0)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18008060D)
    - sub_180022FF0 (0x180022FF0)
    - sub_1800671B0 (0x1800671B0)
    - sub_1800774D0 (0x1800774D0)
    - sub_180067A70 (0x180067A70)
    - sub_180067950 (0x180067950)
    - US_str_UnInitIializeZString (0x18007AFF0)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_180067DC0 (0x180067DC0)
  调用以下函数:
    - unknown_libname_1 (0x180004800)
    - sub_180077240 (0x180077240)
    - sub_180009780 (0x180009780)
    - sub_180077420 (0x180077420)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180009A00)
    - sub_180022FF0 (0x180022FF0)
    - sub_1800775B0 (0x1800775B0)
  被以下函数调用:
    - sub_180064BB0 (0x180064BB0)

函数: sub_180077240 (0x180077240)
  调用以下函数:
    - GetAIFilePathSuite (0x180077E00)
    - _CxxThrowException (0x18008189C)
    - sub_180026160 (0x180026160)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180067DC0 (0x180067DC0)
    - MainExport_fun (0x1800086F0)
    - sub_180007460 (0x180007460)

函数: sub_180006EC0 (0x180006EC0)
  调用以下函数:
    - sub_180009780 (0x180009780)
    - sub_18007B580 (0x18007B580)
    - sub_18007B0A0 (0x18007B0A0)
    - sub_180007C80 (0x180007C80)
    - sub_18000E0A0 (0x18000E0A0)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180009A00)
    - sub_180022FF0 (0x180022FF0)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - CopyUnicodeStr (0x18007A9F0)
    - sub_18007B870 (0x18007B870)
    - CreateUnicodeStringFromCString (0x18007AC30)
    - sub_18006F4B0 (0x18006F4B0)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_18007B580 (0x18007B580)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180006EC0 (0x180006EC0)
    - sub_180053DB0 (0x180053DB0)
    - sub_18006F4B0 (0x18006F4B0)

函数: sub_180007C80 (0x180007C80)
  调用以下函数:
    - sub_180007C80 (0x180007C80)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - sub_180006EC0 (0x180006EC0)
    - sub_180007C80 (0x180007C80)

函数: CreateUnicodeStringFromCString (0x18007AC30)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180006EC0 (0x180006EC0)

函数: sub_18006F4B0 (0x18006F4B0)
  调用以下函数:
    - sub_18007B420 (0x18007B420)
    - sub_18007B580 (0x18007B580)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_1800715D0 (0x1800715D0)
    - sub_180023710 (0x180023710)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - __security_check_cookie (0x180080B50)
  被以下函数调用:
    - sub_180006EC0 (0x180006EC0)

函数: sub_18007B420 (0x18007B420)
  调用以下函数:
    - sub_18007AA60 (0x18007AA60)
  被以下函数调用:
    - sub_18006F4B0 (0x18006F4B0)

函数: sub_18007AA60 (0x18007AA60)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_18007B420 (0x18007B420)

函数: sub_1800715D0 (0x1800715D0)
  调用以下函数:
    - sub_18006E6C0 (0x18006E6C0)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_18006EFD0 (0x18006EFD0)
    - __security_check_cookie (0x180080B50)
    - ?classic@locale@std@@SAAEBV12@XZ (0x180080672)
    - ?_Init@locale@std@@CAPEAV_Locimp@12@_N@Z (0x180080678)
  被以下函数调用:
    - sub_18006F4B0 (0x18006F4B0)

函数: sub_18006E6C0 (0x18006E6C0)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
    - ?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ (0x180080654)
    - ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z (0x18008061C)
    - sub_18006E9D0 (0x18006E9D0)
  被以下函数调用:
    - sub_1800715D0 (0x1800715D0)

函数: ?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ (0x180080654)
  被以下函数调用:
    - sub_18006E6C0 (0x18006E6C0)

函数: ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z (0x18008061C)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
  被以下函数调用:
    - sub_18006E6C0 (0x18006E6C0)

函数: sub_18006E9D0 (0x18006E9D0)
  调用以下函数:
    - sub_180006DD0 (0x180006DD0)
    - __security_check_cookie (0x180080B50)
    - memcpy (0x180081890)
    - ?_Xbad_alloc@std@@YAXXZ (0x1800805CB)
  被以下函数调用:
    - sub_18006E6C0 (0x18006E6C0)

函数: sub_180006DD0 (0x180006DD0)
  调用以下函数:
    - memcpy (0x180081890)
    - ?_Xbad_alloc@std@@YAXXZ (0x1800805CB)
  被以下函数调用:
    - sub_18006E9D0 (0x18006E9D0)

函数: memcpy (0x180081890)
  被以下函数调用:
    - sub_180006DD0 (0x180006DD0)
    - sub_180023710 (0x180023710)
    - sub_18006E9D0 (0x18006E9D0)

函数: ?_Xbad_alloc@std@@YAXXZ (0x1800805CB)
  被以下函数调用:
    - sub_180006DD0 (0x180006DD0)
    - sub_18006E9D0 (0x18006E9D0)

函数: __security_check_cookie (0x180080B50)
  被以下函数调用:
    - sub_180070F60 (0x180070F60)
    - sub_1800517E0 (0x1800517E0)
    - sub_18006E9D0 (0x18006E9D0)
    - sub_18006EFD0 (0x18006EFD0)
    - sub_1800715D0 (0x1800715D0)
    - sub_18006F4B0 (0x18006F4B0)
    - sub_1800719D0 (0x1800719D0)
    - MainExport_fun (0x1800086F0)
    - sub_180007D70 (0x180007D70)

函数: sub_18006EFD0 (0x18006EFD0)
  调用以下函数:
    - sub_1800719D0 (0x1800719D0)
    - memcmp (0x1800818A2)
    - __security_check_cookie (0x180080B50)
    - sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - sub_1800715D0 (0x1800715D0)

函数: sub_1800719D0 (0x1800719D0)
  调用以下函数:
    - sub_180023710 (0x180023710)
    - __security_check_cookie (0x180080B50)
    - sub_18000E0A0 (0x18000E0A0)
  被以下函数调用:
    - sub_18006EFD0 (0x18006EFD0)

函数: sub_180023710 (0x180023710)
  调用以下函数:
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_1 (0x1800149A0)
    - sub_18000E0A0 (0x18000E0A0)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
    - sub_180022FF0 (0x180022FF0)
    - memcpy (0x180081890)
    - memmove (0x1800818B4)
  被以下函数调用:
    - sub_1800719D0 (0x1800719D0)
    - sub_18006F4B0 (0x18006F4B0)

函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_1 (0x1800149A0)
  调用以下函数:
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
  被以下函数调用:
    - sub_180023710 (0x180023710)

函数: memcmp (0x1800818A2)
  被以下函数调用:
    - sub_18006EFD0 (0x18006EFD0)

函数: ?classic@locale@std@@SAAEBV12@XZ (0x180080672)
  被以下函数调用:
    - sub_1800715D0 (0x1800715D0)

函数: ?_Init@locale@std@@CAPEAV_Locimp@12@_N@Z (0x180080678)
  被以下函数调用:
    - sub_1800715D0 (0x1800715D0)

函数: sub_180070F60 (0x180070F60)
  调用以下函数:
    - sub_18005C840 (0x18005C840)
    - _Init_thread_header (0x180080CF8)
    - sub_18000E0A0 (0x18000E0A0)
    - __security_check_cookie (0x180080B50)
    - sub_180070390 (0x180070390)
    - _Init_thread_footer (0x180080C98)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_18005C840 (0x18005C840)
  调用以下函数:
    - sub_18005C8D0 (0x18005C8D0)
    - _CxxThrowException (0x18008189C)
    - sub_180026160 (0x180026160)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180070F60 (0x180070F60)

函数: sub_18005C8D0 (0x18005C8D0)
  调用以下函数:
    - _Init_thread_header (0x180080CF8)
    - sub_180026160 (0x180026160)
    - _Init_thread_footer (0x180080C98)
  被以下函数调用:
    - sub_18005C840 (0x18005C840)

函数: sub_180070390 (0x180070390)
  被以下函数调用:
    - sub_180070F60 (0x180070F60)

函数: sub_180068460 (0x180068460)
  调用以下函数:
    - memmove (0x1800818B4)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_18004EE60 (0x18004EE60)
  调用以下函数:
    - InitializeZString_fun_p (0x18001EF40)
    - US_str_InitializeZString (0x18007ADD0)
    - sub_180052D30 (0x180052D30)
    - sub_180052370 (0x180052370)
    - CopyUnicodeStr (0x18007A9F0)
    - US_str_UnInitIializeZString (0x18007AFF0)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_180052D30 (0x180052D30)
  调用以下函数:
    - unknown_libname_1 (0x180004800)
    - CStr2AIUnicodeString (0x18007B440)
    - sub_1800064A0 (0x1800064A0)
    - sub_180052C70 (0x180052C70)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - _CxxThrowException (0x18008189C)
  被以下函数调用:
    - sub_18004EE60 (0x18004EE60)

函数: CStr2AIUnicodeString (0x18007B440)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180052D30 (0x180052D30)

函数: sub_180052C70 (0x180052C70)
  调用以下函数:
    - sub_18007B920 (0x18007B920)
    - sub_1800065A0 (0x1800065A0)
    - sub_18007B9E0 (0x18007B9E0)
    - sub_18007BC90 (0x18007BC90)
    - sub_180053DB0 (0x180053DB0)
    - _CxxThrowException (0x18008189C)
  被以下函数调用:
    - sub_180052D30 (0x180052D30)

函数: sub_18007B920 (0x18007B920)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
  被以下函数调用:
    - sub_180052C70 (0x180052C70)

函数: sub_18007B9E0 (0x18007B9E0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
  被以下函数调用:
    - sub_180052C70 (0x180052C70)

函数: sub_18007BC90 (0x18007BC90)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
  被以下函数调用:
    - sub_180052C70 (0x180052C70)
    - sub_180053DB0 (0x180053DB0)

函数: sub_180053DB0 (0x180053DB0)
  调用以下函数:
    - sub_18007B960 (0x18007B960)
    - sub_18007B580 (0x18007B580)
    - sub_18007BCC0 (0x18007BCC0)
    - sub_18007B0A0 (0x18007B0A0)
    - sub_1800064A0 (0x1800064A0)
    - sub_18007BC90 (0x18007BC90)
    - sub_18007B5F0 (0x18007B5F0)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - _CxxThrowException (0x18008189C)
  被以下函数调用:
    - sub_180052C70 (0x180052C70)

函数: sub_18007B960 (0x18007B960)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180053DB0 (0x180053DB0)

函数: sub_18007BCC0 (0x18007BCC0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180053DB0 (0x180053DB0)

函数: sub_18007B5F0 (0x18007B5F0)
  调用以下函数:
    - GetAIUnicodeStringSuite (0x18007B4D0)
    - InitializeZString_fun_p (0x18001EF40)
    - _CxxThrowException (0x18008189C)
    - sub_1800064A0 (0x1800064A0)
  被以下函数调用:
    - sub_180053DB0 (0x180053DB0)

函数: sub_180052370 (0x180052370)
  调用以下函数:
    - _Init_thread_header (0x180080CF8)
    - sub_180026160 (0x180026160)
    - _Init_thread_footer (0x180080C98)
  被以下函数调用:
    - sub_18004EE60 (0x18004EE60)
    - sub_1800517E0 (0x1800517E0)

函数: sub_180007460 (0x180007460)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
    - sub_180077240 (0x180077240)
    - sub_180007460 (0x180007460)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)
    - sub_180007460 (0x180007460)

函数: sub_1800517E0 (0x1800517E0)
  调用以下函数:
    - sub_18004D200 (0x18004D200)
    - sub_180077AC0 (0x180077AC0)
    - sub_18004C5C0 (0x18004C5C0)
    - sub_1800250C0 (0x1800250C0)
    - InitializeZString_fun_p (0x18001EF40)
    - sub_1800065A0 (0x1800065A0)
    - sub_1800064A0 (0x1800064A0)
    - sub_18004CEF0 (0x18004CEF0)
    - sub_18004C8D0 (0x18004C8D0)
    - US_str_UnInitIializeZString (0x18007AFF0)
    - sub_180052370 (0x180052370)
    - __security_check_cookie (0x180080B50)
    - _CxxThrowException (0x18008189C)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_18004D200 (0x18004D200)
  调用以下函数:
    - sub_1800537A0 (0x1800537A0)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
    - USS_UTF_16_str_buffer (0x18007BDD0)
    - sub_180022FF0 (0x180022FF0)
    - ceilf (0x1800818D2)
    - sub_18007B870 (0x18007B870)
  被以下函数调用:
    - sub_1800517E0 (0x1800517E0)

函数: sub_1800537A0 (0x1800537A0)
  调用以下函数:
    - sub_180052F50 (0x180052F50)
    - sub_18007B870 (0x18007B870)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
    - USS_UTF_16_str_buffer (0x18007BDD0)
  被以下函数调用:
    - sub_18004D200 (0x18004D200)

函数: sub_18004C5C0 (0x18004C5C0)
  调用以下函数:
    - sub_180022FF0 (0x180022FF0)
    - ceilf (0x1800818D2)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
    - sub_1800533C0 (0x1800533C0)
  被以下函数调用:
    - sub_1800517E0 (0x1800517E0)

函数: sub_1800533C0 (0x1800533C0)
  调用以下函数:
    - sub_180052F50 (0x180052F50)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
  被以下函数调用:
    - sub_18004C5C0 (0x18004C5C0)

函数: sub_1800250C0 (0x1800250C0)
  被以下函数调用:
    - sub_1800517E0 (0x1800517E0)

函数: sub_18004C8D0 (0x18004C8D0)
  调用以下函数:
    - unknown_libname_1 (0x180004800)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x180080607)
    - sub_180022FF0 (0x180022FF0)
    - sub_1800535B0 (0x1800535B0)
    - ceilf (0x1800818D2)
  被以下函数调用:
    - sub_1800517E0 (0x1800517E0)

函数: sub_180075970 (0x180075970)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_1800077F0 (0x1800077F0)
  调用以下函数:
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006800)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20)
    - sub_18000E0A0 (0x18000E0A0)
    - sub_180022FF0 (0x180022FF0)
    - memmove (0x1800818B4)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: GetAssetSelectionPath22 (0x18007C470)
  调用以下函数:
    - unknown_libname_1 (0x180004800)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_180007D70 (0x180007D70)
  调用以下函数:
    - sub_180009660 (0x180009660)
    - sub_180009610 (0x180009610)
    - __security_check_cookie (0x180080B50)
  被以下函数调用:
    - MainExport_fun (0x1800086F0)

函数: sub_180009660 (0x180009660)
  被以下函数调用:
    - sub_180007D70 (0x180007D70)

函数: sub_180009610 (0x180009610)
  被以下函数调用:
    - sub_180007D70 (0x180007D70)

// ========== 伪代码 ==========
// ===== 函数: MainExport_fun (0x1800086F0) =====
// 好的，这是一个非常核心、功能极其复杂的函数。分析报告中庞大的调用图已经预示了这一点。
// 
// sub_1800086F0 的作用
// 这个函数 sub_1800086F0 是**“智能导出”功能的核心执行引擎**。当用户在面板上设置好一切并点击“导出”按钮时，就是这个函数在负责处理整个导出流程。
// 
// 它负责收集所有需要导出的资源、解析用户的导出设置，并根据情况智能地选择最高效的导出方式（前景或后台），最终完成文件的生成。
// 
// 参数的意思是什么 📝
// a1: 一个资源列表（其结构类似于 std::vector<AssetItem*>），包含了面板中所有待处理的资源项目。函数会从这个总列表中筛选出用户实际勾选的那些来进行处理。
// 
// a2: 一个指向导出设置结构体的指针。这个结构体里包含了用户在UI上配置的所有信息，比如导出格式（PNG, SVG等）、尺寸、缩放比例、文件名前缀、目标文件夹路径等等。
// 
// a3: 一个导出上下文或控制器对象。它可能用于在导出过程中更新进度条、或者响应用户的“取消”操作。
// 
// 核心逻辑：智能的导出路径选择
// 这个函数最“智能”的地方在于它会根据情况选择不同的导出方式，这主要体现在伪代码中 v22 = sub_180070F60(v4) && !v6; 这一关键判断上：
// 
// 前景导出 (Foreground Export):
// 
// 触发条件: 如果用户选中的资源包含了复杂的动态对象（比如重复图案，v6 为 true），或者系统/用户设置禁用了后台导出（sub_180070F60 返回 false）。
// 
// 行为: 程序会采用安全的前景模式进行导出。这种模式下，可能会弹出“文件已存在”的确认框（如 sub_180064BB0 的功能），并且在导出完成前，Illustrator界面可能会被锁定（显示一个进度条）。
// 
// 后台导出 (Background Export):
// 
// 触发条件: 如果条件允许（系统支持、用户开启、且资源类型简单），函数会启动一个后台任务来执行导出。
// 
// 行为: sub_18004EE60 函数会利用 AITaskManager（任务管理器）来启动后台导出流程。这意味着导出工作会在后台线程中进行，用户可以立即返回继续编辑文档，无需等待，极大地提升了工作效率。
// 
// 详细工作流程 ⚙️
// 准备工作: 函数开始时会清理当前工作环境（如退出隔离模式）、设置一个“撤销”点以便用户可以撤销此次导出操作。
// 
// 筛选并检查资源: 遍历输入的总资源列表 a1，只把用户标记为“已选中”的资源挑出来。同时，调用 GetArtHandlesFromAsset 等API深入检查这些资源，判断其中是否包含不支持后台导出的“重复图案”等特殊对象。
// 
// 选择导出路径: 根据上一步的检查结果和系统设置，决定是走“前景导出”还是“后台导出”的逻辑分支。
// 
// 调用核心导出API: 根据选择的路径，调用 gAISmartExportSuite 中对应的核心导出函数（如 ProcessAssetExportWithEntitlementAndFeatureCheck 或 ExportAssetsWithEntitlementCheck）来执行真正的文件生成工作。
// 
// 结果处理与UI更新: 导出完成后（对于后台任务，可能是在任务结束时通过回调），可能会调用 sub_1800517E0 等函数来处理结果，比如弹出“导出成功”的提示，或者更新UI状态。
// 
// 清理: 在函数的末尾，有大量的清理代码，负责释放所有在函数中为了处理导出任务而临时创建的列表和对象，确保没有内存泄漏。
//       DocDateByAIDocumentHandle = GetDocDateByAIDocumentHandle(pSmartExportManager, &v45);
//       v28 = MainExport_fun(*DocDateByAIDocumentHandle, ExportJob, &v48);
__int64 __fastcall MainExport_fun(__int64 **std_vector_AssetItem__, __int64 ExportJob, __int64 v_set1)
{
  __int64 v4; // r15
  __int64 v6; // rdx
  void **v7; // r8
  bool v8; // si
  __int64 *v9; // r14
  __int64 *v10; // r12
  __int64 v11; // r13
  double v12; // xmm0_8
  _QWORD *AssetSelectionPath22; // rax
  void (__fastcall *GetArtHandlesFromAsset_fun)(__int64, __int128 *); // rdi
  __int64 v15; // rcx
  ai *v16; // rdi
  ai *v17; // r15
  __int64 v18; // r13
  __int64 v19; // rsi
  int v20; // eax
  _QWORD *v21; // rax
  int v22; // eax
  char *v23; // rdx
  ai *v24; // rax
  void **v25; // r8
  bool v26; // di
  __int64 v27; // rax
  unsigned int v28; // esi
  ai *v29; // rcx
  char *v30; // rdx
  __int64 (__fastcall *ExportAssetsWithEntitlementCheck_)(__int128 *, __int64, __int64, _BYTE *); // rbx
  __int64 v32; // rax
  __int64 v33; // rdx
  void **v34; // r8
  unsigned __int64 v35; // rax
  __int64 v36; // rax
  __int64 **v37; // rdx
  __int64 *i; // rcx
  __int64 v39; // rcx
  __int64 j; // rax
  _BYTE *v41; // rdx
  ai *v42; // rcx
  ai *v43; // rdi
  ai *v44; // rbx
  _BYTE *v45; // rdx
  void (__fastcall *v46)(_QWORD *); // rbx
  _QWORD *v47; // rax
  _QWORD *v48; // rbx
  _QWORD *v49; // rdi
  char *v50; // rdx
  char *v51; // rax
  ai *v52; // rcx
  char *v53; // rdx
  __int128 v55; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int8 v56[8]; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v57; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v58; // [rsp+50h] [rbp-B0h] BYREF
  _QWORD v59[2]; // [rsp+58h] [rbp-A8h] BYREF
  void *v60[2]; // [rsp+68h] [rbp-98h] BYREF
  _BYTE *v61; // [rsp+78h] [rbp-88h]
  __int128 v62; // [rsp+80h] [rbp-80h] BYREF
  __int64 v63; // [rsp+90h] [rbp-70h]
  __int128 v64; // [rsp+98h] [rbp-68h] BYREF
  __int64 v65; // [rsp+A8h] [rbp-58h]
  char v66[8]; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v67; // [rsp+B8h] [rbp-48h]
  _BYTE v68[56]; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v69; // [rsp+F8h] [rbp-8h]
  _BYTE pExceptionObject[56]; // [rsp+140h] [rbp+40h] BYREF
  _BYTE *v71; // [rsp+178h] [rbp+78h]

  v67 = -2LL;
  v4 = ExportJob;
  v59[0] = ExportJob;
  v64 = 0LL;
  v65 = 0LL;
  *v60 = 0LL;
  v61 = 0LL;
  AIContextSuite_Put(v66, *(gAISmartExportUI_app + 8), 0);
  (*(gAIUndoSuite + 72LL))(1LL);
  if ( (*(gAIIsolationMode + 24))() )
    (*(gAIIsolationMode + 8))();
  sub_180006EC0(std_vector_AssetItem__, v6, v7);
  v56[1] = 1;
  v8 = 0;
  v9 = *std_vector_AssetItem__;
  v10 = std_vector_AssetItem__[1];
  *&v55 = v10;
  if ( v9 != v10 )
  {
    v11 = TlsIndex;
    do
    {
      if ( sub_180075970(*v9) )
      {
        v12 = sub_18007C400(*v9);
        v58 = *&v12;
        if ( *(&v64 + 1) == v65 )
        {
          sub_1800077F0(&v64, *(&v64 + 1), &v58);
        }
        else
        {
          **(&v64 + 1) = v12;
          *(&v64 + 1) += 8LL;
        }
        AssetSelectionPath22 = GetAssetSelectionPath22(*v9, &v57);
        if ( v60[1] == v61 )
        {
          sub_1800079B0(v60, v60[1], AssetSelectionPath22);
        }
        else
        {
          *v60[1] = *AssetSelectionPath22;
          *AssetSelectionPath22 = 0LL;
          v60[1] = v60[1] + 8;
        }
        US_str_UnInitIializeZString(&v57);
        if ( !v8 )
        {
          v62 = 0LL;
          v63 = 0LL;
          //     /*15*/ AIErr(*GetArtHandlesFromAsset); // 【资源管理】同[11]，根据资源ID获取图稿句柄（兼容不同版本的图稿访问接口）
          GetArtHandlesFromAsset_fun = *(gAISmartExportSuite + 120LL);
          sub_18007C400(*v9);
          GetArtHandlesFromAsset_fun(v15, &v62);
          v17 = *(&v62 + 1);
          v16 = v62;
          if ( v62 != *(&v62 + 1) )
          {
            v18 = *(NtCurrentTeb()->ThreadLocalStoragePointer + v11);
            do
            {
              v19 = *v16;
              if ( dword_1800F2518[0] > *(v18 + 4) )
              {
                Init_thread_header(dword_1800F2518);
                if ( dword_1800F2518[0] == -1 )
                {
                  xmmword_1800F24F8 = 0LL;
                  qword_1800F2508 = "AI Repeat Private Suite";
                  dword_1800F2510 = 1;
                  byte_1800F2514 = 0;
                  Init_thread_footer(dword_1800F2518);
                }
              }
              if ( !*(&xmmword_1800F24F8 + 1) && qword_1800F45C0 )
              {
                v20 = (*qword_1800F45C0)(qword_1800F2508, dword_1800F2510, &xmmword_1800F24F8 + 8);
                if ( v20 )
                {
                  sub_1800064A0(pExceptionObject, v20, 0LL);
                  throw pExceptionObject;
                }
                if ( !byte_1800F2514 )
                {
                  v21 = sub_180026160();
                  *&xmmword_1800F24F8 = *v21;
                  *v21 = &xmmword_1800F24F8;
                }
              }
              v22 = (*(*(&xmmword_1800F24F8 + 1) + 304LL))(v19);
              v8 = v22 != 0;
              if ( v22 )
                break;
              v16 = (v16 + 8);
            }
            while ( v16 != v17 );
            v16 = v62;
            v10 = v55;
            v11 = TlsIndex;
          }
          if ( v16 )
          {
            v23 = (8 * ((v63 - v16) >> 3));
            v24 = v16;
            if ( v23 >= 0x1000 )
            {
              v23 += 39;
              v16 = *(v16 - 1);
              if ( (v24 - v16 - 8) > 0x1F )
                invalid_parameter_noinfo_noreturn();
            }
            sub_18000E0A0(v16, v23);
          }
        }
      }
      v9 += 2;
    }
    while ( v9 != v10 );
    v4 = v59[0];
  }
  v26 = sub_180070F60(v4) && !v8;
  if ( !*(v4 + 8) )
    goto LABEL_56;
  v59[0] = v_set1;
  if ( v_set1 )
  {
    if ( *v_set1 )
    {
      v_set1 = 0LL;
      v59[0] = 0LL;
    }
    else
    {
      if ( gAIDevUtilsSuite )
      {
        v27 = (*(gAIDevUtilsSuite + 112LL))(*(v_set1 + 16));
        *(v_set1 + 8) = (*(gAIDevUtilsSuite + 64LL))(*(v_set1 + 8), v27);
      }
      *v_set1 = 1;
    }
  }
  if ( v26 )
  {
    v62 = 0LL;
    v63 = 0LL;
    v28 = sub_180065DA0(v60, v4, &v62);
    if ( !v28 )
      v28 = sub_180068460(&v64, &v62);
    v29 = v62;
    if ( v62 )
    {
      v30 = (4 * ((v63 - v62) >> 2));
      if ( v30 >= 0x1000 )
      {
        v30 += 39;
        v29 = *(v62 - 8);
        if ( (v62 - v29 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18000E0A0(v29, v30);
    }
  }
  else
  {
    v28 = sub_180064BB0(v60, v4, v25);
  }
  if ( v_set1 )
  {
    if ( gAIDevUtilsSuite )
      *(v_set1 + 16) = (*(gAIDevUtilsSuite + 56LL))();
    *v_set1 = 0;
  }
  if ( !v28 )
  {
LABEL_56:
    unknown_libname_1(&v57);
    sub_1800774D0(&v57, v4);
    if ( !v26 )
    {
      // AIErr (*DispatchSmartExport)(__int64 **a1, __int64 a2);
      v28 = (*(gAISmartExportSuite + 128LL))(&v64, v4);
      if ( !v28 && *(gAISmartExportUI_app + 616) )
      {
        v46 = *(gAIUserSuite + 480LL);
        v47 = sub_180077240(v59, &v57);
        v46(v47);
      }
      goto LABEL_79;
    }
    v28 = sub_18004EE60(gAISmartExportUI_app, &v58);
    if ( v28 )
    {
LABEL_79:
      sub_180077420(&v57);
      goto LABEL_80;
    }
    sub_18004F220(gAISmartExportUI_app, &v58);
    v71 = 0LL;
    // AIErr (*ExportAssetsWithEntitlementCheck)(int a1, int a2, __int64 a3, __int64 a4);
    ExportAssetsWithEntitlementCheck_ = *(gAISmartExportSuite + 136LL);
    v32 = sub_180007D70(v68, sub_180051FE0, sub_18004F8F0, v58);
    v28 = ExportAssetsWithEntitlementCheck_(&v64, v4, v32, pExceptionObject);
    v55 = 0LL;
    v59[0] = &v55;
    v59[1] = &v55;
    v35 = sub_180022FF0(0x28, v33, v34);
    *v35 = v35;
    *(v35 + 8) = v35;
    *(v35 + 16) = v35;
    *(v35 + 24) = 257;
    *&v55 = v35;
    v36 = sub_180007460(&v55, *(*(v4 + 16) + 8LL), v35, v56[0]);
    *(v55 + 8) = v36;
    *(&v55 + 1) = *(v4 + 24);
    v37 = *(v55 + 8);
    if ( *(v37 + 25) )
    {
      *v55 = v55;
      *(v55 + 16) = v55;
    }
    else
    {
      for ( i = *v37; !*(i + 25); i = *i )
        v37 = i;
      *v55 = v37;
      v39 = *(v55 + 8);
      for ( j = *(v39 + 16); !*(j + 25); j = *(j + 16) )
        v39 = j;
      *(v55 + 16) = v39;
    }
    v69 = 0LL;
    if ( v71 )
    {
      if ( v71 != pExceptionObject )
      {
        v69 = v71;
        goto LABEL_70;
      }
      v69 = (*(*v71 + 8LL))(v71, v68);
      if ( v71 )
      {
        v41 = pExceptionObject;
        LOBYTE(v41) = v71 != pExceptionObject;
        (*(*v71 + 32LL))(v71, v41);
LABEL_70:
        v71 = 0LL;
      }
    }
    sub_1800517E0(gAISmartExportUI_app, v28, v58, v68, &v55, &v57);
    v42 = v55;
    v43 = *(v55 + 8);
    if ( !*(v43 + 25) )
    {
      do
      {
        sub_180007C00(&v55, &v55, *(v43 + 2));
        v44 = v43;
        v43 = *v43;
        sub_180077420(v44 + 4);
        sub_18000E0A0(v44, 0x28);
      }
      while ( !*(v43 + 25) );
      v42 = v55;
    }
    sub_18000E0A0(v42, 0x28);
    if ( v71 )
    {
      v45 = pExceptionObject;
      LOBYTE(v45) = v71 != pExceptionObject;
      (*(*v71 + 32LL))(v71, v45);
    }
    goto LABEL_79;
  }
LABEL_80:
  sub_180008090(v56);
  AIContextSuite_Out(v66);
  v48 = v60[0];
  if ( v60[0] )
  {
    v49 = v60[1];
    if ( v60[0] != v60[1] )
    {
      do
        US_str_UnInitIializeZString(v48++);
      while ( v48 != v49 );
      v48 = v60[0];
    }
    v50 = (8 * ((v61 - v48) >> 3));
    v51 = v48;
    if ( v50 >= 0x1000 )
    {
      v50 += 39;
      v48 = *(v48 - 1);
      if ( (v51 - v48 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18000E0A0(v48, v50);
    *v60 = 0LL;
    v61 = 0LL;
  }
  v52 = v64;
  if ( v64 )
  {
    v53 = ((v65 - v64) & 0xFFFFFFFFFFFFFFF8uLL);
    if ( v53 >= 0x1000 )
    {
      v53 += 39;
      v52 = *(v64 - 8);
      if ( (v64 - v52 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18000E0A0(v52, v53);
  }
  return v28;
}


// ===== 函数: sub_18007C400 (0x18007C400) =====
double __fastcall sub_18007C400(__int64 a1)
{
  return *(a1 + 40);
}


// ===== 函数: unknown_libname_1 (0x180004800) =====
// Microsoft VisualC v7/14 64bit runtime
_QWORD *__fastcall unknown_libname_1(_QWORD *a1)
{
  *a1 = 0LL;
  return a1;
}


// ===== 函数: sub_180007C00 (0x180007C00) =====
__int64 __fastcall sub_180007C00(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*(i + 25); result = sub_18000E0A0(v6) )
  {
    sub_180007C00(a1, a2, *(i + 16));
    v6 = i;
    i = *i;
    sub_180077420((v6 + 32));
  }
  return result;
}


// ===== 函数: sub_180077420 (0x180077420) =====
void __fastcall sub_180077420(_QWORD *a1)
{
  __int128 *AIFilePathSuite; // rax
  __int128 *v3; // rbx
  int v4; // eax
  _QWORD *v5; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  if ( *a1 )
  {
    try
    {
      AIFilePathSuite = GetAIFilePathSuite();
      v3 = AIFilePathSuite;
      if ( !*(AIFilePathSuite + 1) && qword_1800F45C0 )
      {
        v4 = (*qword_1800F45C0)(*(AIFilePathSuite + 2), *(AIFilePathSuite + 6), AIFilePathSuite + 8);
        if ( v4 )
        {
          sub_1800064A0(pExceptionObject, v4, 0LL);
          throw pExceptionObject;
        }
        if ( !*(v3 + 28) )
        {
          v5 = sub_180026160();
          *v3 = *v5;
          *v5 = v3;
        }
      }
      (*(*(v3 + 1) + 8LL))(a1);
    }
    catch ( ... )
    {
    }
  }
}


// ===== 函数: GetAIFilePathSuite (0x180077E00) =====
__int128 *GetAIFilePathSuite()
{
  __int64 v1; // rcx
  _QWORD *v2; // rax

  if ( dword_1800F6558 <= *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4LL) )
    return &xmmword_1800F6538;
  Init_thread_header(&dword_1800F6558);
  if ( dword_1800F6558 != -1 )
    return &xmmword_1800F6538;
  xmmword_1800F6538 = 0LL;
  qword_1800F6548 = "AI File Path Suite";
  dword_1800F6550 = 8;
  byte_1800F6554 = 1;
  v2 = sub_180026160(v1);
  *&xmmword_1800F6538 = *v2;
  *v2 = &xmmword_1800F6538;
  Init_thread_footer(&dword_1800F6558);
  return &xmmword_1800F6538;
}


// ===== 函数: _Init_thread_header (0x180080CF8) =====
void __fastcall Init_thread_header(_DWORD *a1)
{
  EnterCriticalSection(&CriticalSection);
  while ( 1 )
  {
    if ( !*a1 )
    {
      *a1 = -1;
      goto LABEL_7;
    }
    if ( *a1 != -1 )
      break;
    Init_thread_wait(0x64u);
  }
  *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4LL) = dword_1800E2EB4;
LABEL_7:
  LeaveCriticalSection(&CriticalSection);
}


// ===== 函数: _Init_thread_wait (0x180080DA4) =====
void __fastcall Init_thread_wait(DWORD dwMilliseconds)
{
  if ( qword_1800F6678 )
  {
    qword_1800F6678(&unk_1800F6640, &CriticalSection, dwMilliseconds);
  }
  else
  {
    LeaveCriticalSection(&CriticalSection);
    WaitForSingleObjectEx(hHandle, dwMilliseconds, 0);
    EnterCriticalSection(&CriticalSection);
  }
}


// ===== 函数: sub_180026160 (0x180026160) =====
void *sub_180026160()
{
  return &unk_1800F45C8;
}


// ===== 函数: _Init_thread_footer (0x180080C98) =====
__int64 __fastcall Init_thread_footer(_DWORD *a1)
{
  __int64 v2; // rdx

  EnterCriticalSection(&CriticalSection);
  v2 = TlsIndex;
  *a1 = ++dword_1800E2EB4;
  *(*(NtCurrentTeb()->ThreadLocalStoragePointer + v2) + 4LL) = dword_1800E2EB4;
  LeaveCriticalSection(&CriticalSection);
  return Init_thread_notify();
}


// ===== 函数: _CxxThrowException (0x18008189C) =====
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}


// ===== 函数: sub_1800064A0 (0x1800064A0) =====
__int64 __fastcall sub_1800064A0(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // rax

  *(a1 + 8) = 0LL;
  *a1 = &ai::Error::`vftable';
  result = a1;
  *(a1 + 24) = a2;
  *(a1 + 32) = a3;
  return result;
}


// ===== 函数: sub_18000E0A0 (0x18000E0A0) =====
// attributes: thunk
int __fastcall sub_18000E0A0(ai *a1, void *a2)
{
  return sub_180023090(a1, a2);
}


// ===== 函数: sub_180008090 (0x180008090) =====
__int64 __fastcall sub_180008090(__int64 a1)
{
  __int64 result; // rax

  if ( *(a1 + 1) )
  {
    try
    {
      result = (*(gAIUndoSuite + 32LL))(a1);
    }
    catch ( ... )
    {
    }
  }
  return result;
}


// ===== 函数: AIContextSuite_Out (0x180009C10) =====
__int64 __fastcall AIContextSuite_Out(__int64 *a1)
{
  __int64 result; // rax
  __int64 v3; // rcx

  result = gAIContextSuite;
  if ( gAIContextSuite )
  {
    v3 = *a1;
    if ( v3 )
    {
      result = (*(gAIContextSuite + 16))(v3);
      *a1 = 0LL;
    }
  }
  return result;
}


// ===== 函数: sub_180065DA0 (0x180065DA0) =====
__int64 __fastcall sub_180065DA0(_QWORD *a1, __int64 a2, void **a3)
{
  _QWORD *v3; // r13
  _QWORD *v4; // r14
  unsigned __int64 v5; // rax
  __int64 v6; // rdx
  void **v7; // r8
  unsigned __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // r8
  __int64 *v11; // rbx
  unsigned __int8 v12; // di
  __int64 v13; // rcx
  char v14; // r10
  __int64 v15; // rax
  __int128 *v16; // rdx
  __int64 v17; // rsi
  __int64 v18; // rax
  _QWORD *v19; // r15
  _QWORD *v20; // r14
  _QWORD *v21; // rsi
  __int64 v22; // r13
  unsigned int v23; // esi
  _QWORD *v24; // r12
  __int64 v25; // rdx
  __int64 v26; // rcx
  void **v27; // r8
  _QWORD *v28; // r14
  __int64 *v29; // rsi
  _QWORD *v30; // r15
  unsigned __int64 v31; // rax
  _QWORD *v32; // rsi
  __int64 v33; // rax
  __int64 **v34; // rax
  __int64 *i; // rax
  __int64 *j; // rcx
  unsigned int v37; // r12d
  char *v38; // rsi
  char *v39; // r15
  __int64 v40; // r14
  __int64 v41; // rax
  __int64 v42; // rbx
  int v43; // eax
  _QWORD *v44; // rax
  __int64 *m; // rcx
  __int64 *v46; // rdi
  __int64 *v47; // rbx
  __int64 v48; // rbx
  unsigned __int64 v49; // rdi
  _QWORD *v50; // rbx
  __int64 v51; // rax
  int v52; // edi
  __int64 k; // rax
  _QWORD *v54; // rax
  __int64 n; // rcx
  __int64 *ii; // rcx
  __int64 v57; // rbx
  unsigned __int64 v58; // rax
  unsigned __int64 v59; // rcx
  unsigned int v60; // eax
  __int64 v61; // rax
  __int64 v62; // rcx
  __int64 v63; // rcx
  char *jj; // rbx
  char *v65; // rax
  __int64 v66; // rcx
  __int64 v67; // rdi
  __int64 v68; // rbx
  __int64 v69; // rcx
  __int64 v70; // rbx
  __int64 v71; // rcx
  _QWORD *v73; // [rsp+20h] [rbp-E0h] BYREF
  unsigned __int64 v74; // [rsp+28h] [rbp-D8h]
  __int64 v75; // [rsp+30h] [rbp-D0h] BYREF
  _QWORD *v76; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int64 v77; // [rsp+40h] [rbp-C0h]
  __int128 pExceptionObject; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v79; // [rsp+58h] [rbp-A8h]
  __int64 v80; // [rsp+70h] [rbp-90h]
  __int64 v81; // [rsp+78h] [rbp-88h] BYREF
  __int128 v82; // [rsp+80h] [rbp-80h] BYREF
  _OWORD v83[2]; // [rsp+90h] [rbp-70h] BYREF
  void *v84[2]; // [rsp+B0h] [rbp-50h] BYREF
  __int128 v85; // [rsp+C0h] [rbp-40h]
  __int128 v86; // [rsp+D0h] [rbp-30h]
  _QWORD v87[2]; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v88; // [rsp+F0h] [rbp-10h]
  __int64 v89; // [rsp+F8h] [rbp-8h]
  __int64 v93; // [rsp+168h] [rbp+68h] BYREF

  v89 = -2LL;
  v3 = a2;
  v4 = a1;
  v82 = 0LL;
  v5 = sub_180022FF0(0x20, a2, a3);
  *v5 = v5;
  *(v5 + 8) = v5;
  *(v5 + 16) = v5;
  *(v5 + 24) = 257;
  *&v82 = v5;
  sub_180068160(v3, &v82);
  unknown_libname_1(&v81);
  sub_1800774D0(&v81, v3);
  v74 = 0LL;
  v8 = sub_180022FF0(0x28, v6, v7);
  *v8 = v8;
  *(v8 + 8) = v8;
  *(v8 + 16) = v8;
  *(v8 + 24) = 257;
  v73 = v8;
  *v84 = 0LL;
  v85 = 0LL;
  v86 = 0LL;
  v11 = *v82;
  if ( *(*v82 + 25LL) )
    goto LABEL_62;
  v12 = v93;
  do
  {
    pExceptionObject = 0LL;
    v79 = 0LL;
    v9 = v3[6];
    v13 = *(v9 + 8);
    v10 = v9;
    v14 = *(v13 + 25);
    if ( !v14 )
    {
      v15 = *(v9 + 8);
      do
      {
        if ( *(v15 + 32) >= *(v11 + 26) )
        {
          v10 = v15;
          v15 = *v15;
        }
        else
        {
          v15 = *(v15 + 16);
        }
      }
      while ( !*(v15 + 25) );
    }
    if ( *(v10 + 25) || *(v11 + 26) < *(v10 + 32) || v10 == v9 )
    {
      v19 = 0LL;
      v80 = 0LL;
    }
    else
    {
      if ( !v14 )
      {
        do
        {
          if ( *(v13 + 32) >= *(v11 + 26) )
          {
            v9 = v13;
            v13 = *v13;
          }
          else
          {
            v13 = *(v13 + 16);
          }
        }
        while ( !*(v13 + 25) );
      }
      if ( *(v9 + 25) || *(v11 + 26) < *(v9 + 32) )
      {
        std::_Xout_of_range("invalid map<K, T> key");
LABEL_128:
        std::vector<void *>::_Xlen(v26);
      }
      v16 = (v9 + 40);
      if ( &pExceptionObject != v16 )
        sub_1800671B0(&pExceptionObject, *v16, *(v16 + 1), v12);
      v17 = *(&pExceptionObject + 1);
      sub_180067A70(v87, pExceptionObject, *(&pExceptionObject + 1), 0LL);
      v10 = v87[0];
      if ( v87[0] == v17 )
      {
        v19 = *(&pExceptionObject + 1);
        v80 = *(&pExceptionObject + 1);
        goto LABEL_29;
      }
      v18 = sub_180067950(v17, *(&pExceptionObject + 1));
      v19 = v18;
      v80 = v18;
      v20 = *(&pExceptionObject + 1);
      if ( v18 != *(&pExceptionObject + 1) )
      {
        v21 = (v18 + 8);
        do
        {
          US_str_UnInitIializeZString(v21 + 1);
          US_str_UnInitIializeZString(v21);
          v21 += 5;
        }
        while ( v21 - 1 != v20 );
      }
      v4 = a1;
    }
    *(&pExceptionObject + 1) = v19;
LABEL_29:
    v22 = pExceptionObject;
    if ( pExceptionObject == v19 )
      goto LABEL_46;
    do
    {
      v23 = 0;
      v24 = *v4;
      v76 = v4[1];
      if ( v24 == v76 )
        goto LABEL_44;
      do
      {
        unknown_libname_1(&v75);
        (*(gAISmartExportSuite + 56LL))(v24, v22, &v81, &v75);
        LODWORD(v93) = v23 + 1;
        sub_180067F90(&v75, v84, v23);
        v28 = v73;
        v29 = v73[1];
        *&v83[0] = v29;
        DWORD2(v83[0]) = 0;
        v30 = v73;
        if ( !*(v29 + 25) )
        {
          do
          {
            *&v83[0] = v29;
            if ( sub_1800775B0(v29 + 4, &v75) )
            {
              DWORD2(v83[0]) = 0;
              v29 = v29[2];
            }
            else
            {
              DWORD2(v83[0]) = 1;
              v30 = v29;
              v29 = *v29;
            }
          }
          while ( !*(v29 + 25) );
          v28 = v73;
        }
        if ( !*(v30 + 25) )
        {
          if ( !sub_1800775B0(&v75, v30 + 4) )
            goto LABEL_42;
          v28 = v73;
        }
        if ( v74 == 0x666666666666666LL )
          goto LABEL_128;
        v87[1] = &v73;
        v88 = 0LL;
        v31 = sub_180022FF0(0x28, v25, v27);
        *(v31 + 32) = v75;
        v75 = 0LL;
        *v31 = v28;
        *(v31 + 8) = v28;
        *(v31 + 16) = v28;
        *(v31 + 24) = 0;
        v88 = 0LL;
        sub_180009780(&v73, v83);
LABEL_42:
        sub_180077420(&v75);
        ++v24;
        v23 = v93;
      }
      while ( v24 != v76 );
      v19 = v80;
      v4 = a1;
LABEL_44:
      v22 += 40LL;
    }
    while ( v22 != v19 );
    v19 = *(&pExceptionObject + 1);
    v22 = pExceptionObject;
LABEL_46:
    if ( v22 )
    {
      if ( v22 != v19 )
      {
        v32 = (v22 + 8);
        do
        {
          US_str_UnInitIializeZString(v32 + 1);
          US_str_UnInitIializeZString(v32);
          v32 += 5;
        }
        while ( v32 - 1 != v19 );
        v22 = pExceptionObject;
      }
      v33 = v22;
      if ( (40 * ((v79 - v22) / 40)) >= 0x1000 )
      {
        v22 = *(v22 - 8);
        if ( (v33 - v22 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18000E0A0(v22);
    }
    v34 = v11[2];
    if ( *(v34 + 25) )
    {
      for ( i = v11[1]; !*(i + 25); i = i[1] )
      {
        if ( v11 != i[2] )
          break;
        v11 = i;
      }
      v11 = i;
    }
    else
    {
      v11 = v11[2];
      for ( j = *v34; !*(j + 25); j = *j )
        v11 = j;
    }
    v3 = a2;
  }
  while ( !*(v11 + 25) );
LABEL_62:
  v37 = 0;
  v38 = v84[0];
  v39 = v84[1];
  if ( v84[0] == v84[1] )
    goto LABEL_101;
  v40 = sub_1800230B0(&off_1800E2DF8);
  v41 = sub_1800683B0(&unk_1800F4DB5);
  v42 = v41;
  if ( !*(v41 + 8) && qword_1800F45C0 )
  {
    v43 = (*qword_1800F45C0)(*(v41 + 16), *(v41 + 24), v41 + 8);
    if ( v43 )
    {
      sub_1800064A0(&pExceptionObject, v43, 0LL);
      throw &pExceptionObject;
    }
    if ( !*(v42 + 28) )
    {
      v44 = sub_180026160();
      *v42 = *v44;
      *v44 = v42;
    }
  }
  v37 = (**(v42 + 8))(v38, (v39 - v38) >> 4, v40);
  if ( !v37 )
  {
LABEL_69:
    while ( v38 != v39 )
    {
      if ( !*(v38 + 2) )
      {
        v46 = v3[4];
        v47 = v46[1];
        *&pExceptionObject = v47;
        DWORD2(pExceptionObject) = 0;
        while ( !*(v47 + 25) )
        {
          *&pExceptionObject = v47;
          if ( sub_18007B870(v47 + 4, v38) >= 0 )
          {
            DWORD2(pExceptionObject) = 1;
            v46 = v47;
            v47 = *v47;
          }
          else
          {
            DWORD2(pExceptionObject) = 0;
            v47 = v47[2];
          }
        }
        if ( *(v46 + 25) || sub_18007B870(v38, v46 + 4) < 0 )
        {
          if ( v3[5] == 0x666666666666666LL )
            std::vector<void *>::_Xlen(m);
          v48 = v3[4];
          v76 = v3 + 4;
          v77 = 0LL;
          v49 = sub_180022FF0(0x28, v9, v10);
          v77 = v49;
          CopyUnicodeStr(v49 + 32, v38);
          *v49 = v48;
          *(v49 + 8) = v48;
          *(v49 + 16) = v48;
          *(v49 + 24) = 0;
          v77 = 0LL;
          v83[0] = pExceptionObject;
          sub_180009780(v3 + 4, v83);
        }
        v50 = *v73;
        if ( *v73 != v73 )
        {
          while ( 1 )
          {
            v51 = sub_1800779C0(v50 + 4, &v93, 0LL);
            v52 = sub_18007B870(v51, v38);
            US_str_UnInitIializeZString(&v93);
            m = v50[2];
            v9 = *(m + 25);
            if ( !v52 )
              break;
            if ( v9 )
            {
              for ( k = v50[1]; !*(k + 25); k = *(k + 8) )
              {
                if ( v50 != *(k + 16) )
                  break;
                v50 = k;
              }
              v50 = k;
            }
            else
            {
              v50 = v50[2];
              for ( m = *m; !*(m + 25); m = *m )
                v50 = m;
            }
            if ( v50 == v73 )
            {
              v38 += 16;
              goto LABEL_69;
            }
          }
          v54 = v50;
          if ( v9 )
          {
            for ( n = v50[1]; !*(n + 25); n = *(n + 8) )
            {
              if ( v54 != *(n + 16) )
                break;
              v54 = n;
            }
          }
          else
          {
            for ( ii = *m; !*(ii + 25); ii = *ii )
              ;
          }
          v57 = sub_1800143A0(&v73, v50);
          sub_180077420((v57 + 32));
          sub_18000E0A0(v57);
        }
      }
      v38 += 16;
    }
LABEL_101:
    v76 = 0LL;
    v77 = 0LL;
    v58 = sub_180022FF0(0x28, v9, v10);
    *v58 = v58;
    *(v58 + 8) = v58;
    *(v58 + 16) = v58;
    *(v58 + 24) = 257;
    v76 = v73;
    v73 = v58;
    v59 = v77;
    v77 = v74;
    v74 = v59;
    sub_180068320(v3, &v76);
    v60 = sub_180068280(v3);
    v61 = sub_180064520(&pExceptionObject, a1, v84, v60);
    sub_180067D20(a3, v61);
    v62 = pExceptionObject;
    if ( pExceptionObject )
    {
      if ( (4 * ((v79 - pExceptionObject) >> 2)) >= 0x1000 )
      {
        v62 = *(pExceptionObject - 8);
        if ( (pExceptionObject - v62 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18000E0A0(v62);
    }
    v38 = v84[0];
    v39 = v84[1];
  }
  v63 = *(&v85 + 1);
  if ( *(&v85 + 1) )
  {
    if ( (4 * ((*(&v86 + 1) - *(&v85 + 1)) >> 2)) < 0x1000
      || (v63 = *(*(&v85 + 1) - 8LL), (*(&v85 + 1) - v63 - 8) <= 0x1F) )
    {
      sub_18000E0A0(v63);
      goto LABEL_111;
    }
LABEL_116:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_111:
  if ( v38 )
  {
    for ( jj = v38; jj != v39; jj += 16 )
      US_str_UnInitIializeZString(jj);
    v65 = v38;
    if ( ((v85 - v38) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
    {
      v38 = *(v38 - 1);
      if ( (v65 - v38 - 8) > 0x1F )
        goto LABEL_116;
    }
    sub_18000E0A0(v38);
  }
  v66 = v73;
  v67 = v73[1];
  if ( !*(v67 + 25) )
  {
    do
    {
      sub_180007C00(&v73, &v73, *(v67 + 16));
      v68 = v67;
      v67 = *v67;
      sub_180077420((v68 + 32));
      sub_18000E0A0(v68);
    }
    while ( !*(v67 + 25) );
    v66 = v73;
  }
  sub_18000E0A0(v66);
  sub_180077420(&v81);
  v69 = v82;
  v70 = *(v82 + 8);
  if ( !*(v70 + 25) )
  {
    do
    {
      sub_180027AE0(&v82, &v82, *(v70 + 16));
      v71 = v70;
      v70 = *v70;
      sub_18000E0A0(v71);
    }
    while ( !*(v70 + 25) );
    v69 = v82;
  }
  sub_18000E0A0(v69);
  return v37;
}


// ===== 函数: sub_180009780 (0x180009780) =====
__int64 __fastcall sub_180009780(__int64 **a1, __int64 a2, __int64 a3)
{
  _QWORD *v4; // r11
  _QWORD *v6; // rax
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 *v21; // rcx
  _QWORD *v22; // rcx

  a1[1] = (a1[1] + 1);
  v4 = *a1;
  v6 = *a2;
  *(a3 + 8) = *a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(a3 + 24) = 1;
    return result;
  }
  if ( *(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == *v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == v4[2] )
      v4[2] = a3;
  }
  v8 = a3;
  while ( !*(*(v8 + 8) + 24LL) )
  {
    v9 = *(v8 + 8);
    v10 = *(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(v12 + 24) )
      {
        v13 = *(v9 + 16);
        if ( v8 == v13 )
        {
          v8 = *(v8 + 8);
          *(v9 + 16) = *v13;
          if ( !*(*v13 + 25LL) )
            *(*v13 + 8LL) = v9;
          v13[1] = *(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v13;
          }
          else
          {
            v14 = *(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(v9 + 8) = v13;
        }
        *(*(v8 + 8) + 24LL) = 1;
        *(*(*(v8 + 8) + 8LL) + 24LL) = 0;
        v15 = *(*(v8 + 8) + 8LL);
        v16 = *v15;
        *v15 = *(*v15 + 16LL);
        v17 = v16[2];
        if ( !*(v17 + 25) )
          *(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == (*a1)[1] )
        {
          (*a1)[1] = v16;
          v16[2] = v15;
        }
        else
        {
          v18 = v15[1];
          if ( v15 == v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(v9 + 24) = 1;
      *(v12 + 24) = 1;
      *(*(*(v8 + 8) + 8LL) + 24LL) = 0;
      v8 = *(*(v8 + 8) + 8LL);
    }
    else
    {
      if ( *(v11 + 24) )
      {
        v19 = *v9;
        if ( v8 == *v9 )
        {
          v8 = *(v8 + 8);
          *v9 = *(v19 + 16);
          v20 = *(v19 + 16);
          if ( !*(v20 + 25) )
            *(v20 + 8) = v9;
          *(v19 + 8) = *(v9 + 8);
          if ( v9 == (*a1)[1] )
          {
            (*a1)[1] = v19;
          }
          else
          {
            v21 = *(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          *(v19 + 16) = v9;
          *(v9 + 8) = v19;
        }
        *(*(v8 + 8) + 24LL) = 1;
        *(*(*(v8 + 8) + 8LL) + 24LL) = 0;
        v15 = *(*(v8 + 8) + 8LL);
        v16 = v15[2];
        v15[2] = *v16;
        if ( !*(*v16 + 25LL) )
          *(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == (*a1)[1] )
        {
          (*a1)[1] = v16;
        }
        else
        {
          v22 = v15[1];
          if ( v15 == *v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(v9 + 24) = 1;
      *(v11 + 24) = 1;
      *(*(*(v8 + 8) + 8LL) + 24LL) = 0;
      v8 = *(*(v8 + 8) + 8LL);
    }
  }
  *(v4[1] + 24LL) = 1;
  return a3;
}


// ===== 函数: sub_180068280 (0x180068280) =====
__int64 __fastcall sub_180068280(__int64 a1)
{
  unsigned int v1; // r9d
  __int64 *j; // rcx
  __int64 **v3; // rax
  __int64 *i; // rax
  __int64 *v5; // r8

  v1 = 0;
  j = **(a1 + 48);
  while ( !*(j + 25) )
  {
    v3 = j[2];
    v1 += (j[6] - j[5]) / 40;
    if ( *(v3 + 25) )
    {
      for ( i = j[1]; !*(i + 25); i = i[1] )
      {
        if ( j != i[2] )
          break;
        j = i;
      }
      j = i;
    }
    else
    {
      v5 = *v3;
      for ( j = j[2]; !*(v5 + 25); v5 = *v5 )
        j = v5;
    }
  }
  return v1;
}


// ===== 函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180009A00) =====
void __noreturn std::vector<void *>::_Xlen()
{
  std::_Xlength_error("map/set too long");
}


// ===== 函数: ?_Xlength_error@std@@YAXPEBD@Z (0x180080607) =====
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}


// ===== 函数: ?_Xout_of_range@std@@YAXPEBD@Z (0x18008060D) =====
// attributes: thunk
void __fastcall std::_Xout_of_range(const char *a1)
{
  __imp_?_Xout_of_range@std@@YAXPEBD@Z(a1);
}


// ===== 函数: sub_180067F90 (0x180067F90) =====
void __fastcall sub_180067F90(__int64 a1, _QWORD *a2, int a3)
{
  __int64 v6; // rdx
  _QWORD *v7; // rsi
  unsigned __int64 v8; // rax
  __int64 v9; // r9
  unsigned __int64 i; // r8
  __int64 v11; // rax
  __int64 v12; // rbx
  __int64 v13; // rsi
  __int64 *v14; // rax
  _QWORD *v15; // rdx
  __int64 v16; // rcx
  _DWORD *v17; // rdx
  char v18; // [rsp+30h] [rbp-48h] BYREF
  char v19; // [rsp+31h] [rbp-47h] BYREF
  __int64 v20; // [rsp+38h] [rbp-40h] BYREF
  __int64 v21; // [rsp+40h] [rbp-38h] BYREF
  _QWORD v22[3]; // [rsp+48h] [rbp-30h] BYREF
  int v23; // [rsp+90h] [rbp+18h] BYREF
  char v24; // [rsp+98h] [rbp+20h] BYREF

  v23 = a3;
  v22[1] = -2LL;
  sub_180077AC0(a1, &v20, 0);
  v24 = 0;
  LOBYTE(v6) = 1;
  if ( !sub_1800777E0(a1, v6, 0LL, &v24) || !v24 )
  {
    v7 = gAISmartExportUI_app;
    v8 = USS_UTF_16_str_buffer(&v20, &v21);
    v9 = 0LL;
    for ( i = 0LL; i < v8; ++i )
      v9 = *(v21 + 2 * i) + 33 * v9;
    v11 = v7[97];
    v12 = *(v11 + 16 * (v9 & v7[100]) + 8);
    if ( v12 != v7[95] )
    {
      v13 = *(v11 + 16 * (v9 & v7[100]));
      if ( !sub_18007B870(&v20, v12 + 16) )
        goto LABEL_11;
      while ( v12 != v13 )
      {
        v12 = *(v12 + 8);
        if ( !sub_18007B870(&v20, v12 + 16) )
          goto LABEL_11;
      }
    }
    v12 = 0LL;
LABEL_11:
    if ( !v12 )
      goto LABEL_18;
  }
  v18 = 0;
  v19 = 1;
  v14 = sub_1800779C0(a1, v22, 0LL);
  v15 = a2[1];
  if ( v15 == a2[2] )
  {
    sub_180067660(a2, v15, v14, &v19, &v18);
  }
  else
  {
    v16 = *v14;
    *v14 = 0LL;
    *v15 = v16;
    v21 = 0LL;
    v15[1] = 1LL;
    US_str_UnInitIializeZString(&v21);
    a2[1] += 16LL;
  }
  US_str_UnInitIializeZString(v22);
  v17 = a2[4];
  if ( v17 == a2[5] )
  {
    sub_180067560(a2 + 3, v17, &v23);
  }
  else
  {
    *v17 = a3;
    a2[4] += 4LL;
  }
LABEL_18:
  US_str_UnInitIializeZString(&v20);
}


// ===== 函数: sub_180077AC0 (0x180077AC0) =====
_QWORD *__fastcall sub_180077AC0(__int64 a1, _QWORD *a2, unsigned __int8 a3)
{
  __int128 *AIFilePathSuite; // rax
  __int128 *v7; // rbx
  int v8; // eax
  _QWORD *v9; // rax
  int v10; // eax
  _BYTE pExceptionObject[48]; // [rsp+30h] [rbp-48h] BYREF

  unknown_libname_1(a2);
  AIFilePathSuite = GetAIFilePathSuite();
  v7 = AIFilePathSuite;
  if ( !*(AIFilePathSuite + 1) && qword_1800F45C0 )
  {
    v8 = (*qword_1800F45C0)(*(AIFilePathSuite + 2), *(AIFilePathSuite + 6), AIFilePathSuite + 8);
    if ( v8 )
    {
      sub_1800064A0(pExceptionObject, v8, 0LL);
      throw pExceptionObject;
    }
    if ( !*(v7 + 28) )
    {
      v9 = sub_180026160();
      *v7 = *v9;
      *v9 = v7;
    }
  }
  v10 = (*(*(v7 + 1) + 160LL))(a1, a3, a2);
  if ( v10 )
  {
    sub_1800064A0(pExceptionObject, v10, 0LL);
    throw pExceptionObject;
  }
  return a2;
}


// ===== 函数: sub_1800779C0 (0x1800779C0) =====
_QWORD *__fastcall sub_1800779C0(__int64 a1, _QWORD *a2, unsigned __int8 a3)
{
  __int128 *AIFilePathSuite; // rax
  __int128 *v7; // rbx
  int v8; // eax
  _QWORD *v9; // rax
  int v10; // eax
  _BYTE pExceptionObject[48]; // [rsp+30h] [rbp-48h] BYREF

  unknown_libname_1(a2);
  AIFilePathSuite = GetAIFilePathSuite();
  v7 = AIFilePathSuite;
  if ( !*(AIFilePathSuite + 1) && qword_1800F45C0 )
  {
    v8 = (*qword_1800F45C0)(*(AIFilePathSuite + 2), *(AIFilePathSuite + 6), AIFilePathSuite + 8);
    if ( v8 )
    {
      sub_1800064A0(pExceptionObject, v8, 0LL);
      throw pExceptionObject;
    }
    if ( !*(v7 + 28) )
    {
      v9 = sub_180026160();
      *v7 = *v9;
      *v9 = v7;
    }
  }
  v10 = (*(*(v7 + 1) + 136LL))(a1, a3, a2);
  if ( v10 )
  {
    sub_1800064A0(pExceptionObject, v10, 0LL);
    throw pExceptionObject;
  }
  return a2;
}


// ===== 函数: sub_1800777E0 (0x1800777E0) =====
bool __fastcall sub_1800777E0(__int64 a1, unsigned __int8 a2, __int64 a3, bool *a4)
{
  __int128 *AIFilePathSuite; // rax
  __int128 *v9; // rbx
  int v10; // eax
  _QWORD *v11; // rax
  bool result; // al
  _BYTE v13[8]; // [rsp+20h] [rbp-48h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+28h] [rbp-40h] BYREF

  AIFilePathSuite = GetAIFilePathSuite();
  v9 = AIFilePathSuite;
  if ( !*(AIFilePathSuite + 1) && qword_1800F45C0 )
  {
    v10 = (*qword_1800F45C0)(*(AIFilePathSuite + 2), *(AIFilePathSuite + 6), AIFilePathSuite + 8);
    if ( v10 )
    {
      sub_1800064A0(pExceptionObject, v10, 0LL);
      throw pExceptionObject;
    }
    if ( !*(v9 + 28) )
    {
      v11 = sub_180026160();
      *v9 = *v11;
      *v11 = v9;
    }
  }
  result = (*(*(v9 + 1) + 104LL))(a1, a2, a3, v13) != 0;
  if ( a4 )
    *a4 = v13[0] != 0;
  return result;
}


// ===== 函数: sub_180067660 (0x180067660) =====
char *__fastcall sub_180067660(__int64 *a1, _DWORD *a2, __int64 *a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  unsigned __int8 *v5; // r10
  __int64 *v6; // r9
  _QWORD *v9; // rdx
  __int64 v10; // r8
  __int64 v11; // rax
  unsigned __int64 v12; // r13
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // r15
  unsigned __int64 v16; // r12
  unsigned __int64 v17; // rax
  char *v18; // rdi
  char *v19; // r15
  int v20; // edx
  int v21; // ecx
  __int64 v22; // rax
  __int64 v23; // r8
  __int64 v24; // rax
  _DWORD *v25; // rdx
  _DWORD *v26; // rdx
  _DWORD *v27; // rdx
  _DWORD *v28; // rcx
  __int64 v29; // rsi
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rsi
  _QWORD *v33; // rbx
  _QWORD *i; // rsi
  __int64 v35; // rcx
  unsigned __int64 v37; // [rsp+20h] [rbp-68h]
  char *v38; // [rsp+28h] [rbp-60h]
  void *v39[11]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v41; // [rsp+98h] [rbp+10h]
  __int64 v42; // [rsp+98h] [rbp+10h]

  v39[2] = -2LL;
  v5 = a4;
  v6 = a3;
  v9 = *a1;
  v10 = (a2 - *a1) >> 4;
  v41 = v10;
  v11 = (a1[1] - *a1) >> 4;
  if ( v11 == 0xFFFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen(a1, v9, v10, v6);
  v12 = v11 + 1;
  v13 = (a1[2] - v9) >> 4;
  v14 = v13 >> 1;
  if ( v13 > 0xFFFFFFFFFFFFFFFLL - (v13 >> 1) )
    goto LABEL_35;
  v15 = v11 + 1;
  if ( v14 + v13 >= v12 )
    v15 = v14 + v13;
  if ( v15 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_35;
  v16 = 16 * v15;
  v37 = v15;
  if ( 16 * v15 < 0x1000 )
  {
    if ( v16 )
    {
      v18 = sub_180022FF0((16 * v15), v14, v10);
      v38 = v18;
      v10 = v41;
      v6 = a3;
      v5 = a4;
    }
    else
    {
      v18 = 0LL;
      v38 = 0LL;
    }
    v37 = v15;
    goto LABEL_38;
  }
  if ( v16 + 39 < v16 )
LABEL_35:
    Concurrency::cancel_current_task();
  v17 = sub_180022FF0((v16 + 39), v14, v10);
  if ( !v17 )
    goto LABEL_34;
  v18 = ((v17 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v18 - 1) = v17;
  v38 = v18;
  v10 = v41;
  v6 = a3;
  v5 = a4;
LABEL_38:
  try
  {
    v42 = 16 * v10;
    v19 = &v18[16 * v10];
    v39[1] = v19 + 16;
    v20 = *a5;
    v21 = *v5;
    v22 = *v6;
    *v6 = 0LL;
    *v19 = v22;
    v39[0] = 0LL;
    *(v19 + 2) = v21;
    *(v19 + 3) = v20;
    US_str_UnInitIializeZString(v39);
    v39[0] = v19;
    v23 = a1[1];
    v24 = *a1;
    if ( a2 == v23 )
    {
      if ( v24 != v23 )
      {
        v25 = v18 + 12;
        do
        {
          *(v25 - 3) = *v24;
          *v24 = 0LL;
          *(v25 - 1) = *(v24 + 8);
          *v25 = *(v24 + 12);
          v25 += 4;
          v24 += 16LL;
        }
        while ( v24 != v23 );
      }
    }
    else
    {
      if ( v24 != a2 )
      {
        v26 = v18 + 12;
        do
        {
          *(v26 - 3) = *v24;
          *v24 = 0LL;
          *(v26 - 1) = *(v24 + 8);
          *v26 = *(v24 + 12);
          v26 += 4;
          v24 += 16LL;
        }
        while ( v24 != a2 );
      }
      v39[0] = v18;
      v27 = a1[1];
      if ( a2 != v27 )
      {
        v28 = v19 + 28;
        v29 = &a2[v42 / 0xFFFFFFFFFFFFFFFCuLL] - v18;
        v30 = v29 - 20;
        v31 = v29 - 16;
        v32 = v29 - 28;
        do
        {
          *(v28 - 3) = *(v28 + v32);
          *(v28 + v32) = 0LL;
          *(v28 - 1) = *(v28 + v30);
          *v28 = *(v28 + v31);
          v28 += 4;
        }
        while ( (v28 + v32) != v27 );
      }
    }
  }
  catch ( ... )
  {
    sub_180067520(v39[0]);
    sub_180009A90(a1, v38, v37);
    throw;
  }
  v33 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v33 != i; v33 += 2 )
      US_str_UnInitIializeZString(v33);
    v35 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
      goto LABEL_32;
    if ( (v35 - *(v35 - 8) - 8) <= 0x1F )
    {
      v35 = *(v35 - 8);
LABEL_32:
      sub_18000E0A0(v35);
      goto LABEL_33;
    }
LABEL_34:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_33:
  *a1 = v18;
  a1[1] = &v18[16 * v12];
  a1[2] = &v18[v16];
  return v19;
}


// ===== 函数: ?cancel_current_task@Concurrency@@YAXXZ (0x180006800) =====
void __noreturn Concurrency::cancel_current_task(void)
{
  _BYTE pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  sub_180006650(pExceptionObject);
  throw pExceptionObject;
}


// ===== 函数: sub_180006650 (0x180006650) =====
_QWORD *__fastcall sub_180006650(_QWORD *a1)
{
  a1[2] = 0LL;
  a1[1] = "bad array new length";
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}


// ===== 函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x180009A20) =====
void __noreturn std::vector<void *>::_Xlen()
{
  std::_Xlength_error("vector too long");
}


// ===== 函数: sub_180022FF0 (0x180022FF0) =====
unsigned __int64 __fastcall sub_180022FF0(ai *a1, __int64 a2, void **a3)
{
  unsigned __int64 result; // rax
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 v5; // [rsp+58h] [rbp+10h] BYREF

  v5 = 0LL;
  if ( ai::SPBasicAllocateBlock(a1, &v5, a3) )
  {
    v5 = 0LL;
    goto LABEL_4;
  }
  result = v5;
  if ( !v5 )
  {
LABEL_4:
    sub_180022FC0(pExceptionObject);
    throw pExceptionObject;
  }
  return result;
}


// ===== 函数: sub_180022FC0 (0x180022FC0) =====
_QWORD *__fastcall sub_180022FC0(_QWORD *a1)
{
  a1[2] = 0LL;
  a1[1] = "bad allocation";
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}


// ===== 函数: ?SPBasicAllocateBlock@ai@@YAH_KPEAPEAX@Z (0x18007F9DD) =====
// attributes: thunk
int __fastcall ai::SPBasicAllocateBlock(ai *this, unsigned __int64 a2, void **a3)
{
  return __imp_?SPBasicAllocateBlock@ai@@YAH_KPEAPEAX@Z(this, a2, a3);
}


// ===== 函数: US_str_UnInitIializeZString (0x18007AFF0) =====
void __fastcall US_str_UnInitIializeZString(_QWORD *a1)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int128 *v3; // rbx
  __int64 v4; // rcx
  __int128 **v5; // rax
  __int128 *v6; // rax
  __int64 v7; // rax

  if ( *a1 )
  {
    AIUnicodeStringSuite = GetAIUnicodeStringSuite();
    v3 = AIUnicodeStringSuite;
    if ( !*(AIUnicodeStringSuite + 1) && qword_1800F45C0 )
    {
      if ( (*qword_1800F45C0)(*(AIUnicodeStringSuite + 2), *(AIUnicodeStringSuite + 6), AIUnicodeStringSuite + 8) )
      {
        *(v3 + 1) = 0LL;
      }
      else if ( !*(v3 + 28) )
      {
        v5 = sub_180026160(v4);
        *v3 = *v5;
        *v5 = v3;
      }
    }
    if ( *(v3 + 1) )
    {
      v6 = GetAIUnicodeStringSuite();
      v7 = InitializeZString_fun_p(v6);
      (*(v7 + 24))(a1);
    }
  }
}


// ===== 函数: GetAIUnicodeStringSuite (0x18007B4D0) =====
__int128 *GetAIUnicodeStringSuite()
{
  __int64 v1; // rcx
  _QWORD *v2; // rax

  if ( dword_1800F65B0 <= *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4LL) )
    return &xmmword_1800F6590;
  Init_thread_header(&dword_1800F65B0);
  if ( dword_1800F65B0 != -1 )
    return &xmmword_1800F6590;
  xmmword_1800F6590 = 0LL;
  qword_1800F65A0 = "AI Unicode String Suite";
  dword_1800F65A8 = 9;
  byte_1800F65AC = 1;
  v2 = sub_180026160(v1);
  *&xmmword_1800F6590 = *v2;
  *v2 = &xmmword_1800F6590;
  Init_thread_footer(&dword_1800F65B0);
  return &xmmword_1800F6590;
}


// ===== 函数: InitializeZString_fun_p (0x18001EF40) =====
// ## sub_18007B440 函数分析
// 这个函数的功能是一个包装器（wrapper），它的作用是从一个标准的、以空字符结尾的 C 风格字符串创建一个 AIUnicodeString 对象。让我们来逐步解析它的逻辑：
// 
// _QWORD *__fastcall sub_18007B440(_QWORD *a1, __int64 a2):
// 
// a1: 这是输出参数。它是一个指针，指向即将被初始化的 AIUnicodeString 对象。
// 
// a2: 这是输入参数。它是一个指针，指向一个 C 风格字符串（例如，根据注释，是 "Last Used Artboard Export Settings"）。
// 
// AIUnicodeStringSuite = GetAIUnicodeStringSuite();:
// 
// 这行代码获取了用于所有 AIUnicodeString 操作的主接口（即 "suite"）。你可以把它理解为获取核心的 API 对象。
// 
// vvvv3 = sub_18001EF40(AIUnicodeStringSuite);:
// 
// 这是最关键的一步。它接收主接口对象作为参数，并调用 sub_18001EF40 来从中获取一个特定的函数指针。用面向对象的术语来说，这就像从一个类的虚函数表（vtable）中获取一个成员函数（方法）。我们的目标就是确定 vvvv3 究竟是哪个函数。
// 
// do ++v6; while ( *(a2 + v6) );:
// 
// 这是一个简单的循环，用来计算输入字符串 a2 的长度。它的功能等同于标准库函数 strlen(a2)。
// 
// v7 = (*vvvv3)(a1, a2, v6, 16LL);:
// 
// 这里是实际的函数调用。它通过 vvvv3 指针调用了目标函数，并传递了四个参数：
// 
// a1: 要被初始化的新字符串对象。
// 
// a2: 源 C 风格字符串。
// 
// v6: 源字符串的长度。
// 
// 16LL: 常数 16，很可能代表一种编码格式（例如 UTF-16）。
// 
// ## 结论 🎯
// (*vvvv3)(...) 这个函数调用的目的非常明确：从一个以零结尾的字符串（a2）来初始化一个新的字符串对象（a1）。
// 
// 对照您提供的 AIUnicodeStringSuite 函数列表，能够完美匹配这个功能的函数就是 InitializeZString。
// 
// ZString 中的 "Z" 代表 "Zero-terminated"（以零结尾），这正是标准 C 语言字符串的格式。因此，可以确定 vvvv3 指向的就是 InitializeZString 函数。
__int64 __fastcall sub_18001EF40(__int64 a1)
{
  int v2; // eax
  __int64 v3; // rcx
  _QWORD *v4; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  if ( !*(a1 + 8) && qword_1800F45C0 )
  {
    v2 = (*qword_1800F45C0)(*(a1 + 16), *(a1 + 24), a1 + 8);
    if ( v2 )
    {
      sub_1800064A0(pExceptionObject, v2, 0LL);
      throw pExceptionObject;
    }
    if ( !*(a1 + 28) )
    {
      v4 = sub_180026160(v3);
      *a1 = *v4;
      *v4 = a1;
    }
  }
  return *(a1 + 8);
}


// ===== 函数: sub_180067560 (0x180067560) =====
char *__fastcall sub_180067560(const void **a1, _BYTE *a2, _DWORD *a3, __int64 a4)
{
  _BYTE *v7; // rdx
  __int64 v8; // r14
  __int64 v9; // rax
  __int64 v10; // rbx
  unsigned __int64 v11; // r15
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdx
  char *v14; // rsi
  char *v15; // r14
  _BYTE *v16; // r8
  _BYTE *v17; // rdx
  void *v18; // rcx
  size_t v19; // r8

  v7 = *a1;
  v8 = (a2 - *a1) >> 2;
  v9 = (a1[1] - *a1) >> 2;
  v10 = 0x3FFFFFFFFFFFFFFFLL;
  if ( v9 == 0x3FFFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen(a1, v7, a3, a4);
  v11 = v9 + 1;
  v12 = (a1[2] - v7) >> 2;
  v13 = v12 >> 1;
  if ( v12 <= 0x3FFFFFFFFFFFFFFFLL - (v12 >> 1) )
  {
    v10 = v13 + v12;
    if ( v13 + v12 < v11 )
      v10 = v9 + 1;
  }
  v14 = sub_18004BB30(a1, v10);
  v15 = &v14[4 * v8];
  *v15 = *a3;
  v16 = a1[1];
  v17 = *a1;
  v18 = v14;
  if ( a2 == v16 )
  {
    v19 = v16 - v17;
  }
  else
  {
    memmove(v14, v17, a2 - v17);
    v18 = v15 + 4;
    v19 = a1[1] - a2;
    v17 = a2;
  }
  memmove(v18, v17, v19);
  sub_180068710(a1, v14, v11, v10, -2LL);
  return v15;
}


// ===== 函数: sub_18004BB30 (0x18004BB30) =====
unsigned __int64 __fastcall sub_18004BB30(__int64 a1, unsigned __int64 a2, void **a3)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 result; // rax

  if ( a2 > 0x3FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  v3 = 4 * a2;
  if ( 4 * a2 < 0x1000 )
  {
    if ( v3 )
      return sub_180022FF0(v3, a2, a3);
    else
      return 0LL;
  }
  if ( v3 + 39 < v3 )
LABEL_10:
    Concurrency::cancel_current_task();
  v4 = sub_180022FF0((v3 + 39), a2, a3);
  v5 = v4;
  if ( !v4 )
    invalid_parameter_noinfo_noreturn();
  result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(result - 8) = v5;
  return result;
}


// ===== 函数: sub_180068710 (0x180068710) =====
__int64 __fastcall sub_180068710(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  ai *v6; // rcx
  char *v9; // rdx
  __int64 result; // rax

  v6 = *a1;
  if ( v6 )
  {
    v9 = ((*(a1 + 16) - v6) & 0xFFFFFFFFFFFFFFFCuLL);
    if ( v9 >= 0x1000 )
    {
      v9 += 39;
      if ( v6 - *(v6 - 1) - 8 > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v6 = *(v6 - 1);
    }
    sub_18000E0A0(v6, v9);
  }
  *a1 = a2;
  *(a1 + 8) = a2 + 4 * a3;
  result = a2 + 4 * a4;
  *(a1 + 16) = result;
  return result;
}


// ===== 函数: memmove (0x1800818B4) =====
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}


// ===== 函数: sub_18007B870 (0x18007B870) =====
__int64 __fastcall sub_18007B870(__int64 a1, __int64 a2)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 (__fastcall *v5)(__int64, _QWORD, __int64, __int64, _QWORD, __int64); // rdi
  __int128 *v6; // rax
  __int64 v7; // rax
  __int64 v8; // rbx
  __int128 *v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v5 = *(InitializeZString_fun_p(AIUnicodeStringSuite) + 80);
  v6 = GetAIUnicodeStringSuite();
  v7 = InitializeZString_fun_p(v6);
  v8 = (*(v7 + 128))(a2);
  v9 = GetAIUnicodeStringSuite();
  v10 = InitializeZString_fun_p(v9);
  v11 = (*(v10 + 128))(a1);
  return v5(a1, 0LL, v11, a2, 0LL, v8);
}


// ===== 函数: USS_UTF_16_str_buffer (0x18007BDD0) =====
// ai::UnicodeString::size_type(*  UTF_16 )(const ai::UnicodeString &str, const ai::UnicodeString::UTF16Char *&buffer) 
//   Retrieves a read-only pointer to a buffer that contains UTF-16 encoded characters in platform byte order, for a given Unicode string.  
__int64 __fastcall USS_UTF_16_str_buffer(__int64 a1, __int64 a2)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v5; // rax

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v5 = InitializeZString_fun_p(AIUnicodeStringSuite);
  return (*(v5 + 288))(a1, a2);
}


// ===== 函数: sub_1800143A0 (0x1800143A0) =====
__int64 *__fastcall sub_1800143A0(_QWORD *a1, __int64 *a2)
{
  __int64 *v2; // rax
  __int64 *v3; // r9
  __int64 *v5; // r14
  __int64 ***i; // r8
  __int64 *v7; // rdx
  __int64 *v8; // rdi
  __int64 **v9; // rbx
  __int64 **v10; // rdx
  __int64 *v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 *j; // rcx
  __int64 **v15; // rcx
  char v16; // dl
  __int64 **v17; // r10
  __int64 *v18; // rcx
  __int64 ***v19; // rcx
  __int64 ***v20; // rdx
  __int64 ***v21; // rax
  __int64 *v22; // rcx
  __int64 v23; // rax
  __int64 **v24; // rax
  __int64 v25; // r8
  __int64 v26; // rcx
  __int64 *result; // rax

  v2 = a2[2];
  v3 = a2 + 2;
  v5 = a2;
  if ( *(v2 + 25) )
  {
    v2 = a2[1];
    for ( i = (a2 + 1); !*(v2 + 25); v2 = v2[1] )
    {
      if ( a2 != v2[2] )
        break;
      a2 = v2;
    }
  }
  else
  {
    v7 = *v2;
    if ( !*(*v2 + 25) )
    {
      do
      {
        v2 = v7;
        v7 = *v7;
      }
      while ( !*(v7 + 25) );
    }
    i = (v5 + 1);
  }
  v8 = *v3;
  if ( *(*v5 + 25) )
    goto LABEL_13;
  if ( *(v8 + 25) )
  {
    v8 = *v5;
LABEL_13:
    v9 = *i;
    if ( !*(v8 + 25) )
      v8[1] = v9;
    if ( *(*a1 + 8LL) == v5 )
    {
      *(*a1 + 8LL) = v8;
    }
    else if ( *v9 == v5 )
    {
      *v9 = v8;
    }
    else
    {
      v9[2] = v8;
    }
    if ( **a1 == v5 )
    {
      if ( *(v8 + 25) )
      {
        v10 = v9;
      }
      else
      {
        v11 = *v8;
        v10 = v8;
        if ( !*(*v8 + 25) )
        {
          do
          {
            v10 = v11;
            v11 = *v11;
          }
          while ( !*(v11 + 25) );
        }
      }
      **a1 = v10;
    }
    v12 = *a1;
    if ( *(*a1 + 16LL) == v5 )
    {
      if ( *(v8 + 25) )
      {
        *(v12 + 16) = v9;
      }
      else
      {
        v13 = v8[2];
        for ( j = v8; !*(v13 + 25); v13 = *(v13 + 16) )
          j = v13;
        *(v12 + 16) = j;
      }
    }
    goto LABEL_43;
  }
  v8 = v2[2];
  if ( v2 == v5 )
    goto LABEL_13;
  *(*v5 + 8) = v2;
  *v2 = *v5;
  if ( v2 == *v3 )
  {
    v9 = v2;
  }
  else
  {
    v9 = v2[1];
    if ( !*(v8 + 25) )
      v8[1] = v9;
    *v9 = v8;
    v2[2] = *v3;
    *(*v3 + 8) = v2;
  }
  if ( *(*a1 + 8LL) == v5 )
  {
    *(*a1 + 8LL) = v2;
  }
  else
  {
    v15 = *i;
    if ( **i == v5 )
      *v15 = v2;
    else
      v15[2] = v2;
  }
  v16 = *(v2 + 24);
  v2[1] = *i;
  *(v2 + 24) = *(v5 + 24);
  *(v5 + 24) = v16;
LABEL_43:
  if ( *(v5 + 24) == 1 )
  {
    if ( v8 != *(*a1 + 8LL) )
    {
      do
      {
        v17 = v9;
        if ( *(v8 + 24) != 1 )
          break;
        v18 = *v9;
        if ( v8 == *v9 )
        {
          v18 = v9[2];
          if ( *(v18 + 24) )
          {
            v20 = (v9 + 1);
          }
          else
          {
            *(v18 + 24) = 1;
            v19 = v9[2];
            *(v9 + 24) = 0;
            v9[2] = *v19;
            if ( !*(*v19 + 25) )
              (*v19)[1] = v9;
            v20 = (v9 + 1);
            v19[1] = v9[1];
            if ( v9 == *(*a1 + 8LL) )
            {
              *(*a1 + 8LL) = v19;
              *v19 = v9;
              *v20 = v19;
              v18 = v9[2];
            }
            else
            {
              v21 = *v20;
              if ( v9 == **v20 )
                *v21 = v19;
              else
                v21[2] = v19;
              *v19 = v9;
              *v20 = v19;
              v18 = v9[2];
            }
          }
          if ( *(v18 + 25) )
            goto LABEL_77;
          if ( *(*v18 + 24) != 1 || *(v18[2] + 24) != 1 )
          {
            if ( *(v18[2] + 24) == 1 )
            {
              *(*v18 + 24) = 1;
              *(v18 + 24) = 0;
              sub_1800147E0(a1, v18);
              v18 = v9[2];
            }
            *(v18 + 24) = *(v9 + 24);
            *(v9 + 24) = 1;
            *(v18[2] + 24) = 1;
            sub_180014780(a1, v9);
            break;
          }
        }
        else
        {
          if ( *(v18 + 24) )
          {
            v20 = (v9 + 1);
          }
          else
          {
            *(v18 + 24) = 1;
            v22 = *v9;
            *(v9 + 24) = 0;
            *v9 = v22[2];
            v23 = v22[2];
            if ( !*(v23 + 25) )
              *(v23 + 8) = v9;
            v20 = (v9 + 1);
            v22[1] = v9[1];
            if ( v9 == *(*a1 + 8LL) )
            {
              *(*a1 + 8LL) = v22;
              v22[2] = v9;
              *v20 = v22;
              v18 = *v9;
            }
            else
            {
              v24 = *v20;
              if ( v9 == (*v20)[2] )
                v24[2] = v22;
              else
                *v24 = v22;
              v22[2] = v9;
              *v20 = v22;
              v18 = *v9;
            }
          }
          if ( *(v18 + 25) )
            goto LABEL_77;
          v25 = v18[2];
          if ( *(v25 + 24) != 1 || *(*v18 + 24) != 1 )
          {
            if ( *(*v18 + 24) == 1 )
            {
              *(v25 + 24) = 1;
              *(v18 + 24) = 0;
              sub_180014780(a1, v18);
              v18 = *v9;
            }
            *(v18 + 24) = *(v9 + 24);
            *(v9 + 24) = 1;
            *(*v18 + 24) = 1;
            sub_1800147E0(a1, v9);
            break;
          }
        }
        *(v18 + 24) = 0;
LABEL_77:
        v8 = v9;
        v9 = *v20;
      }
      while ( v17 != *(*a1 + 8LL) );
    }
    *(v8 + 24) = 1;
  }
  v26 = a1[1];
  result = v5;
  if ( v26 )
    a1[1] = v26 - 1;
  return result;
}


// ===== 函数: sub_1800147E0 (0x1800147E0) =====
_QWORD *__fastcall sub_1800147E0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax
  _QWORD *result; // rax

  v2 = *a2;
  *a2 = *(*a2 + 16LL);
  v3 = *(v2 + 16);
  if ( !*(v3 + 25) )
    *(v3 + 8) = a2;
  *(v2 + 8) = a2[1];
  result = *a1;
  if ( a2 == *(*a1 + 8LL) )
  {
    result[1] = v2;
    *(v2 + 16) = a2;
    a2[1] = v2;
  }
  else
  {
    result = a2[1];
    if ( a2 == result[2] )
      result[2] = v2;
    else
      *result = v2;
    *(v2 + 16) = a2;
    a2[1] = v2;
  }
  return result;
}


// ===== 函数: sub_180014780 (0x180014780) =====
_QWORD *__fastcall sub_180014780(__int64 a1, __int64 a2)
{
  _QWORD *v2; // r8
  _QWORD *result; // rax

  v2 = *(a2 + 16);
  *(a2 + 16) = *v2;
  if ( !*(*v2 + 25LL) )
    *(*v2 + 8LL) = a2;
  v2[1] = *(a2 + 8);
  result = *a1;
  if ( a2 == *(*a1 + 8LL) )
  {
    result[1] = v2;
    *v2 = a2;
    *(a2 + 8) = v2;
  }
  else
  {
    result = *(a2 + 8);
    if ( a2 == *result )
      *result = v2;
    else
      result[2] = v2;
    *v2 = a2;
    *(a2 + 8) = v2;
  }
  return result;
}


// ===== 函数: sub_180068320 (0x180068320) =====
__int64 __fastcall sub_180068320(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx

  v2 = (a1 + 16);
  if ( (a1 + 16) != a2 )
  {
    v4 = *v2;
    sub_180007C00(a1 + 16, a1 + 16, *(*v2 + 8));
    v4[1] = v4;
    *v4 = v4;
    v4[2] = v4;
    v2[1] = 0LL;
    v5 = *v2;
    *v2 = *a2;
    v6 = a2[1];
    *a2 = v5;
    v7 = v2[1];
    v2[1] = v6;
    a2[1] = v7;
  }
  sub_180007C00(a2, a2, *(*a2 + 8));
  return sub_18000E0A0(*a2);
}


// ===== 函数: sub_180064520 (0x180064520) =====
__int64 __fastcall sub_180064520(__int64 a1, _QWORD *a2, __int64 *a3, __int64 a4)
{
  int v4; // r13d
  int v7; // ebx
  __int64 v8; // rax
  __int64 v9; // rdi
  char *v10; // r14
  char *v11; // rbp
  char *v12; // r15
  __int64 v13; // rcx
  __int64 v14; // r9
  __int64 v15; // rdx
  unsigned __int64 v16; // r8
  char *i; // rdi
  _BYTE *v18; // rdx
  char *v19; // rax
  __int128 v21; // [rsp+30h] [rbp-58h] BYREF
  char *v22; // [rsp+40h] [rbp-48h]
  int v23; // [rsp+98h] [rbp+10h] BYREF

  v4 = a4;
  v7 = 0;
  *a1 = 0LL;
  *(a1 + 8) = 0LL;
  *(a1 + 16) = 0LL;
  v8 = (a2[1] - *a2) >> 3;
  v9 = v8;
  v21 = 0LL;
  v10 = 0LL;
  v22 = 0LL;
  if ( v8 )
  {
    if ( v8 > 0x3FFFFFFFFFFFFFFFLL )
      std::vector<void *>::_Xlen(a1, a2, a3, a4);
    v11 = sub_18004BB30(&v21, v8);
    *&v21 = v11;
    v10 = &v11[4 * v9];
    v22 = v10;
    memset(v11, 0, 4 * v9);
    v12 = v10;
    *(&v21 + 1) = v10;
  }
  else
  {
    v12 = *(&v21 + 1);
    v11 = v21;
  }
  v13 = *a3;
  v14 = a3[1];
  if ( *a3 != v14 )
  {
    v15 = 0LL;
    do
    {
      if ( !*(v13 + 8) )
      {
        v16 = *(v15 + a3[3]);
        if ( (v12 - v11) >> 2 <= v16 )
          std::vector<void *>::_Xlen(v13, v15);
        ++*&v11[4 * v16];
      }
      v15 += 4LL;
      v13 += 16LL;
    }
    while ( v13 != v14 );
  }
  v23 = 0;
  for ( i = v11; i != v12; i += 4 )
  {
    if ( *i == v4 )
    {
      v18 = *(a1 + 8);
      if ( v18 == *(a1 + 16) )
      {
        sub_180067560(a1, v18, &v23, v14);
        v7 = v23;
      }
      else
      {
        *v18 = v7;
        *(a1 + 8) += 4LL;
      }
    }
    v23 = ++v7;
  }
  if ( v11 )
  {
    v19 = v11;
    if ( ((v10 - v11) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
    {
      v11 = *(v11 - 1);
      if ( (v19 - v11 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18000E0A0(v11);
  }
  return a1;
}


// ===== 函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x1800687A0) =====
void __noreturn std::vector<void *>::_Xlen()
{
  std::_Xout_of_range("invalid vector subscript");
  JUMPOUT(0x1800687B0LL);
}


// ===== 函数: memset (0x180081896) =====
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}


// ===== 函数: sub_180067D20 (0x180067D20) =====
__int64 *__fastcall sub_180067D20(__int64 *a1, __int64 *a2)
{
  __int64 v4; // rcx

  if ( a1 != a2 )
  {
    v4 = *a1;
    if ( v4 )
    {
      if ( ((a1[2] - v4) & 0xFFFFFFFFFFFFFFFCuLL) >= 0x1000 )
      {
        if ( (v4 - *(v4 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v4 = *(v4 - 8);
      }
      sub_18000E0A0(v4);
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }
    *a1 = *a2;
    a1[1] = a2[1];
    a1[2] = a2[2];
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
  }
  return a1;
}


// ===== 函数: sub_1800671B0 (0x1800671B0) =====
__int64 __fastcall sub_1800671B0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rdx
  __int64 v9; // rbx
  unsigned __int64 v10; // rcx
  __int64 i; // rbp
  __int64 v12; // r8
  __int64 v13; // rax
  __int64 result; // rax
  unsigned __int64 v15; // rdx
  __int64 v16; // rbx
  _QWORD *v17; // rbp
  _QWORD *v18; // rdi
  _QWORD *v19; // rbx

  v3 = *a1;
  v7 = (a3 - a2) / 40;
  v8 = (a1[2] - *a1) / 40;
  if ( v7 <= v8 )
  {
    v15 = (a1[1] - v3) / 40;
    if ( v7 <= v15 )
    {
      v17 = (v3 + 40 * v7);
      result = sub_1800674A0(a2, a3, v3);
      v18 = a1[1];
      if ( v17 != v18 )
      {
        v19 = v17 + 1;
        do
        {
          US_str_UnInitIializeZString(v19 + 1);
          US_str_UnInitIializeZString(v19);
          v19 += 5;
          result = (v19 - 1);
        }
        while ( v19 - 1 != v18 );
      }
      a1[1] = v17;
    }
    else
    {
      v16 = a2 + 40 * v15;
      sub_1800674A0(a2, v16, v3);
      result = sub_1800679C0(v16, a3, a1[1], a1);
      a1[1] = result;
    }
  }
  else
  {
    v9 = 0x666666666666666LL;
    if ( v7 > 0x666666666666666LL )
      std::vector<void *>::_Xlen();
    v10 = v8 >> 1;
    if ( v8 <= 0x666666666666666LL - (v8 >> 1) )
    {
      v9 = v10 + v8;
      if ( v10 + v8 < v7 )
        v9 = v7;
    }
    if ( v3 )
    {
      for ( i = a1[1]; v3 != i; v3 += 40LL )
      {
        US_str_UnInitIializeZString((v3 + 16));
        US_str_UnInitIializeZString((v3 + 8));
      }
      v12 = *a1;
      if ( (40 * ((a1[2] - *a1) / 40)) >= 0x1000 )
      {
        if ( (v12 - *(v12 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v12 = *(v12 - 8);
      }
      sub_18000E0A0(v12);
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }
    v13 = sub_18002F320(a1, v9);
    *a1 = v13;
    a1[1] = v13;
    a1[2] = v13 + 40 * v9;
    result = sub_1800679C0(a2, a3, v13, a1);
    a1[1] = result;
  }
  return result;
}


// ===== 函数: sub_18002F320 (0x18002F320) =====
unsigned __int64 __fastcall sub_18002F320(__int64 a1, unsigned __int64 a2, void **a3)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 result; // rax

  if ( a2 > 0x666666666666666LL )
    goto LABEL_10;
  v3 = 40 * a2;
  if ( 40 * a2 < 0x1000 )
  {
    if ( v3 )
      return sub_180022FF0(v3, a2, a3);
    else
      return 0LL;
  }
  if ( v3 + 39 < v3 )
LABEL_10:
    Concurrency::cancel_current_task();
  v4 = sub_180022FF0((v3 + 39), a2, a3);
  v5 = v4;
  if ( !v4 )
    invalid_parameter_noinfo_noreturn();
  result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(result - 8) = v5;
  return result;
}


// ===== 函数: sub_1800674A0 (0x1800674A0) =====
__int64 __fastcall sub_1800674A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rdi
  int v6; // eax

  if ( a1 != a2 )
  {
    v5 = a1 + 16;
    do
    {
      *a3 = *(v5 - 16);
      sub_18007B0A0(a3 + 8, v5 - 8);
      sub_18007B0A0(a3 + 16, v5);
      *(a3 + 24) = *(v5 + 8);
      *(a3 + 28) = *(v5 + 12);
      *(a3 + 32) = *(v5 + 16);
      v6 = *(v5 + 20);
      v5 += 40LL;
      *(a3 + 36) = v6;
      a3 += 40LL;
    }
    while ( v5 - 16 != a2 );
  }
  return a3;
}


// ===== 函数: sub_18007B0A0 (0x18007B0A0) =====
__int64 __fastcall sub_18007B0A0(__int64 a1, __int64 a2)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v5; // rax
  int v6; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v5 = InitializeZString_fun_p(AIUnicodeStringSuite);
  v6 = (*(v5 + 48))(a1, a2);
  if ( v6 )
  {
    sub_1800064A0(pExceptionObject, v6, 0LL);
    throw pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_1800679C0 (0x1800679C0) =====
__int64 __fastcall sub_1800679C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rdi

  if ( a1 != a2 )
  {
    v5 = a1 + 16;
    do
    {
      *a3 = *(v5 - 16);
      CopyUnicodeStr(a3 + 8, v5 - 8);
      CopyUnicodeStr(a3 + 16, v5);
      *(a3 + 24) = *(v5 + 8);
      *(a3 + 28) = *(v5 + 12);
      *(a3 + 32) = *(v5 + 16);
      *(a3 + 36) = *(v5 + 20);
      a3 += 40LL;
      v5 += 40LL;
    }
    while ( v5 - 16 != a2 );
  }
  return a3;
}


// ===== 函数: CopyUnicodeStr (0x18007A9F0) =====
_QWORD *__fastcall sub_18007A9F0(_QWORD *a1, __int64 a2)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v5; // rax
  int v6; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v5 = InitializeZString_fun_p(AIUnicodeStringSuite);
  v6 = (*(v5 + 56))(a1, a2);
  if ( v6 )
  {
    sub_1800064A0(pExceptionObject, v6, 0LL);
    throw pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_1800775B0 (0x1800775B0) =====
bool __fastcall sub_1800775B0(__int64 a1, __int64 a2)
{
  __int128 *AIFilePathSuite; // rax
  __int128 *v5; // rbx
  int v6; // eax
  _QWORD *v7; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  AIFilePathSuite = GetAIFilePathSuite();
  v5 = AIFilePathSuite;
  if ( !*(AIFilePathSuite + 1) && qword_1800F45C0 )
  {
    v6 = (*qword_1800F45C0)(*(AIFilePathSuite + 2), *(AIFilePathSuite + 6), AIFilePathSuite + 8);
    if ( v6 )
    {
      sub_1800064A0(pExceptionObject, v6, 0LL);
      throw pExceptionObject;
    }
    if ( !*(v5 + 28) )
    {
      v7 = sub_180026160();
      *v5 = *v7;
      *v7 = v5;
    }
  }
  return (*(*(v5 + 1) + 48LL))(a1, a2) != 0;
}


// ===== 函数: sub_1800230B0 (0x1800230B0) =====
__int64 __fastcall sub_1800230B0(__int64 *a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  __int64 v4; // rbx
  int v5; // eax
  _QWORD *v6; // rax
  __int64 (__fastcall *v7)(_QWORD *, __int64 *); // rbx
  _QWORD *v8; // rax
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // rbx
  int v12; // eax
  _QWORD *v13; // rax
  __int64 (__fastcall *v14)(__int64, __int64 *); // rbx
  __int64 v15; // rax
  int v16; // eax
  _BYTE pExceptionObject[48]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v18; // [rsp+78h] [rbp+10h] BYREF

  result = a1[3];
  if ( !result )
  {
    if ( *(a1 + 16) )
    {
      v3 = sub_180023290(&unk_1800F448B);
      v4 = v3;
      if ( !*(v3 + 8) && qword_1800F45C0 )
      {
        v5 = (*qword_1800F45C0)(*(v3 + 16), *(v3 + 24), v3 + 8);
        if ( v5 )
        {
          sub_1800064A0(pExceptionObject, v5, 0LL);
          throw pExceptionObject;
        }
        if ( !*(v4 + 28) )
        {
          v6 = sub_180026160();
          *v4 = *v6;
          *v6 = v4;
        }
      }
      v7 = **(v4 + 8);
      v8 = US_str_InitializeZString(&v18, *a1);
      v9 = v7(v8, a1 + 3);
      if ( v9 )
      {
        sub_1800064A0(
          pExceptionObject,
          v9,
          "AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\public\\"
          "api\\IAIGlobalUnicodeString.cpp line: 36 ");
        throw pExceptionObject;
      }
    }
    else
    {
      v10 = sub_180023290(&unk_1800F448B);
      v11 = v10;
      if ( !*(v10 + 8) && qword_1800F45C0 )
      {
        v12 = (*qword_1800F45C0)(*(v10 + 16), *(v10 + 24), v10 + 8);
        if ( v12 )
        {
          sub_1800064A0(pExceptionObject, v12, 0LL);
          throw pExceptionObject;
        }
        if ( !*(v11 + 28) )
        {
          v13 = sub_180026160();
          *v11 = *v13;
          *v13 = v11;
        }
      }
      v14 = **(v11 + 8);
      v15 = sub_18007ACC0(&v18, *a1, a1[1], *(a1 + 8));
      v16 = v14(v15, a1 + 3);
      if ( v16 )
      {
        sub_1800064A0(
          pExceptionObject,
          v16,
          "AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\public\\"
          "api\\IAIGlobalUnicodeString.cpp line: 36 ");
        throw pExceptionObject;
      }
    }
    result = a1[3];
    if ( !result )
    {
      sub_1800065A0(pExceptionObject, "Failed Postcondition");
      throw pExceptionObject;
    }
  }
  return result;
}


// ===== 函数: sub_18007ACC0 (0x18007ACC0) =====
_QWORD *__fastcall sub_18007ACC0(_QWORD *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 (__fastcall **v9)(_QWORD *, __int64, __int64, _QWORD); // rax
  int v10; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  if ( a2 )
  {
    AIUnicodeStringSuite = GetAIUnicodeStringSuite();
    v9 = InitializeZString_fun_p(AIUnicodeStringSuite);
    v10 = (*v9)(a1, a2, a3, a4);
    if ( v10 )
    {
      sub_1800064A0(pExceptionObject, v10, 0LL);
      throw pExceptionObject;
    }
  }
  return a1;
}


// ===== 函数: sub_1800065A0 (0x1800065A0) =====
__int64 __fastcall sub_1800065A0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(a1 + 8) = 0LL;
  *a1 = &ai::Contract::Violation::`vftable';
  result = a1;
  *(a1 + 24) = 1346458189;
  *(a1 + 32) = 0LL;
  *(a1 + 40) = a2;
  return result;
}


// ===== 函数: sub_180023290 (0x180023290) =====
_OWORD *sub_180023290()
{
  _QWORD *v1; // rax

  if ( dword_1800F44B0 <= *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4LL) )
    return &xmmword_1800F4490;
  Init_thread_header(&dword_1800F44B0);
  if ( dword_1800F44B0 != -1 )
    return &xmmword_1800F4490;
  xmmword_1800F4490 = 0LL;
  unk_1800F44A0 = "AI Global UnicodeString Suite";
  unk_1800F44A8 = 1;
  unk_1800F44AC = 1;
  v1 = sub_180026160();
  *&xmmword_1800F4490 = *v1;
  *v1 = &xmmword_1800F4490;
  Init_thread_footer(&dword_1800F44B0);
  return &xmmword_1800F4490;
}


// ===== 函数: US_str_InitializeZString (0x18007ADD0) =====
_QWORD *__fastcall US_str_InitializeZString(_QWORD *a1, __int64 a2)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v5; // rax
  unsigned int v6; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v5 = InitializeZString_fun_p(AIUnicodeStringSuite);
  v6 = (*(v5 + 304))(a1, a2);
  if ( v6 )
  {
    sub_1800064A0(pExceptionObject, v6, 0LL);
    throw pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_1800683B0 (0x1800683B0) =====
__int128 *sub_1800683B0()
{
  _QWORD *v1; // rax

  if ( dword_1800F4DD8[0] <= *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4LL) )
    return &xmmword_1800F4DB8;
  Init_thread_header(dword_1800F4DD8);
  if ( dword_1800F4DD8[0] != -1 )
    return &xmmword_1800F4DB8;
  xmmword_1800F4DB8 = 0LL;
  qword_1800F4DC8 = "AI ReplaceLinkWarningUI Suite";
  dword_1800F4DD0 = 1;
  byte_1800F4DD4 = 1;
  v1 = sub_180026160();
  *&xmmword_1800F4DB8 = *v1;
  *v1 = &xmmword_1800F4DB8;
  Init_thread_footer(dword_1800F4DD8);
  return &xmmword_1800F4DB8;
}


// ===== 函数: sub_1800774D0 (0x1800774D0) =====
_QWORD *__fastcall sub_1800774D0(_QWORD *a1, _QWORD *a2)
{
  __int128 *AIFilePathSuite; // rax
  __int128 *v5; // rbx
  int v6; // eax
  _QWORD *v7; // rax
  int v8; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  if ( *a2 || *a1 )
  {
    AIFilePathSuite = GetAIFilePathSuite();
    v5 = AIFilePathSuite;
    if ( !*(AIFilePathSuite + 1) && qword_1800F45C0 )
    {
      v6 = (*qword_1800F45C0)(*(AIFilePathSuite + 2), *(AIFilePathSuite + 6), AIFilePathSuite + 8);
      if ( v6 )
      {
        sub_1800064A0(pExceptionObject, v6, 0LL);
        throw pExceptionObject;
      }
      if ( !*(v5 + 28) )
      {
        v7 = sub_180026160();
        *v5 = *v7;
        *v7 = v5;
      }
    }
    v8 = (*(*(v5 + 1) + 16LL))(a2, a1);
    if ( v8 )
    {
      sub_1800064A0(pExceptionObject, v8, 0LL);
      throw pExceptionObject;
    }
  }
  return a1;
}


// ===== 函数: sub_180067950 (0x180067950) =====
__int64 __fastcall sub_180067950(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( a1 != a2 )
  {
    v3 = a1 + 16;
    do
    {
      v4 = *(v3 - 16);
      v3 += 40LL;
      v5 = *(a3 + 8);
      *a3 = v4;
      *(a3 + 8) = *(v3 - 48);
      v6 = *(v3 - 40);
      *(v3 - 48) = v5;
      v7 = *(a3 + 16);
      *(a3 + 16) = v6;
      *(v3 - 40) = v7;
      *(a3 + 24) = *(v3 - 32);
      *(a3 + 28) = *(v3 - 28);
      *(a3 + 32) = *(v3 - 24);
      *(a3 + 36) = *(v3 - 20);
      a3 += 40LL;
    }
    while ( v3 - 16 != a2 );
  }
  return a3;
}


// ===== 函数: sub_180068160 (0x180068160) =====
void __fastcall sub_180068160(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // r14
  _QWORD *v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // r8
  _QWORD *v8; // r8
  __int64 **v9; // rdx
  __int64 *i; // rcx
  __int64 v11; // rcx
  __int64 j; // rax
  unsigned __int8 v13; // [rsp+30h] [rbp+8h]

  v2 = (a1 + 64);
  if ( a2 != (a1 + 64) )
  {
    v4 = *a2;
    v5 = *(*a2 + 8LL);
    while ( !*(v5 + 25) )
    {
      sub_180027AE0(a2, a2, *(v5 + 16));
      v6 = v5;
      v5 = *v5;
      sub_18000E0A0(v6);
    }
    v4[1] = v4;
    *v4 = v4;
    v4[2] = v4;
    v7 = *a2;
    a2[1] = 0LL;
    *(*a2 + 8LL) = sub_1800673D0(a2, *(*v2 + 8LL), v7, v13);
    v8 = *a2;
    a2[1] = v2[1];
    v9 = v8[1];
    if ( *(v9 + 25) )
    {
      *v8 = v8;
      *(*a2 + 16LL) = *a2;
    }
    else
    {
      for ( i = *v9; !*(i + 25); i = *i )
        v9 = i;
      *v8 = v9;
      v11 = *(*a2 + 8LL);
      for ( j = *(v11 + 16); !*(j + 25); j = *(j + 16) )
        v11 = j;
      *(*a2 + 16LL) = v11;
    }
  }
}


// ===== 函数: sub_180027AE0 (0x180027AE0) =====
__int64 __fastcall sub_180027AE0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rcx
  __int64 result; // rax

  for ( i = a3; !*(i + 25); result = sub_18000E0A0(v6) )
  {
    sub_180027AE0(a1, a2, *(i + 16));
    v6 = i;
    i = *i;
  }
  return result;
}


// ===== 函数: sub_1800673D0 (0x1800673D0) =====
__int64 __fastcall sub_1800673D0(__int64 *a1, __int64 a2, void **a3, unsigned __int8 a4)
{
  __int64 v8; // r14
  unsigned __int64 v9; // rdi
  __int64 v11; // rax

  v8 = *a1;
  if ( !*(a2 + 25) )
  {
    v9 = sub_180022FF0(0x20, a2, a3);
    *(v9 + 26) = *(a2 + 26);
    *v9 = v8;
    *(v9 + 16) = v8;
    *(v9 + 24) = 0;
    *(v9 + 8) = a3;
    *(v9 + 24) = *(a2 + 24);
    if ( *(v8 + 25) )
      v8 = v9;
    try
    {
      *v9 = sub_1800673D0(a1, *a2, v9, a4);
      *(v9 + 16) = sub_1800673D0(a1, *(a2 + 16), v9, a4);
    }
    catch ( ... )
    {
      v11 = sub_180008F70(a1);
      sub_180027AE0(a1, v11, v8);
      throw;
    }
  }
  return v8;
}


// ===== 函数: sub_180067A70 (0x180067A70) =====
_QWORD *__fastcall sub_180067A70(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdi
  __int64 v6; // rsi
  char v7; // al
  __int64 i; // rsi
  char v10; // al
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx

  v4 = a2;
  if ( a2 == a3 || (v6 = a2 + 40, a2 + 40 == a3) )
  {
LABEL_10:
    *a1 = a3;
  }
  else
  {
    while ( 1 )
    {
      v7 = *(v4 + 24);
      if ( v7 == *(v6 + 24)
        && ((v7 - 6) <= 1u || *v4 == *v6)
        && *(v4 + 28) == *(v6 + 28)
        && !sub_18007B870(v4 + 8, v6 + 8)
        && !sub_18007B870(v4 + 16, v6 + 16) )
      {
        break;
      }
      v4 = v6;
      v6 += 40LL;
      if ( v6 == a3 )
        goto LABEL_10;
    }
    for ( i = v6 + 40; i != a3; i += 40LL )
    {
      v10 = *(v4 + 24);
      if ( v10 != *(i + 24)
        || (v10 - 6) > 1u && *v4 != *i
        || *(v4 + 28) != *(i + 28)
        || sub_18007B870(v4 + 8, i + 8)
        || sub_18007B870(v4 + 16, i + 16) )
      {
        v4 += 40LL;
        v11 = *(v4 + 8);
        *v4 = *i;
        *(v4 + 8) = *(i + 8);
        v12 = *(i + 16);
        *(i + 8) = v11;
        v13 = *(v4 + 16);
        *(v4 + 16) = v12;
        *(i + 16) = v13;
        *(v4 + 24) = *(i + 24);
        *(v4 + 28) = *(i + 28);
        *(v4 + 32) = *(i + 32);
        *(v4 + 36) = *(i + 36);
      }
    }
    *a1 = v4 + 40;
  }
  return a1;
}


// ===== 函数: sub_18004F220 (0x18004F220) =====
__int64 __fastcall sub_18004F220(__int64 a1, __int64 *a2)
{
  int v3; // eax
  __int64 v4; // rbx
  __int64 result; // rax
  _BYTE v6[16]; // [rsp+20h] [rbp-48h] BYREF
  _BYTE pExceptionObject[56]; // [rsp+30h] [rbp-38h] BYREF
  __int64 v8; // [rsp+80h] [rbp+18h] BYREF

  v8 = 0LL;
  v3 = (*(gAIDocumentSuite + 160))(&v8);
  if ( v3 )
  {
    sub_1800064A0(
      pExceptionObject,
      v3,
      "AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\PlugInDev\\SmartExportUI\\Source\\"
      "SmartExportUI.cpp line: 852 ");
    throw pExceptionObject;
  }
  if ( !v8 )
  {
    sub_1800065A0(pExceptionObject, "No document");
    throw pExceptionObject;
  }
  v4 = *a2;
  result = sub_18004CEF0(gAISmartExportUI_app + 432, v6, &v8);
  *(*result + 24LL) = v4;
  return result;
}


// ===== 函数: sub_18004CEF0 (0x18004CEF0) =====
__int64 __fastcall sub_18004CEF0(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // r13
  __int64 v7; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rbx
  _QWORD *v10; // r12
  _QWORD *v11; // r15
  _QWORD *v12; // rcx
  _QWORD *v14; // rdi
  float v15; // xmm3_4
  __int64 v16; // rcx
  float v17; // xmm0_4
  unsigned __int64 v18; // rsi
  float v19; // xmm2_4
  __int64 v20; // rcx
  float v21; // xmm0_4
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  _QWORD *v26; // rax
  _QWORD *v27; // rdx
  __int64 v28; // rcx
  _QWORD *v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // rax
  _QWORD *v32; // r8
  _QWORD *v33; // [rsp+30h] [rbp-38h]

  v6 = 0x100000001B3LL
     * (a3[7] ^ (0x100000001B3LL
               * (a3[6] ^ (0x100000001B3LL
                         * (a3[5] ^ (0x100000001B3LL
                                   * (a3[4] ^ (0x100000001B3LL
                                             * (a3[3] ^ (0x100000001B3LL
                                                       * (a3[2] ^ (0x100000001B3LL
                                                                 * (a3[1] ^ (0x100000001B3LL
                                                                           * (*a3 ^ 0xCBF29CE484222325uLL)))))))))))))));
  v7 = 2 * (v6 & *(a1 + 48));
  v8 = *(a1 + 24);
  v9 = *(v8 + 8 * v7 + 8);
  v10 = *(a1 + 8);
  if ( v9 == v10 )
  {
    v9 = *(a1 + 8);
    v11 = v9;
    goto LABEL_9;
  }
  v12 = *(v8 + 8 * v7);
  if ( *a3 != v9[2] )
  {
    while ( v9 != v12 )
    {
      v9 = v9[1];
      if ( *a3 == v9[2] )
        goto LABEL_6;
    }
    v10 = v9;
    v11 = v9;
LABEL_9:
    if ( *(a1 + 16) == 0x7FFFFFFFFFFFFFFLL )
      std::_Xlength_error("unordered_map/set too long");
    v14 = sub_180022FF0(0x20, a1 + 8, a3);
    v14[2] = *a3;
    v14[3] = 0LL;
    v15 = *a1;
    v16 = *(a1 + 16) + 1LL;
    if ( v16 < 0 )
      v17 = (v16 & 1 | (v16 >> 1)) + (v16 & 1 | (v16 >> 1));
    else
      v17 = v16;
    v18 = *(a1 + 56);
    if ( (v18 & 0x8000000000000000uLL) != 0LL )
    {
      v20 = *(a1 + 56) & 1LL | (v18 >> 1);
      v19 = v20 + v20;
    }
    else
    {
      v19 = v18;
    }
    if ( (v17 / v19) <= v15 )
    {
LABEL_33:
      v29 = v9[1];
      ++*(a1 + 16);
      *v14 = v10;
      v14[1] = v29;
      *v29 = v14;
      v9[1] = v14;
      v30 = *(a1 + 24);
      v31 = 2 * (v6 & *(a1 + 48));
      v32 = *(v30 + 16 * (v6 & *(a1 + 48)));
      if ( v32 == *(a1 + 8) )
      {
        *(v30 + 16 * (v6 & *(a1 + 48))) = v14;
LABEL_39:
        *(v30 + 8 * v31 + 8) = v14;
        goto LABEL_40;
      }
      if ( v32 == v11 )
      {
        *(v30 + 16 * (v6 & *(a1 + 48))) = v14;
      }
      else if ( *(v30 + 16 * (v6 & *(a1 + 48)) + 8) == v29 )
      {
        goto LABEL_39;
      }
LABEL_40:
      *a2 = v14;
      *(a2 + 8) = 1;
      return a2;
    }
    v21 = ceilf(v17 / v15);
    v22 = 0LL;
    if ( v21 >= 9.223372e18 )
    {
      v21 = v21 - 9.223372e18;
      if ( v21 < 9.223372e18 )
        v22 = 0x8000000000000000uLL;
    }
    v23 = v22 + v21;
    v24 = 8LL;
    if ( v23 > 8 )
      v24 = v23;
    if ( v18 < v24 )
    {
      if ( v18 >= 0x200 || (v18 *= 8LL, v18 < v24) )
        v18 = v24;
    }
    sub_1800535B0(a1, v18);
    v25 = *(a1 + 24);
    v26 = *(v25 + 16 * (v6 & *(a1 + 48)) + 8);
    v9 = *(a1 + 8);
    if ( v26 != v9 )
    {
      v27 = *(v25 + 16 * (v6 & *(a1 + 48)));
      v28 = v14[2];
      if ( v28 != v26[2] )
      {
        while ( 1 )
        {
          v9 = v26;
          if ( v26 == v27 )
            break;
          v26 = v26[1];
          if ( v28 == v26[2] )
            goto LABEL_30;
        }
        v33 = v26;
        goto LABEL_32;
      }
LABEL_30:
      v9 = *v26;
    }
    v33 = v9;
LABEL_32:
    v11 = v9;
    v10 = v33;
    goto LABEL_33;
  }
LABEL_6:
  *a2 = v9;
  *(a2 + 8) = 0;
  return a2;
}


// ===== 函数: ceilf (0x1800818D2) =====
// attributes: thunk
float __cdecl ceilf(float X)
{
  return __imp_ceilf(X);
}


// ===== 函数: sub_1800535B0 (0x1800535B0) =====
_QWORD *__fastcall sub_1800535B0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rcx
  _QWORD *v4; // rbx
  unsigned __int64 v5; // rcx
  __int64 v6; // rdi
  _QWORD *result; // rax
  _QWORD *i; // rcx
  _QWORD *v9; // r11
  _QWORD *v10; // r9
  _QWORD *v11; // rdx
  __int64 v12; // r8
  _QWORD *v13; // r10
  _QWORD *v14; // r9
  _QWORD *v15; // r8
  _QWORD *v16; // rdx
  _QWORD *v17; // r10
  _QWORD *v18; // r9
  _QWORD *v19; // r8
  _QWORD *v20; // r10
  _QWORD *v21; // r9
  _QWORD *v22; // r8
  _QWORD *v23; // rdx

  _BitScanReverse64(&v3, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v3 )
    std::_Xlength_error("invalid hash bucket count");
  v4 = a1[1];
  _BitScanReverse64(&v5, (a2 - 1) | 1);
  v6 = 1LL << (v5 + 1);
  sub_180052F50(a1 + 3, 2 * v6, v4);
  a1[7] = v6;
  a1[6] = v6 - 1;
  result = *a1[1];
  for ( i = result; i != v4; result = i )
  {
    i = *i;
    v9 = (a1[3]
        + 16
        * ((0x100000001B3LL
          * (*(result + 23) ^ (0x100000001B3LL
                             * (*(result + 22) ^ (0x100000001B3LL
                                                * (*(result + 21) ^ (0x100000001B3LL
                                                                   * (*(result + 20) ^ (0x100000001B3LL
                                                                                      * (*(result + 19) ^ (0x100000001B3LL * (*(result + 18) ^ (0x100000001B3LL * (*(result + 17) ^ (0x100000001B3LL * (*(result + 16) ^ 0xCBF29CE484222325uLL)))))))))))))))) & a1[6]));
    v10 = *v9;
    if ( *v9 == v4 )
    {
      *v9 = result;
      v9[1] = result;
    }
    else
    {
      v11 = v9[1];
      v12 = result[2];
      if ( v12 == v11[2] )
      {
        v13 = *v11;
        if ( *v11 != result )
        {
          v14 = result[1];
          *v14 = i;
          v15 = i[1];
          *v15 = v13;
          v16 = v13[1];
          *v16 = result;
          v13[1] = v15;
          i[1] = v14;
          result[1] = v16;
        }
        v9[1] = result;
      }
      else if ( v10 == v11 )
      {
LABEL_12:
        v17 = result[1];
        *v17 = i;
        v18 = i[1];
        *v18 = v11;
        v19 = v11[1];
        *v19 = result;
        v11[1] = v18;
        i[1] = v17;
        result[1] = v19;
        *v9 = result;
      }
      else
      {
        while ( 1 )
        {
          v11 = v11[1];
          if ( v12 == v11[2] )
            break;
          if ( v10 == v11 )
            goto LABEL_12;
        }
        v20 = *v11;
        v21 = result[1];
        *v21 = i;
        v22 = i[1];
        *v22 = v20;
        v23 = v20[1];
        *v23 = result;
        v20[1] = v22;
        i[1] = v21;
        result[1] = v23;
      }
    }
  }
  return result;
}


// ===== 函数: sub_180052F50 (0x180052F50) =====
__int64 __fastcall sub_180052F50(ai **a1, unsigned __int64 a2, void **a3)
{
  ai *v3; // rax
  ai *v5; // rcx
  unsigned __int64 v7; // rbp
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // rax
  ai *v10; // rdi
  ai *v11; // rcx
  char *v12; // rdx
  __int64 result; // rax
  void **v14; // [rsp+50h] [rbp+18h] BYREF

  v14 = a3;
  v3 = a1[1];
  v5 = *a1;
  v7 = (v3 - v5) >> 3;
  if ( v7 >= a2 )
    return sub_18004D530(v5, v3, &v14);
  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_20;
  v8 = 8 * a2;
  if ( 8 * a2 < 0x1000 )
  {
    if ( v8 )
      v10 = sub_180022FF0((8 * a2), a2, a3);
    else
      v10 = 0LL;
    goto LABEL_10;
  }
  if ( v8 + 39 < v8 )
LABEL_20:
    Concurrency::cancel_current_task();
  v9 = sub_180022FF0((v8 + 39), a2, a3);
  if ( !v9 )
    goto LABEL_18;
  v10 = ((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v10 - 1) = v9;
LABEL_10:
  if ( !v7 )
    goto LABEL_15;
  v11 = *a1;
  v12 = (8 * v7);
  if ( 8 * v7 >= 0x1000 )
  {
    v12 += 39;
    if ( v11 - *(v11 - 1) - 8 <= 0x1F )
    {
      v11 = *(v11 - 1);
      goto LABEL_14;
    }
LABEL_18:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_14:
  sub_18000E0A0(v11, v12);
LABEL_15:
  result = v10 + v8;
  *a1 = v10;
  a1[1] = (v10 + v8);
  for ( a1[2] = (v10 + v8); v10 != result; v10 = (v10 + 8) )
    *v10 = a3;
  return result;
}


// ===== 函数: sub_18004D530 (0x18004D530) =====
unsigned __int64 __fastcall sub_18004D530(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 *v5; // r9
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdx

  result = 0LL;
  v5 = a1;
  v6 = (a2 - a1 + 7) >> 3;
  if ( a1 > a2 )
    v6 = 0LL;
  if ( v6 >= 2 )
  {
    result = *a3;
    v7 = &a1[v6 - 1];
    if ( v5 > a3 || v7 < a3 )
    {
      v8 = 8 * (v6 & 0xFFFFFFFFFFFFFFFEuLL);
      memset64(v5, result, v8 >> 3);
      v5 = (v5 + v8);
    }
  }
  for ( ; v5 != a2; ++v5 )
  {
    result = *a3;
    *v5 = *a3;
  }
  return result;
}


// ===== 函数: AIContextSuite_Put (0x180009BB0) =====
_QWORD *__fastcall AIContextSuite_Put(_QWORD *a1, __int64 a2, char a3)
{
  __int64 v4; // rax

  *a1 = 0LL;
  v4 = gAIContextSuite;
  if ( gAIContextSuite )
  {
    if ( a3 != 1 )
    {
LABEL_5:
      (*(v4 + 8))(a2, a1);
      return a1;
    }
    if ( !(*(gAIContextSuite + 96))() )
    {
      v4 = gAIContextSuite;
      goto LABEL_5;
    }
  }
  return a1;
}


// ===== 函数: sub_1800079B0 (0x1800079B0) =====
_QWORD *__fastcall sub_1800079B0(__int64 *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4; // rbx
  __int64 v6; // r15
  __int64 v7; // rax
  void **v8; // r8
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // r12
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rdi
  __int64 v15; // r10
  _QWORD *v16; // r15
  _QWORD *v17; // r9
  _QWORD *v18; // rcx
  _QWORD *v19; // r8
  _QWORD *v20; // rcx
  unsigned __int64 v21; // r8
  _QWORD *v22; // rbx
  _QWORD *i; // r14
  __int64 v24; // rcx
  void *v26; // [rsp+20h] [rbp-58h]
  __int64 v27; // [rsp+28h] [rbp-50h]
  unsigned __int64 v29; // [rsp+88h] [rbp+10h]
  unsigned __int64 v30; // [rsp+98h] [rbp+20h]

  v4 = a2;
  v6 = (a2 - *a1) >> 3;
  v7 = (a1[1] - *a1) >> 3;
  if ( v7 == 0x1FFFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen();
  v8 = (v7 + 1);
  v27 = v7 + 1;
  v9 = (a1[2] - *a1) >> 3;
  v10 = v9 >> 1;
  if ( v9 > 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_34;
  v11 = v7 + 1;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_34;
  v12 = 8 * v11;
  v29 = v11;
  if ( 8 * v11 < 0x1000 )
  {
    if ( v12 )
    {
      v14 = sub_180022FF0((8 * v11), v10, v8);
      v30 = v14;
    }
    else
    {
      v14 = 0LL;
      v30 = 0LL;
    }
    v29 = v11;
    goto LABEL_14;
  }
  if ( v12 + 39 < v12 )
LABEL_34:
    Concurrency::cancel_current_task();
  v13 = sub_180022FF0((v12 + 39), v10, v8);
  if ( !v13 )
    goto LABEL_33;
  v14 = (v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(v14 - 8) = v13;
  v30 = v14;
LABEL_14:
  v15 = 8 * v6;
  v16 = (8 * v6 + v14);
  try
  {
    *v16 = *a3;
    *a3 = 0LL;
    v26 = v16;
    v17 = a1[1];
    v18 = *a1;
    v19 = v14;
    if ( v4 == v17 )
    {
      for ( ; v18 != v17; ++v18 )
      {
        *v19 = *v18;
        *v18 = 0LL;
        ++v19;
      }
    }
    else
    {
      for ( ; v18 != v4; ++v18 )
      {
        *v19 = *v18;
        *v18 = 0LL;
        ++v19;
      }
      v26 = v14;
      v20 = a1[1];
      if ( v4 != v20 )
      {
        v21 = v15 - v4 + v14;
        do
        {
          *(v4 + v21 + 8) = *v4;
          *v4++ = 0LL;
        }
        while ( v4 != v20 );
      }
    }
  }
  catch ( ... )
  {
    sub_1800075C0(v26);
    sub_180009A40(a1, v30, v29);
    throw;
  }
  v22 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v22 != i; ++v22 )
      US_str_UnInitIializeZString(v22);
    v24 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
      goto LABEL_31;
    if ( (v24 - *(v24 - 8) - 8) <= 0x1F )
    {
      v24 = *(v24 - 8);
LABEL_31:
      sub_18000E0A0(v24);
      goto LABEL_32;
    }
LABEL_33:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_32:
  *a1 = v14;
  a1[1] = v14 + 8 * v27;
  a1[2] = v12 + v14;
  return v16;
}


// ===== 函数: sub_180064BB0 (0x180064BB0) =====
__int64 __fastcall sub_180064BB0(__int64 *a1, __int64 a2, void **a3)
{
  _QWORD *v3; // r12
  unsigned __int64 v5; // rax
  unsigned int v6; // edi
  __int64 *v7; // rbx
  __int64 *v8; // rdx
  __int64 *v9; // rax
  __int64 *v10; // r8
  char v11; // r10
  __int64 *v12; // rcx
  __int64 *v13; // rdx
  __int64 v14; // rsi
  __int64 v15; // rax
  _QWORD *v16; // r15
  _QWORD *v17; // r14
  _QWORD *v18; // rsi
  __int64 v19; // rsi
  __int64 v20; // r14
  __int64 v21; // r12
  _QWORD *v22; // rsi
  __int64 v23; // rax
  __int64 **v24; // rax
  __int64 *i; // rax
  __int64 *j; // rcx
  __int64 v27; // rcx
  __int64 v28; // rbx
  __int64 v29; // rcx
  __int64 v31; // [rsp+20h] [rbp-40h] BYREF
  __int64 v32[2]; // [rsp+28h] [rbp-38h] BYREF
  __int128 v33; // [rsp+38h] [rbp-28h] BYREF
  __int128 v34; // [rsp+48h] [rbp-18h] BYREF
  __int64 v35; // [rsp+58h] [rbp-8h]
  __int64 v37; // [rsp+B0h] [rbp+50h] BYREF
  __int64 v38; // [rsp+B8h] [rbp+58h] BYREF

  v32[1] = -2LL;
  v3 = a2;
  v33 = 0LL;
  v5 = sub_180022FF0(0x20, a2, a3);
  *v5 = v5;
  *(v5 + 8) = v5;
  *(v5 + 16) = v5;
  *(v5 + 24) = 257;
  *&v33 = v5;
  sub_180068160(v3, &v33);
  unknown_libname_1(&v31);
  sub_1800774D0(&v31, v3);
  v37 = 0LL;
  v6 = (*gAIReplaceFileConfirmationSuite)(&v37);
  if ( !v6 )
  {
    v7 = *v33;
    if ( !*(*v33 + 25LL) )
    {
      while ( 1 )
      {
        v34 = 0LL;
        v35 = 0LL;
        v8 = v3[6];
        v9 = v8[1];
        v10 = v8;
        v11 = *(v9 + 25);
        if ( !v11 )
        {
          v12 = v8[1];
          do
          {
            if ( *(v12 + 32) >= *(v7 + 26) )
            {
              v10 = v12;
              v12 = *v12;
            }
            else
            {
              v12 = v12[2];
            }
          }
          while ( !*(v12 + 25) );
        }
        if ( *(v10 + 25) || *(v7 + 26) < *(v10 + 32) || v10 == v8 )
          break;
        if ( !v11 )
        {
          do
          {
            if ( *(v9 + 32) >= *(v7 + 26) )
            {
              v8 = v9;
              v9 = *v9;
            }
            else
            {
              v9 = v9[2];
            }
          }
          while ( !*(v9 + 25) );
        }
        if ( *(v8 + 25) || *(v7 + 26) < *(v8 + 32) )
        {
          std::_Xout_of_range("invalid map<K, T> key");
          JUMPOUT(0x180064FA3LL);
        }
        v13 = v8 + 5;
        if ( &v34 != v13 )
          sub_1800671B0(&v34, *v13, v13[1]);
        v14 = *(&v34 + 1);
        sub_180067A70(v32, v34, *(&v34 + 1));
        if ( v32[0] != v14 )
        {
          v15 = sub_180067950(v14, *(&v34 + 1), v32[0]);
          v16 = v15;
          v17 = *(&v34 + 1);
          if ( v15 != *(&v34 + 1) )
          {
            v18 = (v15 + 8);
            do
            {
              US_str_UnInitIializeZString(v18 + 1);
              US_str_UnInitIializeZString(v18);
              v18 += 5;
            }
            while ( v18 - 1 != v17 );
          }
          goto LABEL_28;
        }
        v16 = *(&v34 + 1);
LABEL_29:
        v19 = v34;
        if ( v34 != v16 )
        {
          do
          {
            v20 = *a1;
            v21 = a1[1];
            if ( *a1 != v21 )
            {
              do
              {
                unknown_libname_1(&v38);
                (*(gAISmartExportSuite + 56LL))(v20, v19, &v31, &v38);
                (gAIReplaceFileConfirmationSuite[2])(v37, &v38, 0LL);
                sub_180077420(&v38);
                v20 += 8LL;
              }
              while ( v20 != v21 );
            }
            v19 += 40LL;
          }
          while ( v19 != v16 );
          v16 = *(&v34 + 1);
          v19 = v34;
          v3 = a2;
        }
        if ( v19 )
        {
          if ( v19 != v16 )
          {
            v22 = (v19 + 8);
            do
            {
              US_str_UnInitIializeZString(v22 + 1);
              US_str_UnInitIializeZString(v22);
              v22 += 5;
            }
            while ( v22 - 1 != v16 );
            v19 = v34;
          }
          v23 = v19;
          if ( (40 * ((v35 - v19) / 40)) >= 0x1000 )
          {
            v19 = *(v19 - 8);
            if ( (v23 - v19 - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
          }
          sub_18000E0A0(v19);
        }
        v24 = v7[2];
        if ( *(v24 + 25) )
        {
          for ( i = v7[1]; !*(i + 25); i = i[1] )
          {
            if ( v7 != i[2] )
              break;
            v7 = i;
          }
          v7 = i;
        }
        else
        {
          v7 = v7[2];
          for ( j = *v24; !*(j + 25); j = *j )
            v7 = j;
        }
        if ( *(v7 + 25) )
          goto LABEL_50;
      }
      v16 = 0LL;
LABEL_28:
      *(&v34 + 1) = v16;
      goto LABEL_29;
    }
LABEL_50:
    v6 = sub_180067DC0(v37, v3);
    (gAIReplaceFileConfirmationSuite[10])(v37);
  }
  sub_180077420(&v31);
  v27 = v33;
  v28 = *(v33 + 8);
  if ( !*(v28 + 25) )
  {
    do
    {
      sub_180027AE0(&v33, &v33, *(v28 + 16));
      v29 = v28;
      v28 = *v28;
      sub_18000E0A0(v29);
    }
    while ( !*(v28 + 25) );
    v27 = v33;
  }
  sub_18000E0A0(v27);
  return v6;
}


// ===== 函数: sub_180067DC0 (0x180067DC0) =====
__int64 __fastcall sub_180067DC0(__int64 a1, __int64 a2)
{
  unsigned int v4; // r14d
  __int64 v5; // rdx
  void **v6; // r8
  _QWORD *v7; // rsi
  __int64 *v8; // rdi
  __int64 *v9; // rbx
  __int64 *v10; // rbx
  unsigned __int64 v11; // rdi
  _QWORD v13[3]; // [rsp+20h] [rbp-40h] BYREF
  unsigned __int64 v14; // [rsp+38h] [rbp-28h]
  __int64 *v15; // [rsp+40h] [rbp-20h] BYREF
  int v16; // [rsp+48h] [rbp-18h]
  int v17; // [rsp+A0h] [rbp+40h] BYREF
  __int64 v18; // [rsp+A8h] [rbp+48h] BYREF

  v13[1] = -2LL;
  v4 = (gAIReplaceFileConfirmationSuite[4])();
  if ( !v4 )
  {
    v13[0] = 0LL;
    (gAIReplaceFileConfirmationSuite[7])(a1, v13);
    v17 = -1;
    unknown_libname_1(&v18);
    if ( !(gAIReplaceFileConfirmationSuite[8])(v13[0], &v18, &v17) )
    {
      v7 = (a2 + 16);
      do
      {
        v8 = *v7;
        v9 = *(*v7 + 8LL);
        v15 = v9;
        v16 = 0;
        while ( !*(v9 + 25) )
        {
          v15 = v9;
          if ( sub_1800775B0((v9 + 4), &v18) )
          {
            v16 = 0;
            v9 = v9[2];
          }
          else
          {
            v16 = 1;
            v8 = v9;
            v9 = *v9;
          }
        }
        if ( *(v8 + 25) || sub_1800775B0(&v18, (v8 + 4)) )
        {
          if ( v7[1] == 0x666666666666666LL )
            std::vector<void *>::_Xlen();
          v10 = *v7;
          v13[2] = v7;
          v14 = 0LL;
          v11 = sub_180022FF0(0x28, v5, v6);
          v14 = v11;
          sub_180077240((v11 + 32), &v18);
          *v11 = v10;
          *(v11 + 8) = v10;
          *(v11 + 16) = v10;
          *(v11 + 24) = 0;
          v14 = 0LL;
          sub_180009780(v7, &v15, v11);
        }
      }
      while ( !(gAIReplaceFileConfirmationSuite[8])(v13[0], &v18, &v17) );
    }
    (gAIReplaceFileConfirmationSuite[9])(v13[0]);
    sub_180077420(&v18);
  }
  return v4;
}


// ===== 函数: sub_180077240 (0x180077240) =====
_QWORD *__fastcall sub_180077240(_QWORD *a1, __int64 a2)
{
  __int128 *AIFilePathSuite; // rax
  __int128 *v5; // rbx
  unsigned int v6; // eax
  __int64 v7; // rcx
  __int128 **v8; // rax
  unsigned int v9; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  AIFilePathSuite = GetAIFilePathSuite();
  v5 = AIFilePathSuite;
  if ( !*(AIFilePathSuite + 1) && qword_1800F45C0 )
  {
    v6 = (*qword_1800F45C0)(*(AIFilePathSuite + 2), *(AIFilePathSuite + 6), AIFilePathSuite + 8);
    if ( v6 )
    {
      sub_1800064A0(pExceptionObject, v6, 0LL);
      throw pExceptionObject;
    }
    if ( !*(v5 + 28) )
    {
      v8 = sub_180026160(v7);
      *v5 = *v8;
      *v8 = v5;
    }
  }
  v9 = (*(*(v5 + 1) + 16LL))(a2, a1);
  if ( v9 )
  {
    sub_1800064A0(pExceptionObject, v9, 0LL);
    throw pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_180006EC0 (0x180006EC0) =====
__int64 __fastcall sub_180006EC0(__int64 a1, __int64 a2, void **a3)
{
  unsigned __int64 v4; // rax
  __int64 v5; // rdx
  void **v6; // r8
  unsigned __int64 v7; // rax
  _QWORD *v8; // r15
  _QWORD *v9; // r12
  __int64 v10; // rdx
  void **v11; // r8
  _QWORD *v12; // r14
  unsigned __int64 v13; // rsi
  __int64 *v14; // rbx
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rax
  _QWORD *v17; // r15
  _QWORD *v18; // r12
  __int64 v19; // rdx
  void **v20; // r8
  __int64 v21; // rdi
  __int64 v22; // rbx
  __int64 v23; // rsi
  int v24; // eax
  _QWORD *v25; // rax
  unsigned int v26; // r14d
  __int64 i; // rcx
  __int64 v28; // rdx
  void **v29; // r8
  unsigned __int64 v30; // rdi
  __int64 *v31; // rbx
  unsigned __int64 v32; // rsi
  int v33; // eax
  _QWORD *UnicodeStringFromCString; // rax
  __int64 *v35; // rbx
  __int64 *v36; // rsi
  unsigned __int64 v37; // rbx
  __int64 v38; // rbx
  __int64 v39; // rsi
  unsigned __int64 v40; // rbx
  __int64 v41; // rdi
  __int64 v42; // rbx
  __int64 v43; // rcx
  __int64 v44; // rdi
  __int64 v45; // rbx
  _QWORD v47[2]; // [rsp+20h] [rbp-49h] BYREF
  unsigned __int64 v48; // [rsp+30h] [rbp-39h] BYREF
  __int64 v49; // [rsp+38h] [rbp-31h]
  unsigned __int64 v50; // [rsp+40h] [rbp-29h] BYREF
  __int64 v51; // [rsp+48h] [rbp-21h]
  __int128 v52; // [rsp+50h] [rbp-19h] BYREF
  __int64 *v53; // [rsp+60h] [rbp-9h]
  unsigned __int64 v54; // [rsp+68h] [rbp-1h]
  _OWORD v55[5]; // [rsp+70h] [rbp+7h] BYREF
  __int64 v56; // [rsp+D8h] [rbp+6Fh] BYREF
  __int64 v57; // [rsp+E0h] [rbp+77h] BYREF
  __int64 v58; // [rsp+E8h] [rbp+7Fh] BYREF

  v47[1] = -2LL;
  v49 = 0LL;
  v4 = sub_180022FF0(0x28, a2, a3);
  *v4 = v4;
  *(v4 + 8) = v4;
  *(v4 + 16) = v4;
  *(v4 + 24) = 257;
  v48 = v4;
  v51 = 0LL;
  v7 = sub_180022FF0(0x28, v5, v6);
  *v7 = v7;
  *(v7 + 8) = v7;
  *(v7 + 16) = v7;
  *(v7 + 24) = 257;
  v50 = v7;
  v8 = *a1;
  v9 = *(a1 + 8);
  if ( *a1 != v9 )
  {
    while ( 1 )
    {
      v12 = (*(**v8 + 16LL))(*v8, &v56);
      v13 = v48;
      v14 = *(v48 + 8);
      *&v55[0] = v14;
      DWORD2(v55[0]) = 0;
      v15 = v48;
      if ( !*(v14 + 25) )
      {
        do
        {
          *&v55[0] = v14;
          if ( sub_18007B870((v14 + 4), v12) >= 0 )
          {
            DWORD2(v55[0]) = 1;
            v15 = v14;
            v14 = *v14;
          }
          else
          {
            DWORD2(v55[0]) = 0;
            v14 = v14[2];
          }
        }
        while ( !*(v14 + 25) );
        v13 = v48;
      }
      if ( *(v15 + 25) )
        goto LABEL_11;
      if ( sub_18007B870(v12, v15 + 32) < 0 )
        break;
LABEL_13:
      US_str_UnInitIializeZString(&v56);
      v8 += 2;
      if ( v8 == v9 )
        goto LABEL_14;
    }
    v13 = v48;
LABEL_11:
    if ( v49 == 0x666666666666666LL )
      std::vector<void *>::_Xlen();
    v53 = &v48;
    v54 = 0LL;
    v16 = sub_180022FF0(0x28, v10, v11);
    *(v16 + 32) = *v12;
    *v12 = 0LL;
    *v16 = v13;
    *(v16 + 8) = v13;
    *(v16 + 16) = v13;
    *(v16 + 24) = 0;
    v54 = 0LL;
    v52 = v55[0];
    sub_180009780(&v48, &v52, v16);
    goto LABEL_13;
  }
LABEL_14:
  v17 = *a1;
  v18 = *(a1 + 8);
  while ( v17 != v18 )
  {
    (*(**v17 + 16LL))(*v17, &v57);
    v21 = v50;
    v22 = *(v50 + 8);
    v23 = v50;
    if ( !*(v22 + 25) )
    {
      do
      {
        if ( sub_18007B870(v22 + 32, &v57) >= 0 )
        {
          v23 = v22;
          v22 = *v22;
        }
        else
        {
          v22 = *(v22 + 16);
        }
      }
      while ( !*(v22 + 25) );
      v21 = v50;
    }
    if ( !*(v23 + 25) )
    {
      v24 = sub_18007B870(&v57, v23 + 32);
      v21 = v50;
      if ( v24 >= 0 && v23 != v50 )
      {
        CopyUnicodeStr(&v56, &v57);
        v25 = CreateUnicodeStringFromCString(&v58, "_", 0);
        sub_18007B580(&v56, v25);
        US_str_UnInitIializeZString(&v58);
        v26 = 2;
        for ( i = 1LL; ; i = v26++ )
        {
          sub_18006F4B0(i, &v56);
          v30 = v48;
          v31 = *(v48 + 8);
          v32 = v48;
          if ( !*(v31 + 25) )
          {
            do
            {
              if ( sub_18007B870((v31 + 4), &v56) >= 0 )
              {
                v32 = v31;
                v31 = *v31;
              }
              else
              {
                v31 = v31[2];
              }
            }
            while ( !*(v31 + 25) );
            v30 = v48;
          }
          if ( *(v32 + 25) )
            break;
          v33 = sub_18007B870(&v56, v32 + 32);
          v30 = v48;
          if ( v33 < 0 || v32 == v48 )
            break;
          sub_18007B0A0(&v56, &v57);
          UnicodeStringFromCString = CreateUnicodeStringFromCString(v47, "_", 0);
          sub_18007B580(&v56, UnicodeStringFromCString);
          US_str_UnInitIializeZString(v47);
        }
        v35 = *(v30 + 8);
        *&v55[0] = v35;
        DWORD2(v55[0]) = 0;
        v36 = v30;
        if ( !*(v35 + 25) )
        {
          do
          {
            *&v55[0] = v35;
            if ( sub_18007B870((v35 + 4), &v56) >= 0 )
            {
              DWORD2(v55[0]) = 1;
              v36 = v35;
              v35 = *v35;
            }
            else
            {
              DWORD2(v55[0]) = 0;
              v35 = v35[2];
            }
          }
          while ( !*(v35 + 25) );
          v30 = v48;
        }
        if ( *(v36 + 25) )
        {
LABEL_45:
          if ( v49 == 0x666666666666666LL )
            std::vector<void *>::_Xlen();
          *&v52 = &v48;
          *(&v52 + 1) = 0LL;
          v37 = sub_180022FF0(0x28, v28, v29);
          *(&v52 + 1) = v37;
          CopyUnicodeStr((v37 + 32), &v56);
          *v37 = v30;
          *(v37 + 8) = v30;
          *(v37 + 16) = v30;
          *(v37 + 24) = 0;
          *(&v52 + 1) = 0LL;
          sub_180009780(&v48, v55, v37);
        }
        else if ( sub_18007B870(&v56, (v36 + 4)) < 0 )
        {
          v30 = v48;
          goto LABEL_45;
        }
        (*(**v17 + 24LL))(*v17, &v56, 0LL);
        US_str_UnInitIializeZString(&v56);
        goto LABEL_59;
      }
    }
    v38 = *(v21 + 8);
    *&v55[0] = v38;
    DWORD2(v55[0]) = 0;
    v39 = v21;
    if ( !*(v38 + 25) )
    {
      do
      {
        *&v55[0] = v38;
        if ( sub_18007B870(v38 + 32, &v57) >= 0 )
        {
          DWORD2(v55[0]) = 1;
          v39 = v38;
          v38 = *v38;
        }
        else
        {
          DWORD2(v55[0]) = 0;
          v38 = *(v38 + 16);
        }
      }
      while ( !*(v38 + 25) );
      v21 = v50;
    }
    if ( !*(v39 + 25) )
    {
      if ( sub_18007B870(&v57, v39 + 32) >= 0 )
        goto LABEL_59;
      v21 = v50;
    }
    if ( v51 == 0x666666666666666LL )
      std::vector<void *>::_Xlen();
    v53 = &v50;
    v54 = 0LL;
    v40 = sub_180022FF0(0x28, v19, v20);
    v54 = v40;
    CopyUnicodeStr((v40 + 32), &v57);
    *v40 = v21;
    *(v40 + 8) = v21;
    *(v40 + 16) = v21;
    *(v40 + 24) = 0;
    v54 = 0LL;
    sub_180009780(&v50, v55, v40);
LABEL_59:
    US_str_UnInitIializeZString(&v57);
    v17 += 2;
  }
  v41 = *(v50 + 8);
  while ( !*(v41 + 25) )
  {
    sub_180007C80(&v50, &v50, *(v41 + 16));
    v42 = v41;
    v41 = *v41;
    US_str_UnInitIializeZString((v42 + 32));
    sub_18000E0A0(v42);
  }
  sub_18000E0A0(v50);
  v43 = v48;
  v44 = *(v48 + 8);
  if ( !*(v44 + 25) )
  {
    do
    {
      sub_180007C80(&v48, &v48, *(v44 + 16));
      v45 = v44;
      v44 = *v44;
      US_str_UnInitIializeZString((v45 + 32));
      sub_18000E0A0(v45);
    }
    while ( !*(v44 + 25) );
    v43 = v48;
  }
  return sub_18000E0A0(v43);
}


// ===== 函数: sub_18007B580 (0x18007B580) =====
__int64 __fastcall sub_18007B580(__int64 a1, __int64 a2)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v5; // rax
  int v6; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v5 = InitializeZString_fun_p(AIUnicodeStringSuite);
  v6 = (*(v5 + 32))(a1, a2);
  if ( v6 )
  {
    sub_1800064A0(pExceptionObject, v6, 0LL);
    throw pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_180007C80 (0x180007C80) =====
__int64 __fastcall sub_180007C80(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*(i + 25); result = sub_18000E0A0(v6) )
  {
    sub_180007C80(a1, a2, *(i + 16));
    v6 = i;
    i = *i;
    US_str_UnInitIializeZString((v6 + 32));
  }
  return result;
}


// ===== 函数: CreateUnicodeStringFromCString (0x18007AC30) =====
// 这个函数的工作流程非常清晰，我们可以对照您提供的 AIUnicodeStringSuite 结构体来理解：
// 
// 获取API函数指针: 函数首先通过 sub_18001EF40 获取 AIUnicodeStringSuite 中可用的函数指针。根据其调用方式和参数，我们可以确定它最终拿到的是 Initialize 这个函数。
// 
// C++
// 
// AIAPI AIErr(* Initialize )(ai::UnicodeString &str, const char *string, ai::UnicodeString::offset_type srcByteLen, AICharacterEncoding encoding)
// 计算输入字符串长度: 在调用核心API之前，它会执行一个循环（do ++v8; while ( *(a2 + v8) );），这实际上是在计算输入C字符串（参数 a2）的长度，功能等同于 strlen。
// 
// 调用核心API: 函数的核心是 (*v7)(a1, a2, v8, a3); 这一行，它完美地对应了 Initialize 函数的签名：
// 
// a1: 指向一个 ai::UnicodeString 对象，用于接收结果。
// 
// a2: 指向源C字符串。
// 
// v8: 刚刚计算出的源字符串的长度。
// 
// a3: 字符编码格式（AICharacterEncoding），比如 kAIPlatformCharacterEncoding。
// 
// 错误处理: 在调用API后，函数会检查返回值。如果返回值不为0（表示发生了错误），它会构造一个异常对象并 throw（抛出），中断正常的执行流程。这是一种比返回错误码更现代的C++错误处理方式。
_QWORD *__fastcall CreateUnicodeStringFromCString(_QWORD *a1, __int64 a2, unsigned int a3)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 (__fastcall **v7)(_QWORD *, __int64, __int64, _QWORD); // rax
  __int64 v8; // r8
  int v9; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  if ( a2 )
  {
    AIUnicodeStringSuite = GetAIUnicodeStringSuite();
    v7 = InitializeZString_fun_p(AIUnicodeStringSuite);
    v8 = -1LL;
    do
      ++v8;
    while ( *(a2 + v8) );
    v9 = (*v7)(a1, a2, v8, a3);
    if ( v9 )
    {
      sub_1800064A0(pExceptionObject, v9, 0LL);
      throw pExceptionObject;
    }
  }
  return a1;
}


// ===== 函数: sub_18006F4B0 (0x18006F4B0) =====
void __fastcall sub_18006F4B0(int a1, __int64 a2)
{
  __int64 v2; // rbx
  int v4; // eax
  char *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // [rsp+28h] [rbp-A0h] BYREF
  int v10; // [rsp+30h] [rbp-98h] BYREF
  char *v11; // [rsp+38h] [rbp-90h]
  char v12; // [rsp+40h] [rbp-88h]
  int v13; // [rsp+44h] [rbp-84h]
  __int64 v14; // [rsp+48h] [rbp-80h]
  __int128 v15; // [rsp+50h] [rbp-78h] BYREF
  __int128 v16; // [rsp+60h] [rbp-68h]
  _BYTE v17[6]; // [rsp+72h] [rbp-56h] BYREF
  char v18; // [rsp+87h] [rbp-41h] BYREF
  char *v19; // [rsp+88h] [rbp-40h]
  char *v20; // [rsp+90h] [rbp-38h]
  __int128 v21; // [rsp+98h] [rbp-30h] BYREF
  __int128 v22; // [rsp+A8h] [rbp-20h]

  v14 = -2LL;
  v2 = a2;
  v9 = a2;
  *&v15 = 0LL;
  *&v16 = 0LL;
  *(&v16 + 1) = 15LL;
  *&v21 = 0LL;
  *&v22 = 0LL;
  *(&v22 + 1) = 15LL;
  v19 = v17;
  v20 = &v18;
  v4 = -a1;
  if ( a1 >= 0 )
    v4 = a1;
  v10 = v4;
  v11 = &v18;
  v12 = 48;
  v13 = 48;
  try
  {
    v5 = sub_1800715D0(&v10);
    if ( a1 < 0 )
      *--v5 = 45;
    v19 = v5;
    v20 = &v18;
    sub_180023710(&v21, v5, &v18 - v5);
    if ( *(&v16 + 1) >= 0x10uLL )
    {
      v6 = v15;
      if ( (*(&v16 + 1) + 1LL) >= 0x1000 )
      {
        v6 = *(v15 - 8);
        if ( (v15 - v6 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18000E0A0(v6);
    }
    v15 = v21;
    v16 = v22;
  }
  catch ( boost::bad_lexical_cast )
  {
    v2 = v9;
  }
  v5 = sub_1800715D0(&v10);
  if ( a1 < 0 )
    *--v5 = 45;
  v19 = v5;
  v20 = &v18;
}


// ===== 函数: sub_18007B420 (0x18007B420) =====
__int64 __fastcall sub_18007B420(__int64 a1, __int64 a2)
{
  sub_18007AA60(a1, a2, 16LL);
  return a1;
}


// ===== 函数: sub_18007AA60 (0x18007AA60) =====
_QWORD *__fastcall sub_18007AA60(_QWORD *a1, _QWORD *a2, unsigned int a3)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 (__fastcall **v7)(_QWORD *, _QWORD *, __int64, _QWORD); // rax
  __int64 v8; // r8
  int v9; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v7 = InitializeZString_fun_p(AIUnicodeStringSuite);
  v8 = a2[2];
  if ( a2[3] >= 0x10uLL )
    a2 = *a2;
  v9 = (*v7)(a1, a2, v8, a3);
  if ( v9 )
  {
    sub_1800064A0(pExceptionObject, v9, 0LL);
    throw pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_1800715D0 (0x1800715D0) =====
__int64 __fastcall sub_1800715D0(__int64 a1)
{
  const struct std::locale *v2; // rax
  unsigned int v3; // edx
  __int64 v4; // rbx
  __int64 v5; // rdi
  unsigned __int64 v6; // rsi
  char *v7; // rcx
  char v8; // di
  __int64 v9; // r9
  char *v10; // rcx
  _QWORD *v11; // rdx
  unsigned __int64 v12; // r8
  char v13; // r10
  char v14; // r11
  _QWORD *v15; // rax
  unsigned int v16; // edx
  unsigned int v17; // edx
  __int64 v18; // rcx
  void (__fastcall ***v19)(_QWORD, __int64); // rax
  _BYTE v21[8]; // [rsp+28h] [rbp-50h] BYREF
  struct std::locale::_Locimp *v22; // [rsp+30h] [rbp-48h]
  __int64 v23; // [rsp+38h] [rbp-40h]
  _QWORD v24[2]; // [rsp+40h] [rbp-38h] BYREF
  unsigned __int64 v25; // [rsp+50h] [rbp-28h]
  unsigned __int64 v26; // [rsp+58h] [rbp-20h]

  v23 = -2LL;
  v22 = std::locale::_Init(1);
  v2 = std::locale::classic();
  if ( sub_18006EFD0(v21, v2) )
  {
    do
    {
      *--*(a1 + 8) = *(a1 + 20) + *a1 % 0xAu;
      v3 = *a1 / 0xAu;
      *a1 = v3;
    }
    while ( v3 );
    v4 = *(a1 + 8);
  }
  else
  {
    v5 = sub_18006E6C0(v21);
    (*(*v5 + 40LL))(v5, v24);
    v6 = v25;
    if ( !v25 )
      goto LABEL_33;
    v7 = v24;
    if ( v26 >= 0x10 )
      v7 = v24[0];
    if ( *v7 > 0 )
    {
      v8 = (*(*v5 + 32LL))(v5);
      v9 = 0LL;
      v10 = v24;
      v11 = v24[0];
      v12 = v26;
      if ( v26 >= 0x10 )
        v10 = v24[0];
      v13 = *v10;
      v14 = *v10;
      while ( 1 )
      {
        if ( !v14 )
        {
          if ( ++v9 < v6 )
          {
            v15 = v24;
            if ( v12 >= 0x10 )
              v15 = v11;
            v13 = *(v15 + v9);
            if ( v13 <= 0 )
              v13 = 127;
          }
          v14 = v13;
          *--*(a1 + 8) = v8;
        }
        --v14;
        *--*(a1 + 8) = *(a1 + 20) + *a1 % 0xAu;
        v16 = *a1 / 0xAu;
        *a1 = v16;
        if ( !v16 )
          break;
        v12 = v26;
        v11 = v24[0];
      }
    }
    else
    {
LABEL_33:
      do
      {
        *--*(a1 + 8) = *(a1 + 20) + *a1 % 0xAu;
        v17 = *a1 / 0xAu;
        *a1 = v17;
      }
      while ( v17 );
    }
    v4 = *(a1 + 8);
    if ( v26 >= 0x10 )
    {
      v18 = v24[0];
      if ( v26 + 1 >= 0x1000 )
      {
        v18 = *(v24[0] - 8LL);
        if ( (v24[0] - v18 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18000E0A0(v18);
    }
    v25 = 0LL;
    v26 = 15LL;
    LOBYTE(v24[0]) = 0;
  }
  if ( v22 )
  {
    v19 = (*(*v22 + 16LL))(v22);
    if ( v19 )
      (**v19)(v19, 1LL);
  }
  return v4;
}


// ===== 函数: sub_18006E6C0 (0x18006E6C0) =====
struct std::_Facet_base *__fastcall sub_18006E6C0(__int64 a1)
{
  char v2; // di
  __int64 v3; // rbp
  void **v4; // r8
  unsigned __int64 v5; // r14
  __int64 v6; // rdx
  __int64 v7; // rsi
  struct std::_Facet_base *v8; // rbx
  struct std::locale::_Locimp *v9; // rax
  __int64 v10; // rdx
  unsigned __int64 v11; // rbx
  void **v12; // r8
  __int64 v13; // rcx
  const char *v14; // rax
  __int64 v15; // rax
  _BYTE v17[144]; // [rsp+28h] [rbp-90h] BYREF
  char v18; // [rsp+C8h] [rbp+10h] BYREF
  unsigned __int64 v19; // [rsp+D0h] [rbp+18h]

  v2 = 0;
  std::_Lockit::_Lockit(&v18, 0);
  v3 = qword_1800F4FC0;
  v5 = std::locale::id::operator unsigned __int64(&unk_1800F2240);
  v6 = *(a1 + 8);
  v7 = 8 * v5;
  if ( v5 >= *(v6 + 24) )
  {
    v8 = 0LL;
  }
  else
  {
    v8 = *(v7 + *(v6 + 16));
    if ( v8 )
      goto LABEL_20;
  }
  if ( !*(v6 + 36) )
    goto LABEL_8;
  v9 = std::locale::_Getgloballocale();
  if ( v5 < *(v9 + 3) )
  {
    v8 = *(v7 + *(v9 + 2));
LABEL_8:
    if ( v8 )
      goto LABEL_20;
  }
  if ( v3 )
  {
    v8 = v3;
  }
  else
  {
    v11 = sub_180022FF0(0x30, v6, v4);
    v19 = v11;
    if ( v11 )
    {
      v13 = *(a1 + 8);
      if ( v13 )
        v14 = std::_Yarn<char>::c_str(v13 + 40);
      else
        v14 = byte_18008D60A;
      v15 = std::_Locinfo::_Locinfo(v17, v14);
      v2 = 1;
      v8 = sub_18006E9D0(v11, v15, 0LL, 1LL, -2LL);
    }
    else
    {
      v8 = 0LL;
    }
    if ( (v2 & 1) != 0 )
      std::_Locinfo::~_Locinfo(v17);
    std::_Facet_Register(v8, v10, v12);
    (*(*v8 + 8LL))(v8);
    qword_1800F4FC0 = v8;
  }
LABEL_20:
  std::_Lockit::~_Lockit(&v18);
  return v8;
}


// ===== 函数: ?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ (0x180080654) =====
// attributes: thunk
struct std::locale::_Locimp *std::locale::_Getgloballocale(void)
{
  return __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ();
}


// ===== 函数: ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z (0x18008061C) =====
void __fastcall std::_Facet_Register(struct std::_Facet_base *a1, __int64 a2, void **a3)
{
  _QWORD *v4; // rax

  v4 = sub_180022FF0(0x10, a2, a3);
  if ( v4 )
  {
    *v4 = qword_1800F65E8;
    v4[1] = a1;
  }
  qword_1800F65E8 = v4;
}


// ===== 函数: sub_18006E9D0 (0x18006E9D0) =====
__int64 __fastcall sub_18006E9D0(__int64 a1, std::_Locinfo *a2, unsigned __int64 a3, char a4)
{
  struct lconv *v7; // r15
  char *grouping; // rcx
  const char *v9; // rsi
  __int64 v10; // rbx
  __int64 v11; // rax
  size_t v12; // rbp
  void *v13; // rax
  void *v14; // r14
  const char *v15; // rax
  const char *v16; // rsi
  size_t v17; // rbp
  void *v18; // rax
  void *v19; // rbx
  char v20; // al
  struct _Cvtvec v22; // [rsp+38h] [rbp-A0h] BYREF
  struct _Cvtvec v23; // [rsp+68h] [rbp-70h] BYREF

  std::locale::facet::facet(a1, a3);
  *a1 = &std::numpunct<char>::`vftable';
  v7 = localeconv();
  std::_Locinfo::_Getcvt(a2, &v22);
  *(a1 + 16) = 0LL;
  *(a1 + 32) = 0LL;
  *(a1 + 40) = 0LL;
  std::_Locinfo::_Getcvt(a2, &v23);
  grouping = byte_18008D60A;
  if ( !a4 )
    grouping = v7->grouping;
  *(a1 + 16) = sub_180006DD0(grouping);
  v9 = std::_Locinfo::_Getfalse(a2);
  v10 = -1LL;
  v11 = -1LL;
  do
    ++v11;
  while ( v9[v11] );
  v12 = v11 + 1;
  v13 = calloc(v11 + 1, 1uLL);
  v14 = v13;
  if ( !v13 )
  {
LABEL_18:
    std::_Xbad_alloc();
    JUMPOUT(0x18006EB7DLL);
  }
  if ( v12 )
    memcpy(v13, v9, v12);
  *(a1 + 32) = v14;
  v15 = std::_Locinfo::_Gettrue(a2);
  v16 = v15;
  do
    ++v10;
  while ( v15[v10] );
  v17 = v10 + 1;
  v18 = calloc(v10 + 1, 1uLL);
  v19 = v18;
  if ( !v18 )
  {
    std::_Xbad_alloc();
    goto LABEL_18;
  }
  if ( v17 )
    memcpy(v18, v16, v17);
  *(a1 + 40) = v19;
  if ( a4 )
  {
    *(a1 + 24) = 46;
    v20 = 44;
  }
  else
  {
    *(a1 + 24) = *v7->decimal_point;
    v20 = *v7->thousands_sep;
  }
  *(a1 + 25) = v20;
  return a1;
}


// ===== 函数: sub_180006DD0 (0x180006DD0) =====
void *__fastcall sub_180006DD0(_BYTE *Src)
{
  __int64 v2; // rax
  size_t v4; // rsi
  void *v5; // rax
  void *v6; // rdi

  v2 = -1LL;
  while ( Src[++v2] != 0 )
    ;
  v4 = v2 + 1;
  v5 = calloc(v2 + 1, 1uLL);
  v6 = v5;
  if ( !v5 )
  {
    std::_Xbad_alloc();
    JUMPOUT(0x180006E40LL);
  }
  if ( v4 )
    memcpy(v5, Src, v4);
  return v6;
}


// ===== 函数: memcpy (0x180081890) =====
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}


// ===== 函数: ?_Xbad_alloc@std@@YAXXZ (0x1800805CB) =====
// attributes: thunk
void std::_Xbad_alloc(void)
{
  __imp_?_Xbad_alloc@std@@YAXXZ();
}


// ===== 函数: __security_check_cookie (0x180080B50) =====
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}


// ===== 函数: sub_18006EFD0 (0x18006EFD0) =====
__int64 __fastcall sub_18006EFD0(__int64 a1, __int64 a2)
{
  char v4; // bl
  _QWORD *v5; // rax
  unsigned __int64 v6; // rsi
  size_t v7; // r8
  _QWORD *v8; // rdi
  _QWORD *v9; // rax
  size_t v10; // rbp
  size_t v11; // rsi
  size_t v12; // r8
  unsigned __int8 v13; // di
  void *v14; // rdx
  ai *v15; // rcx
  void *v16; // rdx
  ai *v17; // rcx
  void *v18; // rdx
  ai *v19; // rcx
  _QWORD v21[3]; // [rsp+30h] [rbp-88h] BYREF
  unsigned __int64 v22; // [rsp+48h] [rbp-70h]
  _QWORD v23[3]; // [rsp+50h] [rbp-68h] BYREF
  unsigned __int64 v24; // [rsp+68h] [rbp-50h]
  ai *v25; // [rsp+70h] [rbp-48h] BYREF
  unsigned __int64 v26; // [rsp+88h] [rbp-30h]

  v4 = 0;
  if ( *(a1 + 8) == *(a2 + 8) )
    goto LABEL_18;
  v5 = sub_1800719D0(a1, &v25);
  v4 = 1;
  v6 = v5[2];
  if ( v5[3] >= 0x10uLL )
    v5 = *v5;
  v7 = v6;
  if ( v6 > 1 )
    v7 = 1LL;
  if ( !memcmp(v5, &unk_1800A2CC8, v7) && v6 == 1 )
    goto LABEL_17;
  v8 = sub_1800719D0(a1, v23);
  v9 = sub_1800719D0(a2, v21);
  v4 = 7;
  v10 = v9[2];
  if ( v9[3] >= 0x10uLL )
    v9 = *v9;
  v11 = v8[2];
  if ( v8[3] >= 0x10uLL )
    v8 = *v8;
  v12 = v11;
  if ( v10 < v11 )
    v12 = v10;
  if ( !memcmp(v8, v9, v12) && v11 >= v10 && v11 <= v10 )
LABEL_18:
    v13 = 1;
  else
LABEL_17:
    v13 = 0;
  if ( (v4 & 4) != 0 )
  {
    v4 &= ~4u;
    if ( v22 >= 0x10 )
    {
      v14 = (v22 + 1);
      v15 = v21[0];
      if ( v22 + 1 >= 0x1000 )
      {
        v14 = (v22 + 40);
        v15 = *(v21[0] - 8LL);
        if ( (v21[0] - v15 - 8LL) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18000E0A0(v15, v14);
    }
    v21[2] = 0LL;
    v22 = 15LL;
    LOBYTE(v21[0]) = 0;
  }
  if ( (v4 & 2) != 0 )
  {
    v4 &= ~2u;
    if ( v24 >= 0x10 )
    {
      v16 = (v24 + 1);
      v17 = v23[0];
      if ( v24 + 1 >= 0x1000 )
      {
        v16 = (v24 + 40);
        v17 = *(v23[0] - 8LL);
        if ( (v23[0] - v17 - 8LL) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18000E0A0(v17, v16);
    }
    v23[2] = 0LL;
    v24 = 15LL;
    LOBYTE(v23[0]) = 0;
  }
  if ( (v4 & 1) != 0 && v26 >= 0x10 )
  {
    v18 = (v26 + 1);
    v19 = v25;
    if ( v26 + 1 >= 0x1000 )
    {
      v18 = (v26 + 40);
      v19 = *(v25 - 1);
      if ( (v25 - v19 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18000E0A0(v19, v18);
  }
  return v13;
}


// ===== 函数: sub_1800719D0 (0x1800719D0) =====
_OWORD *__fastcall sub_1800719D0(__int64 a1, _OWORD *a2)
{
  __int64 v2; // rcx
  char *v4; // rax
  size_t v5; // r8
  __int64 *v6; // rax
  int v7; // ecx
  int v8; // edi
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  ai *v11; // rcx
  void *v12; // rdx
  ai *v13; // rcx
  void *v14; // rdx
  __int64 v16[3]; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int64 v17; // [rsp+48h] [rbp-40h]
  _QWORD v18[3]; // [rsp+50h] [rbp-38h] BYREF
  unsigned __int64 v19; // [rsp+68h] [rbp-20h]

  v2 = *(a1 + 8);
  if ( v2 )
  {
    v4 = std::_Yarn<char>::c_str(v2 + 40);
    v5 = -1LL;
    v16[0] = 0LL;
    v16[2] = 0LL;
    v17 = 15LL;
    do
      ++v5;
    while ( v4[v5] );
    sub_180023710(v16, v4, v5);
    v6 = v16;
    v7 = 0;
    v8 = 1;
  }
  else
  {
    v18[0] = 0LL;
    v6 = v18;
    v18[2] = 0LL;
    v7 = 2;
    v19 = 15LL;
    v8 = 0;
  }
  v9 = *v6;
  v10 = *(v6 + 1);
  v6[2] = 0LL;
  *v6 = 0;
  v6[3] = 15LL;
  *a2 = v9;
  a2[1] = v10;
  if ( v7 && v19 >= 0x10 )
  {
    v11 = v18[0];
    v12 = (v19 + 1);
    if ( v19 + 1 >= 0x1000 )
    {
      v11 = *(v18[0] - 8LL);
      v12 = (v19 + 40);
      if ( (v18[0] - v11 - 8LL) > 0x1F )
LABEL_15:
        invalid_parameter_noinfo_noreturn();
    }
    sub_18000E0A0(v11, v12);
  }
  if ( v8 && v17 >= 0x10 )
  {
    v13 = v16[0];
    v14 = (v17 + 1);
    if ( v17 + 1 >= 0x1000 )
    {
      v13 = *(v16[0] - 8);
      v14 = (v17 + 40);
      if ( (v16[0] - v13 - 8) > 0x1F )
        goto LABEL_15;
    }
    sub_18000E0A0(v13, v14);
  }
  return a2;
}


// ===== 函数: sub_180023710 (0x180023710) =====
__int64 *__fastcall sub_180023710(__int64 *a1, char *Src, size_t Size)
{
  unsigned __int64 v3; // rbp
  char *v5; // r15
  void *v7; // rdi
  size_t v8; // rdi
  ai *v9; // rcx
  unsigned __int64 v10; // rax
  _QWORD *v11; // r14
  __int64 v12; // rcx

  v3 = a1[3];
  v5 = Src;
  if ( Size > v3 )
  {
    v8 = 0x7FFFFFFFFFFFFFFFLL;
    if ( Size > 0x7FFFFFFFFFFFFFFFLL )
      std::vector<void *>::_Xlen();
    if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL || (Src = (v3 >> 1), v3 > 0x7FFFFFFFFFFFFFFFLL - (v3 >> 1)) )
    {
      v9 = 0x8000000000000027LL;
    }
    else
    {
      v8 = Size | 0xF;
      if ( (Size | 0xF) < &Src[v3] )
        v8 = &Src[v3];
      if ( v8 + 1 < 0x1000 )
      {
        if ( v8 == -1LL )
          v11 = 0LL;
        else
          v11 = sub_180022FF0((v8 + 1), Src, Size);
        goto LABEL_19;
      }
      v9 = (v8 + 40);
      if ( v8 + 40 < v8 + 1 )
        Concurrency::cancel_current_task();
    }
    v10 = sub_180022FF0(v9, Src, Size);
    if ( !v10 )
      goto LABEL_26;
    v11 = ((v10 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v11 - 1) = v10;
LABEL_19:
    a1[2] = Size;
    a1[3] = v8;
    memcpy(v11, v5, Size);
    *(v11 + Size) = 0;
    if ( v3 < 0x10 )
    {
LABEL_24:
      *a1 = v11;
      return a1;
    }
    v12 = *a1;
    if ( v3 + 1 < 0x1000 )
    {
LABEL_23:
      sub_18000E0A0(v12);
      goto LABEL_24;
    }
    if ( (v12 - *(v12 - 8) - 8) <= 0x1F )
    {
      v12 = *(v12 - 8);
      goto LABEL_23;
    }
LABEL_26:
    invalid_parameter_noinfo_noreturn();
  }
  v7 = a1;
  if ( v3 >= 0x10 )
    v7 = *a1;
  a1[2] = Size;
  memmove(v7, Src, Size);
  *(v7 + Size) = 0;
  return a1;
}


// ===== 函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_1 (0x1800149A0) =====
void __noreturn std::vector<void *>::_Xlen()
{
  std::_Xlength_error("string too long");
}


// ===== 函数: memcmp (0x1800818A2) =====
// attributes: thunk
int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
{
  return __imp_memcmp(Buf1, Buf2, Size);
}


// ===== 函数: ?classic@locale@std@@SAAEBV12@XZ (0x180080672) =====
// attributes: thunk
const struct std::locale *std::locale::classic(void)
{
  return __imp_?classic@locale@std@@SAAEBV12@XZ();
}


// ===== 函数: ?_Init@locale@std@@CAPEAV_Locimp@12@_N@Z (0x180080678) =====
// attributes: thunk
struct std::locale::_Locimp *__fastcall std::locale::_Init(bool a1)
{
  return __imp_?_Init@locale@std@@CAPEAV_Locimp@12@_N@Z(a1);
}


// ===== 函数: sub_180070F60 (0x180070F60) =====
bool __fastcall sub_180070F60(__int64 a1)
{
  char v2; // al
  __int64 (__fastcall *v3)(__int64 *); // rdx
  int v4; // eax
  __int64 v5; // rcx
  unsigned int (__fastcall *v6)(__int64, __int64); // rbx
  __int64 v7; // rax
  __int64 v8; // rcx
  void (__fastcall *v9)(__int64, __int64, int *); // rbx
  __int64 v10; // rax
  bool v11; // bl
  __int64 v12; // rax
  __int64 v14; // rax
  ai *v15; // rcx
  struct ai::IFeatureManager *FeatureManager; // rax
  __int64 (__fastcall *v17)(struct ai::IFeatureManager *, _QWORD *); // r8
  char v18; // bl
  __int64 v19; // rcx
  __int64 v20; // [rsp+20h] [rbp-40h] BYREF
  int v21; // [rsp+28h] [rbp-38h] BYREF
  __int64 v22; // [rsp+30h] [rbp-30h]
  _QWORD v23[3]; // [rsp+38h] [rbp-28h] BYREF
  unsigned __int64 v24; // [rsp+50h] [rbp-10h]

  v22 = -2LL;
  if ( dword_1800F4F6C > *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4LL) )
  {
    Init_thread_header(&dword_1800F4F6C);
    if ( dword_1800F4F6C == -1 )
    {
      FeatureManager = ai::GetFeatureManager(v15);
      v17 = *(*FeatureManager + 8LL);
      v24 = 15LL;
      v23[2] = 15LL;
      strcpy(v23, "MTRasterization");
      v18 = v17(FeatureManager, v23);
      if ( v24 >= 0x10 )
      {
        v19 = v23[0];
        if ( v24 + 1 >= 0x1000 )
        {
          v19 = *(v23[0] - 8LL);
          if ( (v23[0] - v19 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18000E0A0(v19);
      }
      byte_1800F4F68 = v18;
      Init_thread_footer(&dword_1800F4F6C);
    }
  }
  v2 = byte_1800F4F68;
  if ( !byte_1800F4F68 )
    return 0;
  if ( gAIPreferenceUtilSuite )
  {
    v20 = 0x100000001LL;
    (*(gAIPreferenceUtilSuite + 488LL))(&v20);
    v2 = HIDWORD(v20) != 0;
  }
  if ( !v2 )
    return 0;
  v20 = 0LL;
  v3 = *(gAIDocumentSuite + 320);
  v20 = 0LL;
  v4 = v3(&v20);
  v5 = v20;
  if ( v4 || !v20 )
  {
    if ( v20 )
    {
      v14 = sub_18005C840(v20);
      (*(v14 + 8))(v20);
    }
  }
  else
  {
    v21 = 1;
    v6 = *(gAIDictionarySuite + 80);
    v7 = qword_1800F4F60;
    if ( !qword_1800F4F60 )
    {
      v7 = (*(gAIDictionarySuite + 64))("-EnableBGExport");
      qword_1800F4F60 = v7;
      v5 = v20;
    }
    if ( v6(v5, v7) )
    {
      v9 = *(gAIDictionarySuite + 208);
      v10 = qword_1800F4F60;
      if ( !qword_1800F4F60 )
      {
        v10 = (*(gAIDictionarySuite + 64))("-EnableBGExport");
        qword_1800F4F60 = v10;
      }
      v9(v20, v10, &v21);
    }
    v11 = v21 != 0;
    if ( v20 )
    {
      v12 = sub_18005C840(v8);
      (*(v12 + 8))(v20);
    }
    if ( !v11 )
      return 0;
  }
  return sub_180070390(a1) != 0;
}


// ===== 函数: sub_18005C840 (0x18005C840) =====
__int64 sub_18005C840()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  int v2; // eax
  _QWORD *v3; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v0 = sub_18005C8D0(&unk_1800F4D84);
  v1 = v0;
  if ( !*(v0 + 8) && qword_1800F45C0 )
  {
    v2 = (*qword_1800F45C0)(*(v0 + 16), *(v0 + 24), v0 + 8);
    if ( v2 )
    {
      sub_1800064A0(pExceptionObject, v2, 0LL);
      throw pExceptionObject;
    }
    if ( !*(v1 + 28) )
    {
      v3 = sub_180026160();
      *v1 = *v3;
      *v3 = v1;
    }
  }
  return *(v1 + 8);
}


// ===== 函数: sub_18005C8D0 (0x18005C8D0) =====
__int128 *sub_18005C8D0()
{
  _QWORD *v1; // rax

  if ( dword_1800F4DA8 <= *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4LL) )
    return &xmmword_1800F4D88;
  Init_thread_header(&dword_1800F4DA8);
  if ( dword_1800F4DA8 != -1 )
    return &xmmword_1800F4D88;
  xmmword_1800F4D88 = 0LL;
  qword_1800F4D98 = "AI Counted Object Suite";
  dword_1800F4DA0 = 3;
  byte_1800F4DA4 = 1;
  v1 = sub_180026160();
  *&xmmword_1800F4D88 = *v1;
  *v1 = &xmmword_1800F4D88;
  Init_thread_footer(&dword_1800F4DA8);
  return &xmmword_1800F4D88;
}


// ===== 函数: sub_180070390 (0x180070390) =====
bool __fastcall sub_180070390(__int64 a1)
{
  __int64 *v1; // r8
  __int64 *v2; // rdx
  __int64 *v3; // rax
  char v4; // r9
  __int64 *v5; // rcx
  __int64 *v6; // rdx
  __int64 *v7; // rcx
  __int64 *v8; // rdx
  __int64 *v9; // rcx
  __int64 *v10; // rdx
  __int64 *v11; // rcx
  __int64 *v12; // rdx
  __int64 *v13; // rcx
  __int64 *v14; // rcx

  v1 = *(a1 + 48);
  v2 = v1;
  v3 = v1[1];
  v4 = *(v3 + 25);
  if ( !v4 )
  {
    v5 = v1[1];
    do
    {
      if ( *(v5 + 32) >= 7u )
      {
        v2 = v5;
        v5 = *v5;
      }
      else
      {
        v5 = v5[2];
      }
    }
    while ( !*(v5 + 25) );
  }
  if ( !*(v2 + 25) && *(v2 + 32) <= 7u && v2 != v1 )
    return 0;
  v6 = v1;
  if ( !v4 )
  {
    v7 = v1[1];
    do
    {
      if ( *(v7 + 32) >= 6u )
      {
        v6 = v7;
        v7 = *v7;
      }
      else
      {
        v7 = v7[2];
      }
    }
    while ( !*(v7 + 25) );
  }
  if ( !*(v6 + 25) && *(v6 + 32) <= 6u && v6 != v1 )
    return 0;
  v8 = v1;
  if ( !v4 )
  {
    v9 = v1[1];
    do
    {
      if ( *(v9 + 32) >= 8u )
      {
        v8 = v9;
        v9 = *v9;
      }
      else
      {
        v9 = v9[2];
      }
    }
    while ( !*(v9 + 25) );
  }
  if ( !*(v8 + 25) && *(v8 + 32) <= 8u && v8 != v1 )
    return 0;
  v10 = v1;
  if ( !v4 )
  {
    v11 = v1[1];
    do
    {
      if ( *(v11 + 32) >= 9u )
      {
        v10 = v11;
        v11 = *v11;
      }
      else
      {
        v11 = v11[2];
      }
    }
    while ( !*(v11 + 25) );
  }
  if ( !*(v10 + 25) && *(v10 + 32) <= 9u && v10 != v1 )
    return 0;
  v12 = v1;
  if ( !v4 )
  {
    v13 = v1[1];
    do
    {
      if ( *(v13 + 32) >= 0xAu )
      {
        v12 = v13;
        v13 = *v13;
      }
      else
      {
        v13 = v13[2];
      }
    }
    while ( !*(v13 + 25) );
  }
  if ( !*(v12 + 25) && *(v12 + 32) <= 0xAu && v12 != v1 )
    return 0;
  v14 = v1;
  if ( !v4 )
  {
    do
    {
      if ( *(v3 + 32) >= 0xBu )
      {
        v14 = v3;
        v3 = *v3;
      }
      else
      {
        v3 = v3[2];
      }
    }
    while ( !*(v3 + 25) );
  }
  return *(v14 + 25) || *(v14 + 32) > 0xBu || v14 == v1;
}


// ===== 函数: sub_180068460 (0x180068460) =====
__int64 __fastcall sub_180068460(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v5; // eax
  __int64 i; // rdi
  __int64 v7; // rcx
  __int64 result; // rax

  v2 = a2[1];
  if ( *a2 != v2 )
  {
    v5 = ((v2 - *a2) >> 2) - 1;
    for ( i = v5; i >= 0; --i )
    {
      v7 = *a1 + 8LL * *(*a2 + 4 * i);
      memmove(v7, (v7 + 8), a1[1] - (v7 + 8));
      a1[1] -= 8LL;
    }
  }
  result = 0LL;
  if ( *a1 == a1[1] )
    return 1128353364LL;
  return result;
}


// ===== 函数: sub_18004EE60 (0x18004EE60) =====
__int64 __fastcall sub_18004EE60(__int64 a1, __int64 a2)
{
  unsigned int v3; // ebx
  __int64 v4; // rax
  __int64 (__fastcall *v5)(_QWORD, _QWORD *, _QWORD *, _BYTE *, _QWORD *, __int64); // rdi
  _QWORD *v6; // rbx
  _QWORD *v7; // rax
  _QWORD v9[6]; // [rsp+30h] [rbp-B8h] BYREF
  _QWORD v10[8]; // [rsp+60h] [rbp-88h] BYREF
  _BYTE v11[56]; // [rsp+A0h] [rbp-48h] BYREF
  __int64 v12; // [rsp+D8h] [rbp-10h]
  __int64 v13; // [rsp+100h] [rbp+18h] BYREF
  __int64 v14; // [rsp+108h] [rbp+20h] BYREF

  v9[1] = -2LL;
  v3 = 0;
  US_str_InitializeZString(&v13, "$$$/SmartExportUI/ExportString=^1");
  if ( !sub_180052D30(&v13, 0LL) )
  {
    v4 = sub_180052370(&unk_1800F4B6A);
    v5 = *(InitializeZString_fun_p(v4) + 8);
    v9[2] = v10;
    v10[0] = &std::_Func_impl_no_alloc<void (*)(AITask *),void,AITask *>::`vftable';
    v10[1] = sub_180052ED0;
    v10[7] = v10;
    v9[3] = v11;
    v12 = 0LL;
    v9[4] = &v14;
    v6 = US_str_InitializeZString(&v14, "$$$/SmartExportUI/BGExport/InitializeExportProgress=Exporting...");
    v7 = CopyUnicodeStr(v9, &v13);
    v3 = v5(*(gAISmartExportUI_app + 360), v7, v6, v11, v10, a2);
  }
  US_str_UnInitIializeZString(&v13);
  return v3;
}


// ===== 函数: sub_180052D30 (0x180052D30) =====
__int64 __fastcall sub_180052D30(__int64 a1, __int64 a2)
{
  int v4; // eax
  int v5; // eax
  _QWORD *v6; // rax
  __int64 result; // rax
  unsigned int v8; // [rsp+20h] [rbp-78h] BYREF
  __int64 v9; // [rsp+28h] [rbp-70h]
  const ai::Error *v10; // [rsp+30h] [rbp-68h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+38h] [rbp-60h] BYREF
  _BYTE v12[40]; // [rsp+60h] [rbp-38h] BYREF
  const std::exception *v13; // [rsp+88h] [rbp-10h] BYREF
  __int64 v14; // [rsp+B0h] [rbp+18h] BYREF
  __int64 v15; // [rsp+B8h] [rbp+20h] BYREF

  v9 = -2LL;
  unknown_libname_1(&v15);
  try
  {
    if ( a2 )
    {
      v5 = (*(gAIDocumentSuite + 656))(a2, &v15);
      if ( v5 )
      {
        sub_1800064A0(
          v12,
          v5,
          "AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\PlugInDev\\SmartExportUI\\Sou"
          "rce\\SmartExportUI.cpp line: 108 ");
        throw v12;
      }
    }
    else
    {
      v4 = (*(gAIDocumentSuite + 640))(&v15);
      if ( v4 )
      {
        sub_1800064A0(
          pExceptionObject,
          v4,
          "AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\PlugInDev\\SmartExportUI\\Sou"
          "rce\\SmartExportUI.cpp line: 108 ");
        throw pExceptionObject;
      }
    }
    v6 = CStr2AIUnicodeString(&v14, "^1");
    sub_180052C70(a1, v6, &v15);
    US_str_UnInitIializeZString(&v14);
    US_str_UnInitIializeZString(&v15);
    result = 0LL;
  }
  catch ( const ai::Error *v10 )
  {
    LODWORD(v14) = *(v10 + 6);
    US_str_UnInitIializeZString(&v15);
    return v14;
  }
  catch ( const std::exception *v13 )
  {
    US_str_UnInitIializeZString(&v15);
    return 1398031704LL;
  }
  catch ( int v8 )
  {
    US_str_UnInitIializeZString(&v15);
    return v8;
  }
  catch ( ... )
  {
    US_str_UnInitIializeZString(&v15);
    return 1431192920LL;
  }
  return result;
}


// ===== 函数: CStr2AIUnicodeString (0x18007B440) =====
// &v23, "Last Used Artboard Export Settings"
// sub_18007B440(&v25, "Last Used Asset Export Settings");
_QWORD *__fastcall sub_18007B440(_QWORD *a1, __int64 a2)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 (__fastcall **v5)(_QWORD *, __int64, __int64, __int64); // rax
  __int64 v6; // r8
  int v7; // eax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  *a1 = 0LL;
  if ( a2 )
  {
    AIUnicodeStringSuite = GetAIUnicodeStringSuite();
    v5 = InitializeZString_fun_p(AIUnicodeStringSuite);
    v6 = -1LL;
    do
      ++v6;
    while ( *(a2 + v6) );
    v7 = (*v5)(a1, a2, v6, 16LL);
    if ( v7 )
    {
      sub_1800064A0(pExceptionObject, v7, 0LL);
      throw pExceptionObject;
    }
  }
  return a1;
}


// ===== 函数: sub_180052C70 (0x180052C70) =====
__int64 __fastcall sub_180052C70(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v7; // rsi
  __int64 v8; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  if ( sub_18007B920(a3) || sub_18007B920(a2) || sub_18007B920(a1) )
  {
    sub_1800065A0(pExceptionObject, "Empty String in String Substitute function");
    throw pExceptionObject;
  }
  result = sub_18007BC90(a2);
  if ( result )
  {
    result = sub_18007B9E0(a1, a2, 0LL);
    v7 = result;
    if ( result != -1 )
    {
      v8 = sub_18007BC90(a2);
      return sub_180053DB0(a1, v7, v8, a3);
    }
  }
  return result;
}


// ===== 函数: sub_18007B920 (0x18007B920) =====
bool __fastcall sub_18007B920(__int64 a1)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v3; // rax

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v3 = InitializeZString_fun_p(AIUnicodeStringSuite);
  return (*(v3 + 136))(a1) != 0;
}


// ===== 函数: sub_18007B9E0 (0x18007B9E0) =====
__int64 __fastcall sub_18007B9E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v7; // rax

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v7 = InitializeZString_fun_p(AIUnicodeStringSuite);
  return (*(v7 + 160))(a1, a2, a3);
}


// ===== 函数: sub_18007BC90 (0x18007BC90) =====
__int64 __fastcall sub_18007BC90(__int64 a1)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v3; // rax

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v3 = InitializeZString_fun_p(AIUnicodeStringSuite);
  return (*(v3 + 128))(a1);
}


// ===== 函数: sub_180053DB0 (0x180053DB0) =====
__int64 __fastcall sub_180053DB0(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rax
  _QWORD v10[2]; // [rsp+20h] [rbp-78h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+30h] [rbp-68h] BYREF
  _BYTE v12[40]; // [rsp+58h] [rbp-40h] BYREF
  __int64 v13; // [rsp+A8h] [rbp+10h] BYREF

  v10[1] = -2LL;
  if ( a2 > sub_18007BC90(a1) )
  {
    sub_1800064A0(v12, 1431511369, 0LL);
    throw v12;
  }
  sub_18007BC90(a4);
  sub_18007B960(a1, a2, a3);
  if ( a2 > sub_18007BC90(a1) )
  {
    sub_1800064A0(pExceptionObject, 1431511369, 0LL);
    throw pExceptionObject;
  }
  sub_18007BC90(a4);
  sub_18007BCC0(a1, &v13, 0LL, a2);
  sub_18007B5F0(&v13, a4, 0LL, -1LL);
  v8 = sub_18007BCC0(a1, v10, a2, -1LL);
  sub_18007B580(&v13, v8);
  US_str_UnInitIializeZString(v10);
  sub_18007B0A0(a1, &v13);
  US_str_UnInitIializeZString(&v13);
  return a1;
}


// ===== 函数: sub_18007B960 (0x18007B960) =====
__int64 __fastcall sub_18007B960(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v7; // rax
  int v8; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v7 = InitializeZString_fun_p(AIUnicodeStringSuite);
  v8 = (*(v7 + 144))(a1, a2, a3);
  if ( v8 )
  {
    sub_1800064A0(pExceptionObject, v8, 0LL);
    throw pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_18007BCC0 (0x18007BCC0) =====
_QWORD *__fastcall sub_18007BCC0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v9; // rax
  int v10; // eax
  _BYTE pExceptionObject[48]; // [rsp+30h] [rbp-38h] BYREF

  *a2 = 0LL;
  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v9 = InitializeZString_fun_p(AIUnicodeStringSuite);
  v10 = (*(v9 + 264))(a2, a1, a3, a4, 1, -2LL);
  if ( v10 )
  {
    sub_1800064A0(pExceptionObject, v10, 0LL);
    throw pExceptionObject;
  }
  return a2;
}


// ===== 函数: sub_18007B5F0 (0x18007B5F0) =====
__int64 __fastcall sub_18007B5F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int128 *AIUnicodeStringSuite; // rax
  __int64 v9; // rax
  int v10; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  AIUnicodeStringSuite = GetAIUnicodeStringSuite();
  v9 = InitializeZString_fun_p(AIUnicodeStringSuite);
  v10 = (*(v9 + 40))(a1, a2, a3, a4);
  if ( v10 )
  {
    sub_1800064A0(pExceptionObject, v10, 0LL);
    throw pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_180052370 (0x180052370) =====
__int128 *sub_180052370()
{
  _QWORD *v1; // rax

  if ( dword_1800F24E8[0] <= *(*(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4LL) )
    return &xmmword_1800F24C8;
  Init_thread_header(dword_1800F24E8);
  if ( dword_1800F24E8[0] != -1 )
    return &xmmword_1800F24C8;
  xmmword_1800F24C8 = 0LL;
  qword_1800F24D8 = "AI TaskManager UI Suite";
  dword_1800F24E0 = 1;
  byte_1800F24E4 = 1;
  v1 = sub_180026160();
  *&xmmword_1800F24C8 = *v1;
  *v1 = &xmmword_1800F24C8;
  Init_thread_footer(dword_1800F24E8);
  return &xmmword_1800F24C8;
}


// ===== 函数: sub_180007460 (0x180007460) =====
__int64 __fastcall sub_180007460(__int64 *a1, __int64 a2, void **a3, unsigned __int8 a4)
{
  __int64 v8; // r15
  unsigned __int64 v9; // rsi
  __int64 v11; // rax

  v8 = *a1;
  if ( !*(a2 + 25) )
  {
    v9 = sub_180022FF0(0x28, a2, a3);
    sub_180077240((v9 + 32), a2 + 32);
    *v9 = v8;
    *(v9 + 16) = v8;
    *(v9 + 24) = 0;
    *(v9 + 8) = a3;
    *(v9 + 24) = *(a2 + 24);
    if ( *(v8 + 25) )
      v8 = v9;
    try
    {
      *v9 = sub_180007460(a1, *a2, v9, a4);
      *(v9 + 16) = sub_180007460(a1, *(a2 + 16), v9, a4);
    }
    catch ( ... )
    {
      v11 = sub_180008F70(a1);
      sub_180007C00(a1, v11, v8);
      throw;
    }
  }
  return v8;
}


// ===== 函数: sub_1800517E0 (0x1800517E0) =====
void __fastcall sub_1800517E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 ***a5, _QWORD *a6)
{
  int v8; // eax
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rbx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 *v18; // rbx
  __int64 v19; // rbp
  __int64 v20; // rdi
  _QWORD *v21; // rax
  __int64 **v22; // rax
  __int64 *i; // rax
  __int64 *j; // rcx
  __int128 *v25; // rax
  __int64 v26; // rax
  __int64 v27; // rcx
  __int64 v28; // [rsp+20h] [rbp-98h] BYREF
  __int64 v29; // [rsp+28h] [rbp-90h] BYREF
  _BYTE v30[16]; // [rsp+30h] [rbp-88h] BYREF
  __int64 v31; // [rsp+40h] [rbp-78h]
  _BYTE pExceptionObject[48]; // [rsp+48h] [rbp-70h] BYREF
  __int64 v33; // [rsp+78h] [rbp-40h]

  v31 = -2LL;
  v28 = a3;
  v33 = a4;
  if ( !a2 )
  {
    v29 = 0LL;
    v8 = (*(gAIDocumentSuite + 160))(&v29);
    if ( v8 )
    {
      sub_1800064A0(
        pExceptionObject,
        v8,
        "AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\PlugInDev\\SmartExportUI\\Sourc"
        "e\\SmartExportUI.cpp line: 852 ");
      throw pExceptionObject;
    }
    if ( !v29 )
    {
      sub_1800065A0(pExceptionObject, "No document");
      throw pExceptionObject;
    }
    *(*sub_18004CEF0(gAISmartExportUI_app + 432, v30, &v29) + 24LL) = v28;
    v9 = sub_18004C8D0(a1 + 624, v30, &v28);
    v10 = *(*v9 + 24LL);
    *(*v9 + 24LL) = *a6;
    *a6 = v10;
    v11 = sub_18004C5C0(a1 + 688, v30, &v28);
    v13 = *v11 + 24LL;
    if ( v13 == a4 )
      goto LABEL_13;
    v14 = *(*v11 + 80LL);
    if ( v14 )
    {
      LOBYTE(v12) = v14 != v13;
      (*(*v14 + 32LL))(v14, v12);
      *(v13 + 56) = 0LL;
    }
    v15 = *(a4 + 56);
    if ( !v15 )
      goto LABEL_13;
    if ( v15 == a4 )
    {
      *(v13 + 56) = (*(*v15 + 8LL))(v15, v13);
      v17 = *(a4 + 56);
      if ( !v17 )
      {
LABEL_13:
        v18 = **a5;
        if ( !*(v18 + 25) )
        {
          v19 = a1 + 752;
          do
          {
            v20 = v28;
            v21 = sub_180077AC0((v18 + 4), &v29, 0);
            *(*sub_18004D200(v19, v30, v21) + 24LL) = v20;
            US_str_UnInitIializeZString(&v29);
            v22 = v18[2];
            if ( *(v22 + 25) )
            {
              for ( i = v18[1]; !*(i + 25); i = i[1] )
              {
                if ( v18 != i[2] )
                  break;
                v18 = i;
              }
              v18 = i;
            }
            else
            {
              v18 = v18[2];
              for ( j = *v22; !*(j + 25); j = *j )
                v18 = j;
            }
          }
          while ( !*(v18 + 25) );
        }
        sub_1800250C0();
        goto LABEL_26;
      }
      LOBYTE(v16) = v17 != a4;
      (*(*v17 + 32LL))(v17, v16);
    }
    else
    {
      *(v13 + 56) = v15;
    }
    *(a4 + 56) = 0LL;
    goto LABEL_13;
  }
  if ( a2 != 2050 )
  {
    v25 = sub_180052370();
    v26 = InitializeZString_fun_p(v25);
    (*(v26 + 32))(v28);
  }
LABEL_26:
  v27 = *(a4 + 56);
  if ( v27 )
  {
    LOBYTE(a2) = v27 != a4;
    (*(*v27 + 32LL))(v27, a2);
    *(a4 + 56) = 0LL;
  }
}


// ===== 函数: sub_18004D200 (0x18004D200) =====
__int64 __fastcall sub_18004D200(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  unsigned __int64 v6; // rax
  __int64 v7; // rdx
  void **v8; // r8
  __int64 v9; // rbp
  unsigned __int64 v10; // r9
  __int64 v11; // rsi
  __int64 v12; // rax
  _QWORD *v13; // rbx
  _QWORD *v14; // r12
  _QWORD *v15; // r14
  _QWORD *v16; // rsi
  _QWORD *v18; // rsi
  _QWORD *v19; // r8
  float v20; // xmm3_4
  __int64 v21; // rcx
  float v22; // xmm0_4
  unsigned __int64 v23; // rdi
  float v24; // xmm2_4
  __int64 v25; // rcx
  float v26; // xmm0_4
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rcx
  __int64 v30; // rax
  _QWORD *v31; // rdi
  _QWORD *v32; // r14
  _QWORD *v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // rax
  _QWORD *v36; // r8
  _QWORD *v37; // [rsp+30h] [rbp-48h]
  void **v39; // [rsp+90h] [rbp+18h] BYREF
  _QWORD *v40; // [rsp+98h] [rbp+20h]

  v6 = USS_UTF_16_str_buffer(a3, &v39);
  v9 = 0LL;
  v10 = 0LL;
  if ( v6 )
  {
    v8 = v39;
    do
    {
      v7 = *(v39 + v10);
      v9 = v7 + 33 * v9;
      ++v10;
    }
    while ( v10 < v6 );
  }
  v11 = 2 * (v9 & a1[6]);
  v12 = a1[3];
  v13 = *(v12 + 16 * (v9 & a1[6]) + 8);
  v40 = a1 + 1;
  v14 = a1[1];
  if ( v13 == v14 )
  {
    v13 = a1[1];
    v15 = v13;
    goto LABEL_12;
  }
  v16 = *(v12 + 8 * v11);
  if ( sub_18007B870(a3, (v13 + 2)) )
  {
    while ( v13 != v16 )
    {
      v13 = v13[1];
      if ( !sub_18007B870(a3, (v13 + 2)) )
        goto LABEL_9;
    }
    v14 = v13;
    v15 = v13;
LABEL_12:
    if ( a1[2] == 0x7FFFFFFFFFFFFFFLL )
      std::_Xlength_error("unordered_map/set too long");
    v18 = sub_180022FF0(0x20, v7, v8);
    v18[2] = *a3;
    *a3 = 0LL;
    v18[3] = 0LL;
    v19 = a1;
    v20 = *a1;
    v21 = a1[2] + 1LL;
    if ( v21 < 0 )
      v22 = (v21 & 1 | (v21 >> 1)) + (v21 & 1 | (v21 >> 1));
    else
      v22 = v21;
    v23 = a1[7];
    if ( (v23 & 0x8000000000000000uLL) != 0LL )
    {
      v25 = a1[7] & 1LL | (v23 >> 1);
      v24 = v25 + v25;
    }
    else
    {
      v24 = v23;
    }
    if ( (v22 / v24) <= v20 )
    {
LABEL_36:
      v33 = v13[1];
      ++v19[2];
      *v18 = v14;
      v18[1] = v33;
      *v33 = v18;
      v13[1] = v18;
      v34 = v19[3];
      v35 = 2 * (v9 & v19[6]);
      v36 = *(v34 + 16 * (v9 & v19[6]));
      if ( v36 == *v40 )
      {
        *(v34 + 8 * v35) = v18;
LABEL_42:
        *(v34 + 8 * v35 + 8) = v18;
        goto LABEL_43;
      }
      if ( v36 == v15 )
      {
        *(v34 + 8 * v35) = v18;
      }
      else if ( *(v34 + 8 * v35 + 8) == v33 )
      {
        goto LABEL_42;
      }
LABEL_43:
      *a2 = v18;
      *(a2 + 8) = 1;
      return a2;
    }
    v26 = ceilf(v22 / v20);
    v27 = 0LL;
    if ( v26 >= 9.223372e18 )
    {
      v26 = v26 - 9.223372e18;
      if ( v26 < 9.223372e18 )
        v27 = 0x8000000000000000uLL;
    }
    v28 = v27 + v26;
    v29 = 8LL;
    if ( v28 > 8 )
      v29 = v28;
    if ( v23 < v29 )
    {
      if ( v23 >= 0x200 || (v23 *= 8LL, v23 < v29) )
        v23 = v29;
    }
    sub_1800537A0(a1, v23);
    v19 = a1;
    v30 = a1[3];
    v31 = *(v30 + 16 * (v9 & a1[6]) + 8);
    v13 = a1[1];
    if ( v31 != v13 )
    {
      v32 = *(v30 + 16 * (v9 & a1[6]));
      if ( sub_18007B870((v18 + 2), (v31 + 2)) )
      {
        while ( 1 )
        {
          v13 = v31;
          if ( v31 == v32 )
            break;
          v31 = v31[1];
          if ( !sub_18007B870((v18 + 2), (v31 + 2)) )
            goto LABEL_33;
        }
        v37 = v31;
        v19 = a1;
        goto LABEL_35;
      }
LABEL_33:
      v13 = *v31;
      v19 = a1;
    }
    v37 = v13;
LABEL_35:
    v15 = v13;
    v14 = v37;
    goto LABEL_36;
  }
LABEL_9:
  *a2 = v13;
  *(a2 + 8) = 0;
  return a2;
}


// ===== 函数: sub_1800537A0 (0x1800537A0) =====
_QWORD *__fastcall sub_1800537A0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rcx
  __int64 v5; // rbx
  _QWORD *v6; // rbp
  _QWORD *v7; // r14
  _QWORD *result; // rax
  _QWORD *v9; // rdi
  _QWORD *i; // rsi
  __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  _QWORD *v13; // r14
  _QWORD *v14; // rbx
  __int64 v15; // r8
  _QWORD *v16; // rdx
  _QWORD *v17; // rcx
  _QWORD *v18; // r15
  _QWORD *v19; // rdx
  _QWORD *v20; // rcx
  __int64 v21; // r8
  _QWORD *v22; // rdx
  _QWORD *v23; // rcx
  __int64 v24; // [rsp+78h] [rbp+10h] BYREF
  _QWORD *v25; // [rsp+80h] [rbp+18h]

  _BitScanReverse64(&v3, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v3 )
    std::_Xlength_error("invalid hash bucket count");
  _BitScanReverse64(&v4, (a2 - 1) | 1);
  v5 = 1LL << (v4 + 1);
  v6 = a1[1];
  v7 = a1 + 3;
  sub_180052F50(a1 + 3, 2 * v5, v6);
  result = (v5 - 1);
  a1[6] = v5 - 1;
  a1[7] = v5;
  v25 = a1;
  v9 = *a1[1];
  for ( i = v9; i != v6; v7 = a1 + 3 )
  {
    i = *i;
    result = USS_UTF_16_str_buffer((v9 + 2), &v24);
    v11 = 0LL;
    v12 = 0LL;
    if ( result )
    {
      do
        v11 = *(v24 + 2 * v12++) + 33 * v11;
      while ( v12 < result );
    }
    v13 = (16 * (v11 & a1[6]) + *v7);
    if ( *v13 == v6 )
    {
      *v13 = v9;
      v13[1] = v9;
    }
    else
    {
      v14 = v13[1];
      result = sub_18007B870((v9 + 2), (v14 + 2));
      if ( result )
      {
        v18 = v14;
        if ( *v13 == v14 )
        {
LABEL_14:
          v19 = v9[1];
          *v19 = i;
          v20 = i[1];
          *v20 = v18;
          result = v18[1];
          *result = v9;
          v18[1] = v20;
          i[1] = v19;
          v9[1] = result;
          *v13 = v9;
        }
        else
        {
          while ( 1 )
          {
            v14 = v14[1];
            v18 = v14;
            if ( !sub_18007B870((v9 + 2), (v14 + 2)) )
              break;
            if ( *v13 == v14 )
              goto LABEL_14;
          }
          v21 = *v14;
          v22 = v9[1];
          *v22 = i;
          v23 = i[1];
          *v23 = v21;
          result = *(v21 + 8);
          *result = v9;
          *(v21 + 8) = v23;
          i[1] = v22;
          v9[1] = result;
        }
      }
      else
      {
        v15 = *v14;
        if ( *v14 != v9 )
        {
          v16 = v9[1];
          *v16 = i;
          v17 = i[1];
          *v17 = v15;
          result = *(v15 + 8);
          *result = v9;
          *(v15 + 8) = v17;
          i[1] = v16;
          v9[1] = result;
        }
        v13[1] = v9;
      }
    }
    v9 = i;
  }
  return result;
}


// ===== 函数: sub_18004C5C0 (0x18004C5C0) =====
__int64 __fastcall sub_18004C5C0(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // r13
  __int64 v7; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rbx
  _QWORD *v10; // r12
  _QWORD *v11; // r15
  _QWORD *v12; // rcx
  _QWORD *v14; // rdi
  float v15; // xmm3_4
  __int64 v16; // rcx
  float v17; // xmm0_4
  unsigned __int64 v18; // rsi
  float v19; // xmm2_4
  __int64 v20; // rcx
  float v21; // xmm0_4
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  _QWORD *v26; // rax
  _QWORD *v27; // rdx
  __int64 v28; // rcx
  _QWORD *v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // rax
  _QWORD *v32; // r8
  _QWORD *v33; // [rsp+30h] [rbp-38h]

  v6 = 0x100000001B3LL
     * (a3[7] ^ (0x100000001B3LL
               * (a3[6] ^ (0x100000001B3LL
                         * (a3[5] ^ (0x100000001B3LL
                                   * (a3[4] ^ (0x100000001B3LL
                                             * (a3[3] ^ (0x100000001B3LL
                                                       * (a3[2] ^ (0x100000001B3LL
                                                                 * (a3[1] ^ (0x100000001B3LL
                                                                           * (*a3 ^ 0xCBF29CE484222325uLL)))))))))))))));
  v7 = 2 * (v6 & *(a1 + 48));
  v8 = *(a1 + 24);
  v9 = *(v8 + 8 * v7 + 8);
  v10 = *(a1 + 8);
  if ( v9 == v10 )
  {
    v9 = *(a1 + 8);
    v11 = v9;
    goto LABEL_9;
  }
  v12 = *(v8 + 8 * v7);
  if ( *a3 != v9[2] )
  {
    while ( v9 != v12 )
    {
      v9 = v9[1];
      if ( *a3 == v9[2] )
        goto LABEL_6;
    }
    v10 = v9;
    v11 = v9;
LABEL_9:
    if ( *(a1 + 16) == 0x2E8BA2E8BA2E8BALL )
      std::_Xlength_error("unordered_map/set too long");
    v14 = sub_180022FF0(0x58, a1 + 8, a3);
    v14[2] = *a3;
    v14[10] = 0LL;
    v15 = *a1;
    v16 = *(a1 + 16) + 1LL;
    if ( v16 < 0 )
      v17 = (v16 & 1 | (v16 >> 1)) + (v16 & 1 | (v16 >> 1));
    else
      v17 = v16;
    v18 = *(a1 + 56);
    if ( (v18 & 0x8000000000000000uLL) != 0LL )
    {
      v20 = *(a1 + 56) & 1LL | (v18 >> 1);
      v19 = v20 + v20;
    }
    else
    {
      v19 = v18;
    }
    if ( (v17 / v19) <= v15 )
    {
LABEL_33:
      v29 = v9[1];
      ++*(a1 + 16);
      *v14 = v10;
      v14[1] = v29;
      *v29 = v14;
      v9[1] = v14;
      v30 = *(a1 + 24);
      v31 = 2 * (v6 & *(a1 + 48));
      v32 = *(v30 + 16 * (v6 & *(a1 + 48)));
      if ( v32 == *(a1 + 8) )
      {
        *(v30 + 16 * (v6 & *(a1 + 48))) = v14;
LABEL_39:
        *(v30 + 8 * v31 + 8) = v14;
        goto LABEL_40;
      }
      if ( v32 == v11 )
      {
        *(v30 + 16 * (v6 & *(a1 + 48))) = v14;
      }
      else if ( *(v30 + 16 * (v6 & *(a1 + 48)) + 8) == v29 )
      {
        goto LABEL_39;
      }
LABEL_40:
      *a2 = v14;
      *(a2 + 8) = 1;
      return a2;
    }
    v21 = ceilf(v17 / v15);
    v22 = 0LL;
    if ( v21 >= 9.223372e18 )
    {
      v21 = v21 - 9.223372e18;
      if ( v21 < 9.223372e18 )
        v22 = 0x8000000000000000uLL;
    }
    v23 = v22 + v21;
    v24 = 8LL;
    if ( v23 > 8 )
      v24 = v23;
    if ( v18 < v24 )
    {
      if ( v18 >= 0x200 || (v18 *= 8LL, v18 < v24) )
        v18 = v24;
    }
    sub_1800533C0(a1, v18);
    v25 = *(a1 + 24);
    v26 = *(v25 + 16 * (v6 & *(a1 + 48)) + 8);
    v9 = *(a1 + 8);
    if ( v26 != v9 )
    {
      v27 = *(v25 + 16 * (v6 & *(a1 + 48)));
      v28 = v14[2];
      if ( v28 != v26[2] )
      {
        while ( 1 )
        {
          v9 = v26;
          if ( v26 == v27 )
            break;
          v26 = v26[1];
          if ( v28 == v26[2] )
            goto LABEL_30;
        }
        v33 = v26;
        goto LABEL_32;
      }
LABEL_30:
      v9 = *v26;
    }
    v33 = v9;
LABEL_32:
    v11 = v9;
    v10 = v33;
    goto LABEL_33;
  }
LABEL_6:
  *a2 = v9;
  *(a2 + 8) = 0;
  return a2;
}


// ===== 函数: sub_1800533C0 (0x1800533C0) =====
_QWORD *__fastcall sub_1800533C0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rcx
  _QWORD *v4; // rbx
  unsigned __int64 v5; // rcx
  __int64 v6; // rdi
  _QWORD *result; // rax
  _QWORD *i; // rcx
  _QWORD *v9; // r11
  _QWORD *v10; // r9
  _QWORD *v11; // rdx
  __int64 v12; // r8
  _QWORD *v13; // r10
  _QWORD *v14; // r9
  _QWORD *v15; // r8
  _QWORD *v16; // rdx
  _QWORD *v17; // r10
  _QWORD *v18; // r9
  _QWORD *v19; // r8
  _QWORD *v20; // r10
  _QWORD *v21; // r9
  _QWORD *v22; // r8
  _QWORD *v23; // rdx

  _BitScanReverse64(&v3, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v3 )
    std::_Xlength_error("invalid hash bucket count");
  v4 = a1[1];
  _BitScanReverse64(&v5, (a2 - 1) | 1);
  v6 = 1LL << (v5 + 1);
  sub_180052F50(a1 + 3, 2 * v6, v4);
  a1[7] = v6;
  a1[6] = v6 - 1;
  result = *a1[1];
  for ( i = result; i != v4; result = i )
  {
    i = *i;
    v9 = (a1[3]
        + 16
        * (a1[6] & (0x100000001B3LL
                  * (*(result + 23) ^ (0x100000001B3LL
                                     * (*(result + 22) ^ (0x100000001B3LL
                                                        * (*(result + 21) ^ (0x100000001B3LL
                                                                           * (*(result + 20) ^ (0x100000001B3LL
                                                                                              * (*(result + 19) ^ (0x100000001B3LL * (*(result + 18) ^ (0x100000001B3LL * (*(result + 17) ^ (0x100000001B3LL * (*(result + 16) ^ 0xCBF29CE484222325uLL))))))))))))))))));
    v10 = *v9;
    if ( *v9 == v4 )
    {
      *v9 = result;
      v9[1] = result;
    }
    else
    {
      v11 = v9[1];
      v12 = result[2];
      if ( v12 == v11[2] )
      {
        v13 = *v11;
        if ( *v11 != result )
        {
          v14 = result[1];
          *v14 = i;
          v15 = i[1];
          *v15 = v13;
          v16 = v13[1];
          *v16 = result;
          v13[1] = v15;
          i[1] = v14;
          result[1] = v16;
        }
        v9[1] = result;
      }
      else if ( v10 == v11 )
      {
LABEL_12:
        v17 = result[1];
        *v17 = i;
        v18 = i[1];
        *v18 = v11;
        v19 = v11[1];
        *v19 = result;
        v11[1] = v18;
        i[1] = v17;
        result[1] = v19;
        *v9 = result;
      }
      else
      {
        while ( 1 )
        {
          v11 = v11[1];
          if ( v12 == v11[2] )
            break;
          if ( v10 == v11 )
            goto LABEL_12;
        }
        v20 = *v11;
        v21 = result[1];
        *v21 = i;
        v22 = i[1];
        *v22 = v20;
        v23 = v20[1];
        *v23 = result;
        v20[1] = v22;
        i[1] = v21;
        result[1] = v23;
      }
    }
  }
  return result;
}


// ===== 函数: sub_1800250C0 (0x1800250C0) =====
__int64 sub_1800250C0()
{
  __int64 result; // rax

  result = gAIAdobePIPSuite;
  if ( gAIAdobePIPSuite )
    return (*gAIAdobePIPSuite)("BackgroundExport", "BackgroundExportTriggered", "BackgroundExportTriggered");
  return result;
}


// ===== 函数: sub_18004C8D0 (0x18004C8D0) =====
__int64 __fastcall sub_18004C8D0(float *a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // r13
  __int64 v7; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rbx
  _QWORD *v10; // r12
  _QWORD *v11; // r15
  _QWORD *v12; // rcx
  _QWORD *v14; // rdi
  float v15; // xmm3_4
  __int64 v16; // rcx
  float v17; // xmm0_4
  unsigned __int64 v18; // rsi
  float v19; // xmm2_4
  __int64 v20; // rcx
  float v21; // xmm0_4
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  _QWORD *v26; // rax
  _QWORD *v27; // rdx
  __int64 v28; // rcx
  _QWORD *v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // rax
  _QWORD *v32; // r8
  _QWORD *v33; // [rsp+30h] [rbp-38h]

  v6 = 0x100000001B3LL
     * (a3[7] ^ (0x100000001B3LL
               * (a3[6] ^ (0x100000001B3LL
                         * (a3[5] ^ (0x100000001B3LL
                                   * (a3[4] ^ (0x100000001B3LL
                                             * (a3[3] ^ (0x100000001B3LL
                                                       * (a3[2] ^ (0x100000001B3LL
                                                                 * (a3[1] ^ (0x100000001B3LL
                                                                           * (*a3 ^ 0xCBF29CE484222325uLL)))))))))))))));
  v7 = 2 * (v6 & *(a1 + 6));
  v8 = *(a1 + 3);
  v9 = *(v8 + 8 * v7 + 8);
  v10 = *(a1 + 1);
  if ( v9 == v10 )
  {
    v9 = *(a1 + 1);
    v11 = v9;
    goto LABEL_9;
  }
  v12 = *(v8 + 8 * v7);
  if ( *a3 != v9[2] )
  {
    while ( v9 != v12 )
    {
      v9 = v9[1];
      if ( *a3 == v9[2] )
        goto LABEL_6;
    }
    v10 = v9;
    v11 = v9;
LABEL_9:
    if ( *(a1 + 2) == 0x7FFFFFFFFFFFFFFLL )
      std::_Xlength_error("unordered_map/set too long");
    v14 = sub_180022FF0(0x20, (a1 + 2), a3);
    v14[2] = *a3;
    unknown_libname_1(v14 + 3);
    v15 = *a1;
    v16 = *(a1 + 2) + 1LL;
    if ( v16 < 0 )
      v17 = (v16 & 1 | (v16 >> 1)) + (v16 & 1 | (v16 >> 1));
    else
      v17 = v16;
    v18 = *(a1 + 7);
    if ( (v18 & 0x8000000000000000uLL) != 0LL )
    {
      v20 = *(a1 + 7) & 1LL | (v18 >> 1);
      v19 = v20 + v20;
    }
    else
    {
      v19 = v18;
    }
    if ( (v17 / v19) <= v15 )
    {
LABEL_33:
      v29 = v9[1];
      ++*(a1 + 2);
      *v14 = v10;
      v14[1] = v29;
      *v29 = v14;
      v9[1] = v14;
      v30 = *(a1 + 3);
      v31 = 2 * (v6 & *(a1 + 6));
      v32 = *(v30 + 16 * (v6 & *(a1 + 6)));
      if ( v32 == *(a1 + 1) )
      {
        *(v30 + 16 * (v6 & *(a1 + 6))) = v14;
LABEL_39:
        *(v30 + 8 * v31 + 8) = v14;
        goto LABEL_40;
      }
      if ( v32 == v11 )
      {
        *(v30 + 16 * (v6 & *(a1 + 6))) = v14;
      }
      else if ( *(v30 + 16 * (v6 & *(a1 + 6)) + 8) == v29 )
      {
        goto LABEL_39;
      }
LABEL_40:
      *a2 = v14;
      *(a2 + 8) = 1;
      return a2;
    }
    v21 = ceilf(v17 / v15);
    v22 = 0LL;
    if ( v21 >= 9.223372e18 )
    {
      v21 = v21 - 9.223372e18;
      if ( v21 < 9.223372e18 )
        v22 = 0x8000000000000000uLL;
    }
    v23 = v22 + v21;
    v24 = 8LL;
    if ( v23 > 8 )
      v24 = v23;
    if ( v18 < v24 )
    {
      if ( v18 >= 0x200 || (v18 *= 8LL, v18 < v24) )
        v18 = v24;
    }
    sub_1800535B0(a1, v18);
    v25 = *(a1 + 3);
    v26 = *(v25 + 16 * (v6 & *(a1 + 6)) + 8);
    v9 = *(a1 + 1);
    if ( v26 != v9 )
    {
      v27 = *(v25 + 16 * (v6 & *(a1 + 6)));
      v28 = v14[2];
      if ( v28 != v26[2] )
      {
        while ( 1 )
        {
          v9 = v26;
          if ( v26 == v27 )
            break;
          v26 = v26[1];
          if ( v28 == v26[2] )
            goto LABEL_30;
        }
        v33 = v26;
        goto LABEL_32;
      }
LABEL_30:
      v9 = *v26;
    }
    v33 = v9;
LABEL_32:
    v11 = v9;
    v10 = v33;
    goto LABEL_33;
  }
LABEL_6:
  *a2 = v9;
  *(a2 + 8) = 0;
  return a2;
}


// ===== 函数: sub_180075970 (0x180075970) =====
__int64 __fastcall sub_180075970(__int64 a1)
{
  return *(a1 + 32);
}


// ===== 函数: sub_1800077F0 (0x1800077F0) =====
_QWORD *__fastcall sub_1800077F0(__int64 *a1, _BYTE *a2, _QWORD *a3)
{
  __int64 v5; // r15
  __int64 v6; // rax
  unsigned __int64 v7; // r13
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // rax
  _QWORD *v13; // rbx
  _QWORD *v14; // rsi
  _BYTE *v15; // r8
  _BYTE *v16; // rdx
  void *v17; // rcx
  size_t v18; // r8
  __int64 v19; // rcx
  unsigned __int64 v22; // [rsp+78h] [rbp+10h]
  _QWORD *v24; // [rsp+88h] [rbp+20h]

  v5 = &a2[-*a1] >> 3;
  v6 = (a1[1] - *a1) >> 3;
  if ( v6 == 0x1FFFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen();
  v7 = v6 + 1;
  v8 = (a1[2] - *a1) >> 3;
  v9 = v8 >> 1;
  if ( v8 > 0x1FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_25;
  v10 = v6 + 1;
  if ( v9 + v8 >= v7 )
    v10 = v9 + v8;
  if ( v10 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_25;
  v11 = 8 * v10;
  v22 = v10;
  if ( 8 * v10 >= 0x1000 )
  {
    if ( v11 + 39 >= v11 )
    {
      v12 = sub_180022FF0((v11 + 39), v9, 0x1FFFFFFFFFFFFFFFLL);
      if ( !v12 )
        goto LABEL_24;
      v13 = ((v12 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v13 - 1) = v12;
      goto LABEL_13;
    }
LABEL_25:
    Concurrency::cancel_current_task();
  }
  if ( v11 )
  {
    v13 = sub_180022FF0((8 * v10), v9, 0x1FFFFFFFFFFFFFFFLL);
    v24 = v13;
    v22 = v10;
    goto LABEL_28;
  }
  v13 = 0LL;
  v22 = v10;
LABEL_13:
  v24 = v13;
LABEL_28:
  try
  {
    v14 = &v13[v5];
    *v14 = *a3;
    v15 = a1[1];
    v16 = *a1;
    v17 = v13;
    if ( a2 == v15 )
    {
      v18 = v15 - v16;
    }
    else
    {
      memmove(v13, v16, a2 - v16);
      v17 = v14 + 1;
      v18 = a1[1] - a2;
      v16 = a2;
    }
    memmove(v17, v16, v18);
  }
  catch ( ... )
  {
    sub_180009A40(a1, v24, v22);
    throw;
  }
  v19 = *a1;
  if ( *a1 )
  {
    if ( ((a1[2] - v19) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_22:
      sub_18000E0A0(v19);
      goto LABEL_23;
    }
    if ( (v19 - *(v19 - 8) - 8) <= 0x1F )
    {
      v19 = *(v19 - 8);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  *a1 = v13;
  a1[1] = &v13[v7];
  a1[2] = &v13[v11 / 8];
  return v14;
}


// ===== 函数: GetAssetSelectionPath22 (0x18007C470) =====
_QWORD *__fastcall GetAssetSelectionPath22(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rcx

  unknown_libname_1(a2);
  //     /*18*/ AIErr(*GetAssetSelectionPath)(AssetID assetId, char* pathBuffer, size_t bufferSize); // 【资源管理】获取资源的层级路径（如"文档1/图层2/组1"，描述资源在文档中的位置）
  (*(gAISmartExportSuite + 144LL))(v3, a2);
  return a2;
}


// ===== 函数: sub_180007D70 (0x180007D70) =====
__int64 __fastcall sub_180007D70(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v7; // rax
  void ***v8; // rcx
  _BYTE *v9; // r8
  void ***v10; // rdx
  __int64 v11; // r9
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // r8
  __int64 v15; // rax
  _BYTE *v16; // rcx
  _BYTE *v17; // rdx
  void ***v18; // rdx
  __int64 v19; // rdi
  __int64 v20; // rax
  __int64 v21; // rdx
  void ***v22; // rcx
  _BYTE *v23; // r8
  void ***v24; // rdx
  __int64 v25; // r9
  __int64 v26; // rax
  __int64 v27; // r8
  __int64 v28; // rax
  _BYTE *v29; // rcx
  _BYTE *v30; // rdx
  char v32; // [rsp+20h] [rbp-79h]
  char v33; // [rsp+30h] [rbp-69h]
  char v34; // [rsp+31h] [rbp-68h]
  char v35; // [rsp+32h] [rbp-67h]
  char v36; // [rsp+33h] [rbp-66h]
  char v37; // [rsp+34h] [rbp-65h]
  void **v38; // [rsp+50h] [rbp-49h] BYREF
  __int64 v39; // [rsp+58h] [rbp-41h]
  char v40; // [rsp+60h] [rbp-39h]
  char v41; // [rsp+61h] [rbp-38h]
  char v42; // [rsp+62h] [rbp-37h]
  char v43; // [rsp+63h] [rbp-36h]
  char v44; // [rsp+64h] [rbp-35h]
  __int64 v45; // [rsp+68h] [rbp-31h]
  void ***v46; // [rsp+88h] [rbp-11h]
  _BYTE v47[56]; // [rsp+90h] [rbp-9h] BYREF
  _BYTE *v48; // [rsp+C8h] [rbp+2Fh]

  v38 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (*&)(AITask *,_t_AIDocument *,unsigned int,unsigned int,ai::UnicodeString),AITask * &,std::_Ph<1> const &,std::_Ph<2> const &,std::_Ph<3> const &,std::_Ph<4> const &>,void,_t_AIDocument *,unsigned int,unsigned int,ai::UnicodeString>::`vftable';
  v40 = v32;
  v41 = v32;
  v42 = v32;
  *(a1 + 56) = 0LL;
  v43 = v32;
  *(a1 + 120) = 0LL;
  v46 = &v38;
  v39 = a2;
  v45 = a4;
  v48 = 0LL;
  v7 = sub_180009660(&v38, v47);
  v8 = v46;
  v9 = v7;
  v48 = v7;
  if ( v46 )
  {
    v10 = &v38;
    LOBYTE(v10) = v46 != &v38;
    ((*v46)[4])(v46, v10, v7);
    v9 = v48;
    v8 = 0LL;
    v46 = 0LL;
  }
  v11 = *(a1 + 56);
  if ( v11 )
  {
    v8 = *(a1 + 56);
    if ( v11 == a1 )
    {
      v12 = (*(*v11 + 8LL))(v8, &v38, v9);
      v14 = *(a1 + 56);
      v8 = v12;
      v46 = v12;
      if ( !v14 )
      {
        v9 = v48;
        goto LABEL_10;
      }
      LOBYTE(v13) = v14 != a1;
      (*(*v14 + 32LL))(v14, v13);
      v8 = v46;
      v9 = v48;
    }
    else
    {
      v46 = *(a1 + 56);
    }
    *(a1 + 56) = 0LL;
  }
LABEL_10:
  if ( v9 )
  {
    if ( v9 == v47 )
    {
      v15 = (*(*v9 + 8LL))(v9, a1);
      v16 = v48;
      *(a1 + 56) = v15;
      if ( v16 )
      {
        v17 = v47;
        LOBYTE(v17) = v16 != v47;
        (*(*v16 + 32LL))(v16, v17);
      }
      v8 = v46;
    }
    else
    {
      *(a1 + 56) = v9;
    }
  }
  if ( v8 )
  {
    v18 = &v38;
    LOBYTE(v18) = v8 != &v38;
    ((*v8)[4])(v8, v18);
  }
  v39 = a3;
  v38 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (*&)(AITask *,_t_AIDocument *,unsigned int,unsigned int,int,std::vector<ai::UnicodeString>),AITask * &,std::_Ph<1> const &,std::_Ph<2> const &,std::_Ph<3> const &,std::_Ph<4> const &,std::_Ph<5> const &>,void,_t_AIDocument *,unsigned int,unsigned int,int,std::vector<ai::UnicodeString>>::`vftable';
  v40 = v33;
  v19 = a1 + 64;
  v41 = v34;
  v42 = v35;
  v43 = v36;
  v44 = v37;
  v46 = &v38;
  v45 = a4;
  v48 = 0LL;
  v20 = sub_180009610(&v38, v47);
  v22 = v46;
  v23 = v20;
  v48 = v20;
  if ( v46 )
  {
    v24 = &v38;
    LOBYTE(v24) = v46 != &v38;
    ((*v46)[4])(v46, v24, v20);
    v23 = v48;
    v22 = 0LL;
    v46 = 0LL;
  }
  v25 = *(a1 + 120);
  if ( v25 )
  {
    v22 = *(a1 + 120);
    if ( v25 == v19 )
    {
      v26 = (*(*v25 + 8LL))(v22, &v38, v23);
      v27 = *(a1 + 120);
      v22 = v26;
      v46 = v26;
      if ( !v27 )
      {
        v23 = v48;
        goto LABEL_27;
      }
      LOBYTE(v21) = v27 != v19;
      (*(*v27 + 32LL))(v27, v21);
      v22 = v46;
      v23 = v48;
    }
    else
    {
      v46 = *(a1 + 120);
    }
    *(a1 + 120) = 0LL;
  }
LABEL_27:
  if ( v23 )
  {
    if ( v23 == v47 )
    {
      v28 = (*(*v23 + 8LL))(v23, a1 + 64);
      v29 = v48;
      *(a1 + 120) = v28;
      if ( v29 )
      {
        v30 = v47;
        LOBYTE(v30) = v29 != v47;
        (*(*v29 + 32LL))(v29, v30);
      }
      v22 = v46;
    }
    else
    {
      *(a1 + 120) = v23;
    }
  }
  if ( v22 )
  {
    LOBYTE(v21) = v22 != &v38;
    ((*v22)[4])(v22, v21);
  }
  return a1;
}


// ===== 函数: sub_180009660 (0x180009660) =====
__int64 __fastcall sub_180009660(__int64 a1, __int64 a2)
{
  *a2 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (*&)(AITask *,_t_AIDocument *,unsigned int,unsigned int,ai::UnicodeString),AITask * &,std::_Ph<1> const &,std::_Ph<2> const &,std::_Ph<3> const &,std::_Ph<4> const &>,void,_t_AIDocument *,unsigned int,unsigned int,ai::UnicodeString>::`vftable';
  *(a2 + 8) = *(a1 + 8);
  *(a2 + 16) = *(a1 + 16);
  *(a2 + 17) = *(a1 + 17);
  *(a2 + 18) = *(a1 + 18);
  *(a2 + 19) = *(a1 + 19);
  *(a2 + 24) = *(a1 + 24);
  return a2;
}


// ===== 函数: sub_180009610 (0x180009610) =====
__int64 __fastcall sub_180009610(__int64 a1, __int64 a2)
{
  *a2 = &std::_Func_impl_no_alloc<std::_Binder<std::_Unforced,void (*&)(AITask *,_t_AIDocument *,unsigned int,unsigned int,int,std::vector<ai::UnicodeString>),AITask * &,std::_Ph<1> const &,std::_Ph<2> const &,std::_Ph<3> const &,std::_Ph<4> const &,std::_Ph<5> const &>,void,_t_AIDocument *,unsigned int,unsigned int,int,std::vector<ai::UnicodeString>>::`vftable';
  *(a2 + 8) = *(a1 + 8);
  *(a2 + 16) = *(a1 + 16);
  *(a2 + 17) = *(a1 + 17);
  *(a2 + 18) = *(a1 + 18);
  *(a2 + 19) = *(a1 + 19);
  *(a2 + 20) = *(a1 + 20);
  *(a2 + 24) = *(a1 + 24);
  return a2;
}


