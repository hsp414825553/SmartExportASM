// 函数分析报告
// 目标函数: DispatchSmartExport (0x18000FB90)
// 分析时间: 2025-09-28 20:22:43.952905 
// 总共分析 351 个函数

// ========== 调用图 ==========
函数: DispatchSmartExport (0x18000FB90)
  调用以下函数:
    - sub_18000D200 (0x18000D200)
    - sub_18000BC80 (0x18000BC80)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - sub_180012E90 (0x180012E90)
    - sub_18001AE10 (0x18001AE10)
    - sub_180017990 (0x180017990)
    - sub_18000DB90 (0x18000DB90)
    - _Xtime_get_ticks (0x18004BC9A)
    - _Query_perf_counter (0x18004BCA0)
    - sub_180031D20 (0x180031D20)
    - sub_18000B220 (0x18000B220)
    - _Init_thread_footer (0x18004BEA4)
    - _Query_perf_frequency (0x18004BCA6)
    - _Thrd_sleep (0x18004BCAC)
    - sub_18000DB30 (0x18000DB30)
    - sub_18000DF40 (0x18000DF40)
    - sub_18000C440 (0x18000C440)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_180032550 (0x180032550)
    - sub_180028950 (0x180028950)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
    - sub_18000CFE0 (0x18000CFE0)
    - sub_18000B770 (0x18000B770)

函数: sub_18000D200 (0x18000D200)
  调用以下函数:
    - sub_18002DF30 (0x18002DF30)
    - sub_18001AE10 (0x18001AE10)
    - sub_18000C4E0 (0x18000C4E0)
    - sub_180036A90 (0x180036A90)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: sub_18002DF30 (0x18002DF30)
  调用以下函数:
    - sub_18002F200 (0x18002F200)
    - sub_180026D90 (0x180026D90)
    - sub_180026470 (0x180026470)
    - sub_180036A90 (0x180036A90)
    - sub_1800267D0 (0x1800267D0)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
  被以下函数调用:
    - sub_18000D200 (0x18000D200)
    - sub_180008D60 (0x180008D60)

函数: sub_18002F200 (0x18002F200)
  调用以下函数:
    - sub_18000B6F0 (0x18000B6F0)
    - sub_18002C1F0 (0x18002C1F0)
    - sub_18000DFF0 (0x18000DFF0)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_18002DF30 (0x18002DF30)

函数: sub_18000B6F0 (0x18000B6F0)
  调用以下函数:
    - sub_18000B6F0 (0x18000B6F0)
    - sub_18001AE10 (0x18001AE10)
    - sub_18000DFF0 (0x18000DFF0)
  被以下函数调用:
    - sub_18002F200 (0x18002F200)
    - sub_18000C4E0 (0x18000C4E0)
    - sub_180018A30 (0x180018A30)
    - sub_18000B6F0 (0x18000B6F0)

函数: sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_18002F200 (0x18002F200)
    - sub_18000D200 (0x18000D200)
    - sub_180030E80 (0x180030E80)
    - sub_180030600 (0x180030600)
    - sub_18002FB00 (0x18002FB00)
    - sub_180025880 (0x180025880)
    - sub_18002A600 (0x18002A600)
    - DispatchSmartExport (0x18000FB90)
    - sub_180015B90 (0x180015B90)
    - sub_180031510 (0x180031510)
    - BuildExportFilePath (0x180004C90)
    - sub_180024C90 (0x180024C90)
    - sub_18002B810 (0x18002B810)
    - sub_180005C10 (0x180005C10)
    - sub_18001E690 (0x18001E690)
    - sub_18000CFE0 (0x18000CFE0)
    - sub_18002F4A0 (0x18002F4A0)
    - sub_180030820 (0x180030820)
    - sub_18002F8A0 (0x18002F8A0)
    - sub_180028220 (0x180028220)
    - sub_180027CA0 (0x180027CA0)
    - sub_180012EA0 (0x180012EA0)
    - sub_18002EC30 (0x18002EC30)
    - sub_18002DC30 (0x18002DC30)
    - sub_18000E230 (0x18000E230)
    - sub_18002B3B0 (0x18002B3B0)
    - sub_18000E3B0 (0x18000E3B0)
    - sub_18002BFB0 (0x18002BFB0)
    - sub_180018A30 (0x180018A30)
    - sub_18001A0C0 (0x18001A0C0)
    - sub_180014540 (0x180014540)
    - sub_180025F40 (0x180025F40)
    - sub_18002BBC0 (0x18002BBC0)
    - sub_180026840 (0x180026840)
    - sub_18002DA50 (0x18002DA50)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_1800272D0 (0x1800272D0)
    - sub_180028950 (0x180028950)
    - fxGetArtHandlesFromAsset (0x1800123D0)
    - sub_18000C4E0 (0x18000C4E0)
    - sub_180030060 (0x180030060)
    - sub_18001A660 (0x18001A660)
    - sub_18002F5E0 (0x18002F5E0)
    - sub_180008D60 (0x180008D60)
    - sub_1800261E0 (0x1800261E0)
    - sub_180006CE0 (0x180006CE0)
    - sub_18002CC60 (0x18002CC60)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_1800047E0 (0x1800047E0)
    - sub_18000B6F0 (0x18000B6F0)
    - sub_18000DFF0 (0x18000DFF0)
    - sub_18000B870 (0x18000B870)
    - sub_18000B670 (0x18000B670)
    - sub_18000B770 (0x18000B770)
    - sub_18000B7F0 (0x18000B7F0)
    - sub_18003C470 (0x18003C470)
    - sub_180006EF0 (0x180006EF0)
    - sub_180009D70 (0x180009D70)
    - sub_1800211F0 (0x1800211F0)

函数: sub_18000DFF0 (0x18000DFF0)
  调用以下函数:
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_18000B6F0 (0x18000B6F0)
    - sub_18002F200 (0x18002F200)

函数: sub_180036A90 (0x180036A90)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180012E90 (0x180012E90)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_18000D200 (0x18000D200)
    - sub_180030E80 (0x180030E80)
    - sub_18002FB00 (0x18002FB00)
    - sub_180025880 (0x180025880)
    - sub_18002A600 (0x18002A600)
    - sub_180032310 (0x180032310)
    - sub_180031510 (0x180031510)
    - BuildExportFilePath (0x180004C90)
    - sub_180024C90 (0x180024C90)
    - sub_180005C10 (0x180005C10)
    - sub_18002F4A0 (0x18002F4A0)
    - sub_180030820 (0x180030820)
    - sub_18003D5A0 (0x18003D5A0)
    - sub_180028220 (0x180028220)
    - sub_18002DF30 (0x18002DF30)
    - sub_1800180B0 (0x1800180B0)
    - sub_1800051B0 (0x1800051B0)
    - sub_18002EC30 (0x18002EC30)
    - sub_18000E230 (0x18000E230)
    - sub_18000E3B0 (0x18000E3B0)
    - sub_1800243B0 (0x1800243B0)
    - sub_18001A0C0 (0x18001A0C0)
    - sub_1800311C0 (0x1800311C0)
    - sub_180014540 (0x180014540)
    - sub_1800175C0 (0x1800175C0)
    - sub_180025F40 (0x180025F40)
    - sub_18002DA50 (0x18002DA50)
    - sub_180023850 (0x180023850)
    - sub_180028950 (0x180028950)
    - sub_180018360 (0x180018360)
    - sub_180017F60 (0x180017F60)
    - sub_18001A660 (0x18001A660)
    - sub_18002F5E0 (0x18002F5E0)
    - sub_180008D60 (0x180008D60)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_18000DFF0 (0x18000DFF0)
    - sub_18000B7F0 (0x18000B7F0)
    - sub_180009D70 (0x180009D70)

函数: sub_180036EE0 (0x180036EE0)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_1800367E0 (0x1800367E0)
    - sub_180036480 (0x180036480)
    - sub_1800366C0 (0x1800366C0)
    - sub_1800376E0 (0x1800376E0)
    - sub_180037420 (0x180037420)
    - sub_1800373A0 (0x1800373A0)
    - sub_180037000 (0x180037000)
    - sub_180036B40 (0x180036B40)
    - sub_180036A90 (0x180036A90)
    - sub_1800372B0 (0x1800372B0)
    - sub_180037710 (0x180037710)
    - sub_180036F90 (0x180036F90)
    - sub_180036750 (0x180036750)
    - sub_180036E50 (0x180036E50)
    - sub_180037530 (0x180037530)

函数: sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_180032600 (0x180032600)
    - sub_18003B680 (0x18003B680)
    - sub_180037800 (0x180037800)
    - sub_180042000 (0x180042000)
    - sub_180008580 (0x180008580)
    - sub_180036A90 (0x180036A90)
    - DispatchSmartExport (0x18000FB90)
    - sub_180032E90 (0x180032E90)
    - sub_18003C310 (0x18003C310)
    - sub_180006B10 (0x180006B10)
    - sub_180035F90 (0x180035F90)
    - sub_180039810 (0x180039810)
    - sub_180036320 (0x180036320)
    - sub_180035AA0 (0x180035AA0)
    - sub_180036BB0 (0x180036BB0)
    - sub_1800388B0 (0x1800388B0)
    - sub_180004330 (0x180004330)
    - sub_18001E230 (0x18001E230)
    - sub_180046430 (0x180046430)
    - sub_18003C3C0 (0x18003C3C0)
    - sub_18003BF40 (0x18003BF40)
    - sub_180035940 (0x180035940)
    - sub_1800363C0 (0x1800363C0)
    - sub_180042BC0 (0x180042BC0)
    - sub_18001E2C0 (0x18001E2C0)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_180032550 (0x180032550)
    - sub_180004150 (0x180004150)
    - sub_1800425D0 (0x1800425D0)
    - sub_180032460 (0x180032460)
    - sub_180032860 (0x180032860)
    - sub_180007F60 (0x180007F60)
    - sub_1800427E0 (0x1800427E0)
    - sub_1800326E0 (0x1800326E0)
    - sub_180045EE0 (0x180045EE0)
    - sub_18000CFE0 (0x18000CFE0)
    - sub_180032AF0 (0x180032AF0)
    - sub_180036270 (0x180036270)
    - sub_1800359F0 (0x1800359F0)

函数: sub_180007790 (0x180007790)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
    - sub_180003F80 (0x180003F80)
  被以下函数调用:
    - sub_180036480 (0x180036480)
    - sub_180037000 (0x180037000)
    - sub_18003B680 (0x18003B680)
    - sub_180037800 (0x180037800)
    - sub_180036A90 (0x180036A90)
    - sub_180037710 (0x180037710)
    - sub_180036F90 (0x180036F90)
    - sub_18000C810 (0x18000C810)
    - sub_180031510 (0x180031510)
    - sub_180037420 (0x180037420)
    - sub_1800373A0 (0x1800373A0)
    - sub_180039A20 (0x180039A20)
    - sub_1800372B0 (0x1800372B0)
    - sub_180037530 (0x180037530)
    - sub_1800366C0 (0x1800366C0)
    - sub_180036B40 (0x180036B40)
    - sub_18003B5C0 (0x18003B5C0)
    - sub_18003B540 (0x18003B540)
    - sub_180036750 (0x180036750)
    - sub_180036E50 (0x180036E50)
    - sub_180028950 (0x180028950)
    - sub_1800367E0 (0x1800367E0)
    - sub_1800376E0 (0x1800376E0)
    - sub_180045EE0 (0x180045EE0)
    - sub_18003C970 (0x18003C970)

函数: sub_18002C1F0 (0x18002C1F0)
  调用以下函数:
    - sub_18002C620 (0x18002C620)
    - sub_18002C5C0 (0x18002C5C0)
  被以下函数调用:
    - sub_18002F200 (0x18002F200)
    - sub_18002B810 (0x18002B810)

函数: sub_18002C620 (0x18002C620)
  被以下函数调用:
    - sub_18002C1F0 (0x18002C1F0)

函数: sub_18002C5C0 (0x18002C5C0)
  被以下函数调用:
    - sub_18002C1F0 (0x18002C1F0)

函数: sub_180026D90 (0x180026D90)
  调用以下函数:
    - sub_1800372B0 (0x1800372B0)
  被以下函数调用:
    - sub_180025880 (0x180025880)
    - sub_180028220 (0x180028220)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_18002DF30 (0x18002DF30)
    - sub_180024C90 (0x180024C90)
    - sub_180028950 (0x180028950)

函数: sub_1800372B0 (0x1800372B0)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180026D90 (0x180026D90)
    - sub_18002EC30 (0x18002EC30)

函数: sub_180026470 (0x180026470)
  调用以下函数:
    - sub_18000E460 (0x18000E460)
    - sub_18001A0C0 (0x18001A0C0)
    - sub_180018860 (0x180018860)
    - sub_180018360 (0x180018360)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18000B8D0 (0x18000B8D0)
  被以下函数调用:
    - sub_18002DF30 (0x18002DF30)
    - sub_18002B4E0 (0x18002B4E0)

函数: sub_18000E460 (0x18000E460)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
  被以下函数调用:
    - sub_180026470 (0x180026470)
    - sub_1800183E0 (0x1800183E0)
    - sub_180025F40 (0x180025F40)
    - sub_18000B0B0 (0x18000B0B0)

函数: sub_180031D20 (0x180031D20)
  调用以下函数:
    - sub_180031CF0 (0x180031CF0)
    - _CxxThrowException (0x18004D0DC)
    - ?SPBasicAllocateBlock@ai@@YAH_KPEAPEAX@Z (0x180043FA7)
  被以下函数调用:
    - sub_18000B300 (0x18000B300)
    - sub_18000BC80 (0x18000BC80)
    - sub_18001AC00 (0x18001AC00)
    - sub_18000B980 (0x18000B980)
    - sub_180030600 (0x180030600)
    - sub_18002FB00 (0x18002FB00)
    - sub_18002A600 (0x18002A600)
    - sub_180025880 (0x180025880)
    - DispatchSmartExport (0x18000FB90)
    - sub_18001A990 (0x18001A990)
    - sub_180015B90 (0x180015B90)
    - sub_180024C90 (0x180024C90)
    - sub_18002B810 (0x18002B810)
    - sub_18000BBA0 (0x18000BBA0)
    - sub_18000B220 (0x18000B220)
    - sub_180030820 (0x180030820)
    - sub_18002F8A0 (0x18002F8A0)
    - sub_18003CD20 (0x18003CD20)
    - sub_180028220 (0x180028220)
    - sub_18000BB30 (0x18000BB30)
    - sub_18000B0B0 (0x18000B0B0)
    - sub_18002DC30 (0x18002DC30)
    - sub_18002B3B0 (0x18002B3B0)
    - sub_18002BFB0 (0x18002BFB0)
    - sub_180037530 (0x180037530)
    - sub_18003BF40 (0x18003BF40)
    - sub_1800157C0 (0x1800157C0)
    - sub_180026B40 (0x180026B40)
    - sub_180026840 (0x180026840)
    - sub_18003D250 (0x18003D250)
    - sub_1800272D0 (0x1800272D0)
    - sub_180028950 (0x180028950)
    - sub_18000E460 (0x18000E460)
    - sub_18000B3E0 (0x18000B3E0)
    - sub_180030060 (0x180030060)
    - sub_18001A660 (0x18001A660)
    - sub_18001C060 (0x18001C060)
    - sub_18002F5E0 (0x18002F5E0)
    - sub_18003D3E0 (0x18003D3E0)
    - sub_18002CC60 (0x18002CC60)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_180006EF0 (0x180006EF0)
    - sub_1800182F0 (0x1800182F0)

函数: sub_180031CF0 (0x180031CF0)
  被以下函数调用:
    - sub_180031D20 (0x180031D20)

函数: _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180036480 (0x180036480)
    - sub_180037000 (0x180037000)
    - sub_180032600 (0x180032600)
    - sub_18003B680 (0x18003B680)
    - sub_180042000 (0x180042000)
    - sub_180037710 (0x180037710)
    - sub_180036F90 (0x180036F90)
    - sub_180031510 (0x180031510)
    - sub_180035F90 (0x180035F90)
    - DispatchSmartExport (0x18000FB90)
    - sub_180031D20 (0x180031D20)
    - sub_1800373A0 (0x1800373A0)
    - sub_180030820 (0x180030820)
    - sub_180039A20 (0x180039A20)
    - sub_180036320 (0x180036320)
    - sub_180035AA0 (0x180035AA0)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - sub_1800180B0 (0x1800180B0)
    - sub_180036BB0 (0x180036BB0)
    - sub_1800388B0 (0x1800388B0)
    - sub_18001E230 (0x18001E230)
    - sub_180037530 (0x180037530)
    - sub_1800366C0 (0x1800366C0)
    - sub_180036B40 (0x180036B40)
    - sub_18003BF40 (0x18003BF40)
    - sub_180035940 (0x180035940)
    - sub_1800363C0 (0x1800363C0)
    - sub_180042BC0 (0x180042BC0)
    - sub_180032550 (0x180032550)
    - sub_18003CAD0 (0x18003CAD0)
    - sub_180036750 (0x180036750)
    - sub_180004150 (0x180004150)
    - sub_180036E50 (0x180036E50)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_1800425D0 (0x1800425D0)
    - sub_180032460 (0x180032460)
    - sub_1800367E0 (0x1800367E0)
    - sub_180032860 (0x180032860)
    - sub_1800427E0 (0x1800427E0)
    - sub_1800326E0 (0x1800326E0)
    - sub_180026D60 (0x180026D60)
    - sub_180045EE0 (0x180045EE0)
    - sub_18000CFE0 (0x18000CFE0)
    - sub_18001E370 (0x18001E370)
    - sub_18003C970 (0x18003C970)
    - sub_180032AF0 (0x180032AF0)
    - sub_1800359F0 (0x1800359F0)

函数: ?SPBasicAllocateBlock@ai@@YAH_KPEAPEAX@Z (0x180043FA7)
  被以下函数调用:
    - sub_180031D20 (0x180031D20)

函数: ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
  调用以下函数:
    - sub_1800047B0 (0x1800047B0)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18000E460 (0x18000E460)
    - sub_180030060 (0x180030060)
    - sub_18002F5E0 (0x18002F5E0)
    - sub_18002F8A0 (0x18002F8A0)
    - sub_18002FB00 (0x18002FB00)
    - sub_180026840 (0x180026840)
    - sub_180015B90 (0x180015B90)
    - sub_180006EF0 (0x180006EF0)
    - sub_18002DC30 (0x18002DC30)
    - sub_1800182F0 (0x1800182F0)
    - sub_180037530 (0x180037530)

函数: sub_1800047B0 (0x1800047B0)
  被以下函数调用:
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)

函数: sub_18001A0C0 (0x18001A0C0)
  调用以下函数:
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180026470 (0x180026470)
    - sub_1800183E0 (0x1800183E0)

函数: sub_180018860 (0x180018860)
  被以下函数调用:
    - sub_180026470 (0x180026470)
    - sub_1800183E0 (0x1800183E0)

函数: sub_180018360 (0x180018360)
  调用以下函数:
    - sub_180036A90 (0x180036A90)
  被以下函数调用:
    - sub_180026470 (0x180026470)

函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
  调用以下函数:
    - ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E)
  被以下函数调用:
    - sub_180030060 (0x180030060)
    - sub_18002F5E0 (0x18002F5E0)
    - sub_18002F8A0 (0x18002F8A0)
    - sub_18002FB00 (0x18002FB00)
    - sub_1800175C0 (0x1800175C0)
    - sub_180025F40 (0x180025F40)
    - sub_180026840 (0x180026840)
    - sub_1800183E0 (0x1800183E0)
    - sub_180026470 (0x180026470)
    - sub_18000B0B0 (0x18000B0B0)
    - sub_18002DC30 (0x18002DC30)
    - sub_18002DA50 (0x18002DA50)
    - sub_18001E690 (0x18001E690)

函数: ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E)
  被以下函数调用:
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18001C060 (0x18001C060)
    - sub_180015B90 (0x180015B90)
    - sub_1800157C0 (0x1800157C0)

函数: sub_18000B8D0 (0x18000B8D0)
  调用以下函数:
    - sub_180036480 (0x180036480)
  被以下函数调用:
    - sub_180026470 (0x180026470)
    - sub_180025F40 (0x180025F40)
    - sub_18000B0B0 (0x18000B0B0)

函数: sub_180036480 (0x180036480)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_18000B300 (0x18000B300)
    - sub_180030600 (0x180030600)
    - sub_18002F5E0 (0x18002F5E0)
    - sub_18002A600 (0x18002A600)
    - sub_1800183E0 (0x1800183E0)
    - sub_18000B8D0 (0x18000B8D0)
    - sub_180031510 (0x180031510)
    - sub_180032310 (0x180032310)
    - sub_18002EC30 (0x18002EC30)
    - BuildExportFilePath (0x180004C90)
    - sub_18002DA50 (0x18002DA50)
    - sub_180017CF0 (0x180017CF0)
    - sub_180028950 (0x180028950)

函数: sub_180003F80 (0x180003F80)
  被以下函数调用:
    - sub_180036480 (0x180036480)
    - sub_180037000 (0x180037000)
    - sub_180032600 (0x180032600)
    - sub_18003B680 (0x18003B680)
    - sub_180042000 (0x180042000)
    - DispatchSmartExport (0x18000FB90)
    - sub_180037710 (0x180037710)
    - sub_180036F90 (0x180036F90)
    - sub_180031510 (0x180031510)
    - sub_180035F90 (0x180035F90)
    - sub_1800373A0 (0x1800373A0)
    - sub_180030820 (0x180030820)
    - sub_180039A20 (0x180039A20)
    - sub_180036320 (0x180036320)
    - sub_180035AA0 (0x180035AA0)
    - sub_1800180B0 (0x1800180B0)
    - sub_180036BB0 (0x180036BB0)
    - sub_1800388B0 (0x1800388B0)
    - sub_18001E230 (0x18001E230)
    - sub_180037530 (0x180037530)
    - sub_1800366C0 (0x1800366C0)
    - sub_180036B40 (0x180036B40)
    - sub_18003BF40 (0x18003BF40)
    - sub_180035940 (0x180035940)
    - sub_1800363C0 (0x1800363C0)
    - sub_180042BC0 (0x180042BC0)
    - sub_180032550 (0x180032550)
    - sub_18003CAD0 (0x18003CAD0)
    - sub_180004150 (0x180004150)
    - sub_180036750 (0x180036750)
    - sub_180036E50 (0x180036E50)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_1800425D0 (0x1800425D0)
    - sub_1800367E0 (0x1800367E0)
    - sub_180032460 (0x180032460)
    - sub_180032860 (0x180032860)
    - sub_1800427E0 (0x1800427E0)
    - sub_1800326E0 (0x1800326E0)
    - sub_18000CFE0 (0x18000CFE0)
    - sub_180045EE0 (0x180045EE0)
    - sub_18001E370 (0x18001E370)
    - sub_18003C970 (0x18003C970)
    - sub_180032AF0 (0x180032AF0)
    - sub_1800359F0 (0x1800359F0)

函数: sub_1800267D0 (0x1800267D0)
  被以下函数调用:
    - sub_180025880 (0x180025880)
    - sub_180028220 (0x180028220)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_18002DF30 (0x18002DF30)
    - sub_180024C90 (0x180024C90)
    - sub_180028950 (0x180028950)

函数: ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)
    - sub_180025880 (0x180025880)
    - sub_180028220 (0x180028220)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_18002DF30 (0x18002DF30)
    - sub_180031130 (0x180031130)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x180022590)
    - sub_180024C90 (0x180024C90)
    - sub_180028950 (0x180028950)

函数: sub_18000C4E0 (0x18000C4E0)
  调用以下函数:
    - sub_18000B670 (0x18000B670)
    - sub_18001AE10 (0x18001AE10)
    - sub_18000B770 (0x18000B770)
    - sub_18000B7F0 (0x18000B7F0)
    - sub_18000B6F0 (0x18000B6F0)
  被以下函数调用:
    - sub_18000D200 (0x18000D200)
    - sub_180028950 (0x180028950)
    - sub_180008D60 (0x180008D60)

函数: sub_18000B670 (0x18000B670)
  调用以下函数:
    - sub_18000B870 (0x18000B870)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_18000C4E0 (0x18000C4E0)

函数: sub_18000B870 (0x18000B870)
  调用以下函数:
    - sub_18000B870 (0x18000B870)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180025880 (0x180025880)
    - sub_180028220 (0x180028220)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_18000B670 (0x18000B670)
    - sub_18002B810 (0x18002B810)
    - sub_18000B870 (0x18000B870)
    - sub_180024C90 (0x180024C90)
    - sub_18002B3B0 (0x18002B3B0)
    - sub_180018A30 (0x180018A30)

函数: sub_18000B770 (0x18000B770)
  调用以下函数:
    - sub_18000B770 (0x18000B770)
    - sub_18001AE10 (0x18001AE10)
    - sub_180032550 (0x180032550)
  被以下函数调用:
    - sub_18000C4E0 (0x18000C4E0)
    - sub_180018A30 (0x180018A30)
    - sub_180028950 (0x180028950)
    - sub_18000B770 (0x18000B770)
    - DispatchSmartExport (0x18000FB90)

函数: sub_180032550 (0x180032550)
  调用以下函数:
    - sub_180032E90 (0x180032E90)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_180030820 (0x180030820)
    - sub_180008D60 (0x180008D60)
    - sub_18003D5A0 (0x18003D5A0)
    - sub_180025880 (0x180025880)
    - sub_180028220 (0x180028220)
    - sub_18000B770 (0x18000B770)
    - sub_180009D70 (0x180009D70)
    - sub_18002EC30 (0x18002EC30)
    - DispatchSmartExport (0x18000FB90)
    - sub_18002B190 (0x18002B190)
    - sub_180023850 (0x180023850)
    - sub_180024C90 (0x180024C90)
    - sub_1800243B0 (0x1800243B0)
    - sub_180028950 (0x180028950)

函数: sub_180032E90 (0x180032E90)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180032600 (0x180032600)
    - sub_180032460 (0x180032460)
    - sub_180032860 (0x180032860)
    - sub_1800326E0 (0x1800326E0)
    - sub_180032550 (0x180032550)
    - sub_180032AF0 (0x180032AF0)

函数: _Init_thread_footer (0x18004BEA4)
  被以下函数调用:
    - sub_18003B680 (0x18003B680)
    - sub_180030600 (0x180030600)
    - sub_180042000 (0x180042000)
    - sub_180008580 (0x180008580)
    - sub_180032E90 (0x180032E90)
    - DispatchSmartExport (0x18000FB90)
    - sub_18003C310 (0x18003C310)
    - sub_180006B10 (0x180006B10)
    - sub_180039810 (0x180039810)
    - sub_180036BB0 (0x180036BB0)
    - sub_1800388B0 (0x1800388B0)
    - sub_180004330 (0x180004330)
    - sub_18002BFB0 (0x18002BFB0)
    - sub_180046430 (0x180046430)
    - sub_18003C3C0 (0x18003C3C0)
    - sub_18003BF40 (0x18003BF40)
    - sub_180042BC0 (0x180042BC0)
    - sub_18001E2C0 (0x18001E2C0)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_1800425D0 (0x1800425D0)
    - sub_180028950 (0x180028950)
    - sub_180007F60 (0x180007F60)
    - sub_1800427E0 (0x1800427E0)
    - sub_18000CFE0 (0x18000CFE0)
    - sub_180045EE0 (0x180045EE0)
    - sub_18000D970 (0x18000D970)
    - sub_180036270 (0x180036270)

函数: _Init_thread_header (0x18004BF04)
  调用以下函数:
    - _Init_thread_wait (0x18004BFB0)
  被以下函数调用:
    - sub_18003B680 (0x18003B680)
    - sub_180030600 (0x180030600)
    - sub_180042000 (0x180042000)
    - sub_180008580 (0x180008580)
    - sub_180032E90 (0x180032E90)
    - DispatchSmartExport (0x18000FB90)
    - sub_18003C310 (0x18003C310)
    - sub_180006B10 (0x180006B10)
    - sub_180039810 (0x180039810)
    - sub_180036BB0 (0x180036BB0)
    - sub_1800388B0 (0x1800388B0)
    - sub_180004330 (0x180004330)
    - sub_18002BFB0 (0x18002BFB0)
    - sub_180046430 (0x180046430)
    - sub_18003C3C0 (0x18003C3C0)
    - sub_18003BF40 (0x18003BF40)
    - sub_180042BC0 (0x180042BC0)
    - sub_18001E2C0 (0x18001E2C0)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_1800425D0 (0x1800425D0)
    - sub_180028950 (0x180028950)
    - sub_180007F60 (0x180007F60)
    - sub_1800427E0 (0x1800427E0)
    - sub_18000CFE0 (0x18000CFE0)
    - sub_180045EE0 (0x180045EE0)
    - sub_18000D970 (0x18000D970)
    - sub_180036270 (0x180036270)

函数: _Init_thread_wait (0x18004BFB0)
  被以下函数调用:
    - _Init_thread_header (0x18004BF04)

函数: sub_18000B7F0 (0x18000B7F0)
  调用以下函数:
    - sub_18000B7F0 (0x18000B7F0)
    - sub_18001AE10 (0x18001AE10)
    - sub_180036A90 (0x180036A90)
  被以下函数调用:
    - sub_18000C4E0 (0x18000C4E0)
    - sub_180030820 (0x180030820)
    - sub_180009D70 (0x180009D70)
    - sub_180018A30 (0x180018A30)
    - sub_18000B7F0 (0x18000B7F0)

函数: sub_18000BC80 (0x18000BC80)
  调用以下函数:
    - sub_180032460 (0x180032460)
    - sub_180031D20 (0x180031D20)
    - sub_18000BBA0 (0x18000BBA0)
    - sub_18000B000 (0x18000B000)
    - sub_18000BB30 (0x18000BB30)
    - sub_18000B0B0 (0x18000B0B0)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)
    - sub_180028950 (0x180028950)
    - sub_180008D60 (0x180008D60)

函数: sub_180032460 (0x180032460)
  调用以下函数:
    - sub_180032E90 (0x180032E90)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_18000BC80 (0x18000BC80)
    - sub_18000B220 (0x18000B220)
    - sub_1800271C0 (0x1800271C0)
    - sub_180028950 (0x180028950)
    - sub_180039350 (0x180039350)

函数: sub_18000BBA0 (0x18000BBA0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18000B300 (0x18000B300)
  被以下函数调用:
    - sub_18000BC80 (0x18000BC80)
    - sub_180008D60 (0x180008D60)

函数: sub_18000B300 (0x18000B300)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18000B300 (0x18000B300)
    - sub_180036480 (0x180036480)
  被以下函数调用:
    - sub_18000BBA0 (0x18000BBA0)
    - sub_18000B300 (0x18000B300)

函数: sub_18000B000 (0x18000B000)
  调用以下函数:
    - sub_18000B3E0 (0x18000B3E0)
  被以下函数调用:
    - sub_18000BC80 (0x18000BC80)
    - sub_18002B810 (0x18002B810)
    - sub_180028220 (0x180028220)
    - sub_18002B3B0 (0x18002B3B0)

函数: sub_18000B3E0 (0x18000B3E0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18000B3E0 (0x18000B3E0)
  被以下函数调用:
    - sub_18000B000 (0x18000B000)
    - sub_18002B810 (0x18002B810)
    - sub_18000B3E0 (0x18000B3E0)

函数: sub_18000BB30 (0x18000BB30)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18000AF50 (0x18000AF50)
  被以下函数调用:
    - sub_18000BC80 (0x18000BC80)
    - sub_180028950 (0x180028950)

函数: sub_18000AF50 (0x18000AF50)
  调用以下函数:
    - sub_18000B220 (0x18000B220)
  被以下函数调用:
    - sub_18000BB30 (0x18000BB30)
    - sub_180028950 (0x180028950)

函数: sub_18000B220 (0x18000B220)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18000B220 (0x18000B220)
    - sub_180032460 (0x180032460)
  被以下函数调用:
    - sub_18000AF50 (0x18000AF50)
    - sub_18000B220 (0x18000B220)
    - DispatchSmartExport (0x18000FB90)

函数: sub_18000B0B0 (0x18000B0B0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18000E460 (0x18000E460)
    - sub_18000B0B0 (0x18000B0B0)
    - sub_18000B8D0 (0x18000B8D0)
  被以下函数调用:
    - sub_18000BC80 (0x18000BC80)
    - sub_18000B0B0 (0x18000B0B0)

函数: sub_180017990 (0x180017990)
  调用以下函数:
    - sub_180017F60 (0x180017F60)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: sub_180017F60 (0x180017F60)
  调用以下函数:
    - sub_1800367E0 (0x1800367E0)
    - unknown_libname_2 (0x180032540)
    - sub_1800366C0 (0x1800366C0)
    - sub_180036A90 (0x180036A90)
    - sub_1800180B0 (0x1800180B0)
  被以下函数调用:
    - sub_180017990 (0x180017990)

函数: sub_1800367E0 (0x1800367E0)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180017F60 (0x180017F60)
    - sub_180014540 (0x180014540)
    - sub_180004150 (0x180004150)

函数: unknown_libname_2 (0x180032540)
  被以下函数调用:
    - sub_180017F60 (0x180017F60)
    - sub_180030820 (0x180030820)
    - sub_180008D60 (0x180008D60)
    - sub_18001A660 (0x18001A660)
    - sub_1800311C0 (0x1800311C0)
    - sub_180025880 (0x180025880)
    - sub_180028220 (0x180028220)
    - sub_1800051B0 (0x1800051B0)
    - sub_18002EC30 (0x18002EC30)
    - sub_180032AF0 (0x180032AF0)
    - sub_180039170 (0x180039170)
    - sub_180024C90 (0x180024C90)
    - sub_18002B190 (0x18002B190)
    - sub_180023850 (0x180023850)
    - sub_1800243B0 (0x1800243B0)
    - sub_180028950 (0x180028950)

函数: sub_1800366C0 (0x1800366C0)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180017F60 (0x180017F60)

函数: sub_1800180B0 (0x1800180B0)
  调用以下函数:
    - sub_1800376E0 (0x1800376E0)
    - sub_180037420 (0x180037420)
    - sub_1800373A0 (0x1800373A0)
    - sub_180037000 (0x180037000)
    - sub_180036B40 (0x180036B40)
    - sub_180003F80 (0x180003F80)
    - sub_180037710 (0x180037710)
    - sub_180036F90 (0x180036F90)
    - sub_180036A90 (0x180036A90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180017F60 (0x180017F60)

函数: sub_1800376E0 (0x1800376E0)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_1800180B0 (0x1800180B0)

函数: sub_180037420 (0x180037420)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_1800180B0 (0x1800180B0)

函数: sub_1800373A0 (0x1800373A0)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_1800180B0 (0x1800180B0)

函数: sub_180037000 (0x180037000)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_1800180B0 (0x1800180B0)

函数: sub_180036B40 (0x180036B40)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180026160 (0x180026160)
    - sub_1800053C0 (0x1800053C0)
    - sub_1800180B0 (0x1800180B0)
    - sub_180032310 (0x180032310)
    - sub_1800051B0 (0x1800051B0)
    - sub_180023850 (0x180023850)
    - sub_1800243B0 (0x1800243B0)

函数: sub_180037710 (0x180037710)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_1800180B0 (0x1800180B0)

函数: sub_180036F90 (0x180036F90)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_1800180B0 (0x1800180B0)
    - BuildExportFilePath (0x180004C90)

函数: sub_18000DB90 (0x18000DB90)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)
    - sub_180028950 (0x180028950)

函数: _Xtime_get_ticks (0x18004BC9A)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: _Query_perf_counter (0x18004BCA0)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: _Query_perf_frequency (0x18004BCA6)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: _Thrd_sleep (0x18004BCAC)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: sub_18000DB30 (0x18000DB30)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: sub_18000DF40 (0x18000DF40)
  被以下函数调用:
    - sub_180030820 (0x180030820)
    - sub_180008D60 (0x180008D60)
    - sub_18000B980 (0x18000B980)
    - DispatchSmartExport (0x18000FB90)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)

函数: sub_18000C440 (0x18000C440)
  调用以下函数:
    - sub_18000CDB0 (0x18000CDB0)
    - sub_18000D970 (0x18000D970)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: sub_18000CDB0 (0x18000CDB0)
  被以下函数调用:
    - sub_18000C440 (0x18000C440)
    - sub_180009D70 (0x180009D70)
    - sub_180025880 (0x180025880)

函数: sub_18000D970 (0x18000D970)
  调用以下函数:
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_18000C440 (0x18000C440)
    - sub_1800427E0 (0x1800427E0)
    - sub_18002A600 (0x18002A600)
    - sub_18002CC60 (0x18002CC60)
    - sub_18002EC30 (0x18002EC30)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_180028950 (0x180028950)
    - fxGetArtHandlesFromAsset (0x1800123D0)

函数: fxExportAllArtboardsWithEntitlementCheck (0x180011750)
  调用以下函数:
    - sub_180008D60 (0x180008D60)
    - sub_18000DF40 (0x18000DF40)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - sub_18001AE10 (0x18001AE10)
    - sub_180016BF0 (0x180016BF0)
    - sub_18000D970 (0x18000D970)
    - sub_18000C590 (0x18000C590)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: sub_180008D60 (0x180008D60)
  调用以下函数:
    - sub_180015FC0 (0x180015FC0)
    - sub_18000BC80 (0x18000BC80)
    - unknown_libname_2 (0x180032540)
    - sub_180032600 (0x180032600)
    - sub_18000DF40 (0x18000DF40)
    - sub_18000BBA0 (0x18000BBA0)
    - sub_18000C4E0 (0x18000C4E0)
    - sub_18002DF30 (0x18002DF30)
    - sub_18000C590 (0x18000C590)
    - sub_180009D70 (0x180009D70)
    - sub_180032550 (0x180032550)
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)

函数: sub_180015FC0 (0x180015FC0)
  调用以下函数:
    - ?_Throw_C_error@std@@YAXH@Z (0x18004BD00)
    - _Mtx_unlock (0x18004BCFA)
    - _Mtx_lock (0x18004BCF4)
  被以下函数调用:
    - sub_180008D60 (0x180008D60)

函数: ?_Throw_C_error@std@@YAXH@Z (0x18004BD00)
  被以下函数调用:
    - sub_180015FC0 (0x180015FC0)
    - sub_1800160E0 (0x1800160E0)

函数: _Mtx_unlock (0x18004BCFA)
  被以下函数调用:
    - sub_180015FC0 (0x180015FC0)

函数: _Mtx_lock (0x18004BCF4)
  被以下函数调用:
    - sub_180015FC0 (0x180015FC0)
    - sub_1800160E0 (0x1800160E0)

函数: sub_180032600 (0x180032600)
  调用以下函数:
    - sub_180032E90 (0x180032E90)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_180008D60 (0x180008D60)
    - sub_18003D5A0 (0x18003D5A0)
    - sub_180025880 (0x180025880)
    - sub_180028220 (0x180028220)
    - sub_180028950 (0x180028950)
    - BuildExportFilePath (0x180004C90)
    - sub_180024C90 (0x180024C90)
    - sub_180023850 (0x180023850)
    - sub_1800243B0 (0x1800243B0)

函数: sub_18000C590 (0x18000C590)
  被以下函数调用:
    - sub_180008D60 (0x180008D60)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_180009D70 (0x180009D70)

函数: sub_180009D70 (0x180009D70)
  调用以下函数:
    - sub_1800305C0 (0x1800305C0)
    - sub_1800311C0 (0x1800311C0)
    - sub_18000B980 (0x18000B980)
    - sub_1800160E0 (0x1800160E0)
    - sub_18000DA40 (0x18000DA40)
    - __security_check_cookie (0x18004C150)
    - sub_180032550 (0x180032550)
    - sub_18001AE10 (0x18001AE10)
    - sub_180004150 (0x180004150)
    - sub_18002E370 (0x18002E370)
    - sub_18000B7F0 (0x18000B7F0)
    - sub_18000C810 (0x18000C810)
    - sub_180036A90 (0x180036A90)
    - sub_18000C590 (0x18000C590)
    - sub_18002EC30 (0x18002EC30)
    - sub_18000E230 (0x18000E230)
    - sub_180012D50 (0x180012D50)
    - sub_18000CDB0 (0x18000CDB0)
  被以下函数调用:
    - sub_180008D60 (0x180008D60)

函数: sub_1800305C0 (0x1800305C0)
  调用以下函数:
    - sub_180030060 (0x180030060)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: sub_180030060 (0x180030060)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18002F4A0 (0x18002F4A0)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18001AE10 (0x18001AE10)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - sub_180030450 (0x180030450)
  被以下函数调用:
    - sub_1800305C0 (0x1800305C0)

函数: sub_18002F4A0 (0x18002F4A0)
  调用以下函数:
    - sub_18001AE10 (0x18001AE10)
    - sub_18000C030 (0x18000C030)
    - sub_180036A90 (0x180036A90)
    - sub_180031DC0 (0x180031DC0)
  被以下函数调用:
    - sub_180030060 (0x180030060)
    - sub_180030450 (0x180030450)

函数: sub_18000C030 (0x18000C030)
  调用以下函数:
  被以下函数调用:
    - sub_18002F4A0 (0x18002F4A0)
    - sub_180030820 (0x180030820)
    - sub_18003B680 (0x18003B680)
    - sub_18000E230 (0x18000E230)
    - sub_180037530 (0x180037530)

函数: sub_180031DC0 (0x180031DC0)
  调用以下函数:
  被以下函数调用:
    - sub_18002F4A0 (0x18002F4A0)
    - sub_18001AC00 (0x18001AC00)
    - sub_18001A660 (0x18001A660)
    - sub_180030820 (0x180030820)
    - sub_18003B590 (0x18003B590)
    - sub_18001A990 (0x18001A990)
    - sub_18000E230 (0x18000E230)

函数: sub_180030450 (0x180030450)
  调用以下函数:
    - sub_18002F4A0 (0x18002F4A0)
  被以下函数调用:
    - sub_180030060 (0x180030060)

函数: sub_1800311C0 (0x1800311C0)
  调用以下函数:
    - unknown_libname_2 (0x180032540)
    - sub_18001AC00 (0x18001AC00)
    - sub_18003B680 (0x18003B680)
    - sub_18001A660 (0x18001A660)
    - sub_18001E370 (0x18001E370)
    - sub_18003CAD0 (0x18003CAD0)
    - sub_18003C970 (0x18003C970)
    - sub_18001A990 (0x18001A990)
    - sub_180036A90 (0x180036A90)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x180022590)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: sub_18001AC00 (0x18001AC00)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180031DC0 (0x180031DC0)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)

函数: sub_18003B680 (0x18003B680)
  调用以下函数:
    - sub_18003C3C0 (0x18003C3C0)
    - sub_18003B5C0 (0x18003B5C0)
    - sub_18003B540 (0x18003B540)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
    - sub_180004080 (0x180004080)
    - sub_180007790 (0x180007790)
    - sub_180012E90 (0x180012E90)
    - sub_180036BB0 (0x180036BB0)
    - sub_18000C030 (0x18000C030)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)

函数: sub_18003C3C0 (0x18003C3C0)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_18003B680 (0x18003B680)
    - sub_18003B540 (0x18003B540)
    - sub_18003B5C0 (0x18003B5C0)

函数: sub_18003B5C0 (0x18003B5C0)
  调用以下函数:
    - sub_18003C3C0 (0x18003C3C0)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_18003B680 (0x18003B680)

函数: sub_18003B540 (0x18003B540)
  调用以下函数:
    - sub_18003C3C0 (0x18003C3C0)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_18003B680 (0x18003B680)

函数: sub_180004080 (0x180004080)
  被以下函数调用:
    - sub_18003B680 (0x18003B680)
    - sub_180030820 (0x180030820)
    - sub_18003BF40 (0x18003BF40)
    - sub_180004150 (0x180004150)
    - sub_18003C970 (0x18003C970)

函数: sub_180036BB0 (0x180036BB0)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18003B680 (0x18003B680)

函数: sub_18001A660 (0x18001A660)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - unknown_libname_2 (0x180032540)
    - sub_180031DC0 (0x180031DC0)
    - sub_180036A90 (0x180036A90)
    - sub_180036E30 (0x180036E30)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
    - memset (0x18004D0FA)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)

函数: sub_180036E30 (0x180036E30)
  调用以下函数:
    - sub_1800364F0 (0x1800364F0)
  被以下函数调用:
    - sub_18001A660 (0x18001A660)

函数: sub_1800364F0 (0x1800364F0)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180036E30 (0x180036E30)
    - BuildExportFilePath (0x180004C90)

函数: __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180030600 (0x180030600)
    - sub_18001A580 (0x18001A580)
    - sub_18002CA00 (0x18002CA00)
    - sub_18002A600 (0x18002A600)
    - sub_180031510 (0x180031510)
    - BuildExportFilePath (0x180004C90)
    - sub_18002B190 (0x18002B190)
    - sub_180024C90 (0x180024C90)
    - sub_180005C10 (0x180005C10)
    - DispatchSmartExport (0x18000FB90)
    - sub_18003D5A0 (0x18003D5A0)
    - sub_180027CA0 (0x180027CA0)
    - sub_18002EC30 (0x18002EC30)
    - sub_18002BFB0 (0x18002BFB0)
    - sub_180014540 (0x180014540)
    - sub_18002BBC0 (0x18002BBC0)
    - sub_180005350 (0x180005350)
    - sub_180012D50 (0x180012D50)
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)
    - sub_1800425D0 (0x1800425D0)
    - sub_180023850 (0x180023850)
    - sub_1800272D0 (0x1800272D0)
    - sub_180028950 (0x180028950)
    - sub_18001A660 (0x18001A660)
    - sub_18002CEE0 (0x18002CEE0)
    - sub_1800427E0 (0x1800427E0)
    - sub_180006CE0 (0x180006CE0)
    - sub_18002CC60 (0x18002CC60)
    - sub_180045EE0 (0x180045EE0)
    - sub_18003C470 (0x18003C470)
    - sub_180009D70 (0x180009D70)

函数: memset (0x18004D0FA)
  被以下函数调用:
    - sub_18001A660 (0x18001A660)
    - sub_180026840 (0x180026840)
    - sub_18003D3E0 (0x18003D3E0)

函数: sub_18001E370 (0x18001E370)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)

函数: sub_18003CAD0 (0x18003CAD0)
  调用以下函数:
    - sub_18003BF40 (0x18003BF40)
    - sub_180003F80 (0x180003F80)
    - sub_18003C470 (0x18003C470)
    - sub_180006EF0 (0x180006EF0)
    - sub_18003B590 (0x18003B590)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)

函数: sub_18003BF40 (0x18003BF40)
  调用以下函数:
    - sub_180008800 (0x180008800)
    - sub_180031D20 (0x180031D20)
    - sub_180003F80 (0x180003F80)
    - sub_180004080 (0x180004080)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18003CAD0 (0x18003CAD0)
    - sub_18003C970 (0x18003C970)

函数: sub_180008800 (0x180008800)
  被以下函数调用:
    - sub_18003BF40 (0x18003BF40)

函数: sub_18003C470 (0x18003C470)
  调用以下函数:
    - sub_18003B380 (0x18003B380)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
    - sub_18003C6D0 (0x18003C6D0)
  被以下函数调用:
    - sub_18003CAD0 (0x18003CAD0)

函数: sub_18003B380 (0x18003B380)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18001AE10 (0x18001AE10)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - memmove (0x18004D0F4)
  被以下函数调用:
    - sub_18003C470 (0x18003C470)

函数: sub_18003C6D0 (0x18003C6D0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180004080 (0x180004080)
    - sub_180031DC0 (0x180031DC0)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18003C470 (0x18003C470)

函数: sub_180006EF0 (0x180006EF0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - memcpy (0x18004D0EE)
    - sub_18001AE10 (0x18001AE10)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180006ED0)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - memmove (0x18004D0F4)
  被以下函数调用:
    - sub_18002CA00 (0x18002CA00)
    - sub_180027CA0 (0x180027CA0)
    - sub_18003CAD0 (0x18003CAD0)
    - sub_1800067F0 (0x1800067F0)
    - sub_18003C970 (0x18003C970)
    - sub_18002EC30 (0x18002EC30)
    - sub_180028950 (0x180028950)
    - sub_18002C930 (0x18002C930)

函数: memcpy (0x18004D0EE)
  被以下函数调用:
    - sub_180006EF0 (0x180006EF0)
    - sub_180037530 (0x180037530)
    - sub_180014540 (0x180014540)

函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180006ED0)
  调用以下函数:
    - ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E)
  被以下函数调用:
    - sub_180006EF0 (0x180006EF0)
    - sub_180037530 (0x180037530)

函数: memmove (0x18004D0F4)
  被以下函数调用:
    - sub_180026840 (0x180026840)
    - sub_180006CE0 (0x180006CE0)
    - sub_180006EF0 (0x180006EF0)
    - sub_18002DC30 (0x18002DC30)
    - sub_180037530 (0x180037530)
    - sub_18001E690 (0x18001E690)

函数: sub_18003B590 (0x18003B590)
  调用以下函数:
    - sub_180031DC0 (0x180031DC0)
  被以下函数调用:
    - sub_18003CAD0 (0x18003CAD0)
    - sub_18003C970 (0x18003C970)

函数: sub_18003C970 (0x18003C970)
  调用以下函数:
    - sub_18003BF40 (0x18003BF40)
    - sub_180003F80 (0x180003F80)
    - sub_180004080 (0x180004080)
    - sub_18003C310 (0x18003C310)
    - sub_180006EF0 (0x180006EF0)
    - sub_180007790 (0x180007790)
    - sub_18003B590 (0x18003B590)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)

函数: sub_18003C310 (0x18003C310)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_18003C970 (0x18003C970)

函数: sub_18001A990 (0x18001A990)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180038A00 (0x180038A00)
    - sub_1800388B0 (0x1800388B0)
    - sub_180031DC0 (0x180031DC0)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)

函数: sub_180038A00 (0x180038A00)
  调用以下函数:
    - sub_180038060 (0x180038060)
  被以下函数调用:
    - sub_18001A990 (0x18001A990)

函数: sub_180038060 (0x180038060)
  调用以下函数:
    - sub_180007F60 (0x180007F60)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - sub_180007790 (0x180007790)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180038A00 (0x180038A00)
    - sub_1800388B0 (0x1800388B0)

函数: sub_1800388B0 (0x1800388B0)
  调用以下函数:
    - sub_180038060 (0x180038060)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18001A990 (0x18001A990)

函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x180022590)
  调用以下函数:
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
  被以下函数调用:
    - sub_1800311C0 (0x1800311C0)
    - sub_180031130 (0x180031130)

函数: sub_18000B980 (0x18000B980)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180030820 (0x180030820)
    - sub_18000DF40 (0x18000DF40)
    - sub_180030590 (0x180030590)
    - sub_180030DB0 (0x180030DB0)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: sub_180030820 (0x180030820)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - unknown_libname_2 (0x180032540)
    - sub_18000DF40 (0x18000DF40)
    - sub_180030E80 (0x180030E80)
    - sub_180031DC0 (0x180031DC0)
    - sub_180003F80 (0x180003F80)
    - sub_180004080 (0x180004080)
    - ?_Xbad_function_call@std@@YAXXZ (0x18004BD0C)
    - sub_18000C810 (0x18000C810)
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
    - sub_18000C030 (0x18000C030)
    - sub_180032550 (0x180032550)
    - sub_18000B7F0 (0x18000B7F0)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18000B980 (0x18000B980)

函数: sub_180030E80 (0x180030E80)
  调用以下函数:
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180030820 (0x180030820)
    - sub_18002FB00 (0x18002FB00)

函数: ?_Xbad_function_call@std@@YAXXZ (0x18004BD0C)
  被以下函数调用:
    - sub_180030820 (0x180030820)

函数: sub_18000C810 (0x18000C810)
  调用以下函数:
    - sub_180006BC0 (0x180006BC0)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180030820 (0x180030820)
    - sub_180031510 (0x180031510)
    - sub_180009D70 (0x180009D70)
    - sub_18002F8A0 (0x18002F8A0)

函数: sub_180006BC0 (0x180006BC0)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_18000C810 (0x18000C810)
    - sub_180031510 (0x180031510)

函数: sub_180030590 (0x180030590)
  被以下函数调用:
    - sub_18000B980 (0x18000B980)

函数: sub_180030DB0 (0x180030DB0)
  被以下函数调用:
    - sub_18000B980 (0x18000B980)

函数: sub_1800160E0 (0x1800160E0)
  调用以下函数:
    - sub_1800157C0 (0x1800157C0)
    - ?_Throw_C_error@std@@YAXH@Z (0x18004BD00)
    - _Mtx_lock (0x18004BCF4)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: sub_1800157C0 (0x1800157C0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ceilf (0x18004D12A)
    - sub_180015B90 (0x180015B90)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E)
  被以下函数调用:
    - sub_1800160E0 (0x1800160E0)

函数: ceilf (0x18004D12A)
  被以下函数调用:
    - sub_1800157C0 (0x1800157C0)
    - sub_18001C060 (0x18001C060)

函数: sub_180015B90 (0x180015B90)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E)
    - sub_18001AE10 (0x18001AE10)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - sub_180015AD0 (0x180015AD0)
  被以下函数调用:
    - sub_1800157C0 (0x1800157C0)

函数: sub_180015AD0 (0x180015AD0)
  被以下函数调用:
    - sub_180015B90 (0x180015B90)

函数: sub_18000DA40 (0x18000DA40)
  调用以下函数:
    - ?internal_push_move@concurrent_queue_base_v8@internal@tbb@@IEAAXPEBX@Z (0x18004BC04)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: ?internal_push_move@concurrent_queue_base_v8@internal@tbb@@IEAAXPEBX@Z (0x18004BC04)
  被以下函数调用:
    - sub_18000DA40 (0x18000DA40)

函数: sub_180004150 (0x180004150)
  调用以下函数:
    - sub_180004080 (0x180004080)
    - sub_1800367E0 (0x1800367E0)
    - sub_180003F80 (0x180003F80)
    - sub_180004330 (0x180004330)
    - sub_180036750 (0x180036750)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)
    - sub_18002EC30 (0x18002EC30)
    - sub_1800051B0 (0x1800051B0)

函数: sub_180004330 (0x180004330)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180004150 (0x180004150)

函数: sub_180036750 (0x180036750)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180004150 (0x180004150)

函数: sub_18002E370 (0x18002E370)
  调用以下函数:
    - sub_18001D820 (0x18001D820)
    - sub_18001AB80 (0x18001AB80)
    - sub_18001A360 (0x18001A360)
    - sub_18001A3A0 (0x18001A3A0)
    - sub_180006320 (0x180006320)
    - sub_180021470 (0x180021470)
    - sub_180032310 (0x180032310)
    - sub_180031510 (0x180031510)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: sub_18001D820 (0x18001D820)
  调用以下函数:
    - sub_1800065C0 (0x1800065C0)
    - sub_18001C060 (0x18001C060)
  被以下函数调用:
    - sub_180028220 (0x180028220)
    - sub_18002E370 (0x18002E370)
    - DispatchAssetProcessingTask (0x1800122F0)
    - sub_180028950 (0x180028950)
    - fxGetArtHandlesFromAsset (0x1800123D0)

函数: sub_1800065C0 (0x1800065C0)
  调用以下函数:
    - sub_18001A2C0 (0x18001A2C0)
    - sub_18001A320 (0x18001A320)
  被以下函数调用:
    - sub_18001D820 (0x18001D820)

函数: sub_18001A2C0 (0x18001A2C0)
  被以下函数调用:
    - sub_1800065C0 (0x1800065C0)
    - sub_180028950 (0x180028950)
    - sub_180004B80 (0x180004B80)
    - sub_1800211F0 (0x1800211F0)

函数: sub_18001A320 (0x18001A320)
  被以下函数调用:
    - sub_1800065C0 (0x1800065C0)
    - sub_180028950 (0x180028950)
    - sub_180004B80 (0x180004B80)
    - sub_1800211F0 (0x1800211F0)

函数: sub_18001C060 (0x18001C060)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18001FD60 (0x18001FD60)
    - ceilf (0x18004D12A)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E)
    - sub_18001DD90 (0x18001DD90)
  被以下函数调用:
    - sub_18001D820 (0x18001D820)

函数: sub_18001FD60 (0x18001FD60)
  调用以下函数:
  被以下函数调用:
    - sub_18001C060 (0x18001C060)

函数: sub_18001DD90 (0x18001DD90)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E)
    - sub_18001AE10 (0x18001AE10)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - sub_180015AD0 (0x180015AD0)
  被以下函数调用:
    - sub_18001C060 (0x18001C060)

函数: sub_18001AB80 (0x18001AB80)
  调用以下函数:
    - sub_180008570 (0x180008570)
  被以下函数调用:
    - sub_18002E370 (0x18002E370)

函数: sub_180008570 (0x180008570)
  被以下函数调用:
    - sub_18001AB80 (0x18001AB80)
    - sub_180004B80 (0x180004B80)
    - sub_18001A3A0 (0x18001A3A0)
    - sub_180042BC0 (0x180042BC0)
    - sub_1800064F0 (0x1800064F0)

函数: sub_18001A360 (0x18001A360)
  调用以下函数:
    - sub_180007340 (0x180007340)
  被以下函数调用:
    - sub_18002E370 (0x18002E370)

函数: sub_180007340 (0x180007340)
  调用以下函数:
    - sub_180007060 (0x180007060)
  被以下函数调用:
    - sub_18001A360 (0x18001A360)
    - sub_1800064F0 (0x1800064F0)
    - sub_180041F70 (0x180041F70)
    - sub_180004B80 (0x180004B80)

函数: sub_180007060 (0x180007060)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180007F60 (0x180007F60)
    - sub_180003F80 (0x180003F80)
    - sub_18001E230 (0x18001E230)
    - sub_180007790 (0x180007790)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180007340 (0x180007340)

函数: sub_18001A3A0 (0x18001A3A0)
  调用以下函数:
    - sub_180008570 (0x180008570)
  被以下函数调用:
    - sub_18002E370 (0x18002E370)

函数: sub_180006320 (0x180006320)
  被以下函数调用:
    - sub_18002E370 (0x18002E370)
    - DispatchAssetProcessingTask (0x1800122F0)

函数: sub_180021470 (0x180021470)
  调用以下函数:
    - sub_1800322F0 (0x1800322F0)
  被以下函数调用:
    - sub_18002E370 (0x18002E370)
    - DispatchAssetProcessingTask (0x1800122F0)
    - sub_180028220 (0x180028220)
    - sub_180028950 (0x180028950)

函数: sub_1800322F0 (0x1800322F0)
  被以下函数调用:
    - sub_180021470 (0x180021470)
    - sub_1800211F0 (0x1800211F0)

函数: sub_180032310 (0x180032310)
  调用以下函数:
    - sub_180036480 (0x180036480)
    - sub_180036B40 (0x180036B40)
    - sub_180014540 (0x180014540)
    - sub_180036A90 (0x180036A90)
  被以下函数调用:
    - sub_18002E370 (0x18002E370)
    - sub_180028220 (0x180028220)
    - sub_180028950 (0x180028950)

函数: sub_180014540 (0x180014540)
  调用以下函数:
    - sub_1800377C0 (0x1800377C0)
    - sub_1800367E0 (0x1800367E0)
    - sub_1800152C0 (0x1800152C0)
    - sub_180036580 (0x180036580)
    - __report_rangecheckfailure (0x18004C348)
    - memcpy (0x18004D0EE)
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180032310 (0x180032310)

函数: sub_1800377C0 (0x1800377C0)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180014540 (0x180014540)

函数: sub_1800152C0 (0x1800152C0)
  调用以下函数:
    - memcpy (0x18004D0EE)
    - sub_18001AE10 (0x18001AE10)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180006ED0)
    - memmove (0x18004D0F4)
  被以下函数调用:
    - sub_180014540 (0x180014540)

函数: sub_180036580 (0x180036580)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - sub_180012E90 (0x180012E90)
    - sub_180007790 (0x180007790)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180014540 (0x180014540)

函数: __report_rangecheckfailure (0x18004C348)
  调用以下函数:
  被以下函数调用:
    - sub_180014540 (0x180014540)

函数: sub_180031510 (0x180031510)
  调用以下函数:
    - sub_180039A20 (0x180039A20)
    - sub_180030600 (0x180030600)
    - sub_1800053C0 (0x1800053C0)
    - sub_180036480 (0x180036480)
    - sub_18002F5E0 (0x18002F5E0)
    - sub_180006BC0 (0x180006BC0)
    - sub_18002F8A0 (0x18002F8A0)
    - sub_18002FB00 (0x18002FB00)
    - sub_180003F80 (0x180003F80)
    - sub_180006E90 (0x180006E90)
    - sub_180006AB0 (0x180006AB0)
    - sub_180006B10 (0x180006B10)
    - sub_180007790 (0x180007790)
    - sub_180036A90 (0x180036A90)
    - sub_18000C810 (0x18000C810)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18002E370 (0x18002E370)

函数: sub_180039A20 (0x180039A20)
  调用以下函数:
    - sub_18002D6E0 (0x18002D6E0)
    - sub_18003A6A0 (0x18003A6A0)
    - sub_18002D9A0 (0x18002D9A0)
    - sub_18003DEA0 (0x18003DEA0)
    - sub_1800398C0 (0x1800398C0)
    - sub_180039760 (0x180039760)
    - sub_180039A20 (0x180039A20)
    - sub_180003F80 (0x180003F80)
    - sub_180007D50 (0x180007D50)
    - sub_180007790 (0x180007790)
    - sub_180039970 (0x180039970)
    - sub_18002D630 (0x18002D630)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180031510 (0x180031510)
    - sub_180039A20 (0x180039A20)
    - sub_18002CEE0 (0x18002CEE0)

函数: sub_18002D6E0 (0x18002D6E0)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)

函数: sub_18003A6A0 (0x18003A6A0)
  调用以下函数:
    - sub_180039760 (0x180039760)
    - sub_1800398C0 (0x1800398C0)
    - sub_18002D6E0 (0x18002D6E0)
    - sub_18003DEA0 (0x18003DEA0)
    - sub_180003F80 (0x180003F80)
    - sub_180007D50 (0x180007D50)
    - sub_180007790 (0x180007790)
    - sub_180039970 (0x180039970)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)

函数: sub_18002D9A0 (0x18002D9A0)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)

函数: sub_18003DEA0 (0x18003DEA0)
  调用以下函数:
    - sub_180007D50 (0x180007D50)
    - sub_180007790 (0x180007790)
    - sub_18002D6E0 (0x18002D6E0)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)

函数: sub_1800398C0 (0x1800398C0)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)

函数: sub_180039760 (0x180039760)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)

函数: sub_180007D50 (0x180007D50)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)
    - sub_180045EE0 (0x180045EE0)

函数: sub_180039970 (0x180039970)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)

函数: sub_18002D630 (0x18002D630)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180039A20 (0x180039A20)

函数: sub_180030600 (0x180030600)
  调用以下函数:
    - sub_180036480 (0x180036480)
    - sub_180006A00 (0x180006A00)
    - sub_180031D20 (0x180031D20)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
    - __security_check_cookie (0x18004C150)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180031510 (0x180031510)

函数: sub_180006A00 (0x180006A00)
  被以下函数调用:
    - sub_180030600 (0x180030600)
    - sub_18002BFB0 (0x18002BFB0)

函数: sub_1800053C0 (0x1800053C0)
  调用以下函数:
    - sub_180036B40 (0x180036B40)
  被以下函数调用:
    - sub_180031510 (0x180031510)
    - sub_180005350 (0x180005350)

函数: sub_18002F5E0 (0x18002F5E0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180030320 (0x180030320)
    - sub_180036480 (0x180036480)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18001AE10 (0x18001AE10)
    - sub_180036A90 (0x180036A90)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
  被以下函数调用:
    - sub_180031510 (0x180031510)

函数: sub_180030320 (0x180030320)
  被以下函数调用:
    - sub_18002F5E0 (0x18002F5E0)

函数: sub_18002F8A0 (0x18002F8A0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18000C810 (0x18000C810)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180031510 (0x180031510)

函数: sub_18002FB00 (0x18002FB00)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180030E80 (0x180030E80)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
    - sub_1800303D0 (0x1800303D0)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
  被以下函数调用:
    - sub_180031510 (0x180031510)

函数: sub_1800303D0 (0x1800303D0)
  被以下函数调用:
    - sub_18002FB00 (0x18002FB00)

函数: sub_180006E90 (0x180006E90)
  被以下函数调用:
    - sub_180031510 (0x180031510)
    - sub_180028950 (0x180028950)
    - sub_180023850 (0x180023850)
    - sub_1800243B0 (0x1800243B0)

函数: sub_180006AB0 (0x180006AB0)
  被以下函数调用:
    - sub_180031510 (0x180031510)
    - sub_180028950 (0x180028950)
    - sub_180023850 (0x180023850)

函数: sub_180006B10 (0x180006B10)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180031510 (0x180031510)

函数: sub_18002EC30 (0x18002EC30)
  调用以下函数:
    - sub_18001A580 (0x18001A580)
    - sub_180036480 (0x180036480)
    - sub_18001AE10 (0x18001AE10)
    - BuildExportFilePath (0x180004C90)
    - sub_180036A90 (0x180036A90)
    - sub_18002DC30 (0x18002DC30)
    - sub_180031130 (0x180031130)
    - sub_1800372B0 (0x1800372B0)
    - unknown_libname_2 (0x180032540)
    - sub_180036E50 (0x180036E50)
    - __security_check_cookie (0x18004C150)
    - sub_180031C50 (0x180031C50)
    - sub_18002DA50 (0x18002DA50)
    - sub_180032550 (0x180032550)
    - sub_180004150 (0x180004150)
    - sub_180006EF0 (0x180006EF0)
    - sub_18000DE70 (0x18000DE70)
    - sub_180032AF0 (0x180032AF0)
    - sub_18000D970 (0x18000D970)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: sub_18001A580 (0x18001A580)
  调用以下函数:
    - sub_18003BE50 (0x18003BE50)
    - __security_check_cookie (0x18004C150)
    - sub_18001E650 (0x18001E650)
    - sub_18001E3D0 (0x18001E3D0)
  被以下函数调用:
    - sub_18002EC30 (0x18002EC30)

函数: sub_18003BE50 (0x18003BE50)
  调用以下函数:
    - ceil (0x18004D13C)
  被以下函数调用:
    - sub_18001A580 (0x18001A580)

函数: ceil (0x18004D13C)
  被以下函数调用:
    - sub_18003BE50 (0x18003BE50)

函数: sub_18001E650 (0x18001E650)
  被以下函数调用:
    - sub_18001A580 (0x18001A580)

函数: sub_18001E3D0 (0x18001E3D0)
  调用以下函数:
    - sub_18001E3F0 (0x18001E3F0)
  被以下函数调用:
    - sub_18001A580 (0x18001A580)

函数: sub_18001E3F0 (0x18001E3F0)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18001E3D0 (0x18001E3D0)

函数: BuildExportFilePath (0x180004C90)
  调用以下函数:
    - sub_180036480 (0x180036480)
    - sub_180032600 (0x180032600)
    - sub_180032860 (0x180032860)
    - sub_1800067F0 (0x1800067F0)
    - sub_180036F90 (0x180036F90)
    - sub_1800051B0 (0x1800051B0)
    - sub_180032790 (0x180032790)
    - sub_1800364F0 (0x1800364F0)
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180028220 (0x180028220)
    - sub_18002EC30 (0x18002EC30)
    - sub_180028950 (0x180028950)
    - sub_180023850 (0x180023850)
    - sub_1800243B0 (0x1800243B0)

函数: sub_180032860 (0x180032860)
  调用以下函数:
    - sub_180032E90 (0x180032E90)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - BuildExportFilePath (0x180004C90)

函数: sub_1800067F0 (0x1800067F0)
  调用以下函数:
    - sub_180006EF0 (0x180006EF0)
  被以下函数调用:
    - BuildExportFilePath (0x180004C90)
    - sub_180005C10 (0x180005C10)

函数: sub_1800051B0 (0x1800051B0)
  调用以下函数:
    - unknown_libname_2 (0x180032540)
    - sub_180036B40 (0x180036B40)
    - GetExportSubfolderOrSuffix_0 (0x180006620)
    - sub_180037360 (0x180037360)
    - sub_180004150 (0x180004150)
    - sub_180032790 (0x180032790)
    - sub_180014350 (0x180014350)
    - sub_180036A90 (0x180036A90)
  被以下函数调用:
    - BuildExportFilePath (0x180004C90)

函数: GetExportSubfolderOrSuffix_0 (0x180006620)
  调用以下函数:
    - unknown_libname_2 (0x180032540)
    - sub_180037360 (0x180037360)
    - sub_180036B40 (0x180036B40)
    - sub_180036A90 (0x180036A90)
    - sub_180036E50 (0x180036E50)
    - sub_180036F90 (0x180036F90)
    - sub_180004150 (0x180004150)
  被以下函数调用:
    - sub_1800051B0 (0x1800051B0)

函数: sub_180037360 (0x180037360)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_1800051B0 (0x1800051B0)

函数: sub_180032790 (0x180032790)
  调用以下函数:
    - sub_180032E90 (0x180032E90)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_1800051B0 (0x1800051B0)
    - BuildExportFilePath (0x180004C90)

函数: sub_180014350 (0x180014350)
  调用以下函数:
    - sub_180014350 (0x180014350)
    - sub_180032550 (0x180032550)
    - sub_180032BF0 (0x180032BF0)
    - sub_180036A90 (0x180036A90)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_1800051B0 (0x1800051B0)

函数: sub_18002DC30 (0x18002DC30)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18001AE10 (0x18001AE10)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - memmove (0x18004D0F4)
  被以下函数调用:
    - sub_18002EC30 (0x18002EC30)

函数: sub_180031130 (0x180031130)
  调用以下函数:
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x180022590)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
  被以下函数调用:
    - sub_18002EC30 (0x18002EC30)

函数: sub_180036E50 (0x180036E50)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_18002EC30 (0x18002EC30)

函数: sub_180031C50 (0x180031C50)
  被以下函数调用:
    - sub_18002EC30 (0x18002EC30)

函数: sub_18002DA50 (0x18002DA50)
  调用以下函数:
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_180036480 (0x180036480)
    - sub_1800182F0 (0x1800182F0)
    - sub_18001AE10 (0x18001AE10)
    - sub_180036A90 (0x180036A90)
  被以下函数调用:
    - sub_18002EC30 (0x18002EC30)

函数: sub_1800182F0 (0x1800182F0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
  被以下函数调用:
    - sub_18002DA50 (0x18002DA50)
    - sub_18001E690 (0x18001E690)
    - sub_1800175C0 (0x1800175C0)

函数: sub_18000DE70 (0x18000DE70)
  被以下函数调用:
    - sub_18002EC30 (0x18002EC30)
    - sub_1800211F0 (0x1800211F0)

函数: sub_180032AF0 (0x180032AF0)
  调用以下函数:
    - unknown_libname_2 (0x180032540)
    - sub_180003F80 (0x180003F80)
    - sub_180012E90 (0x180012E90)
    - sub_180032E90 (0x180032E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180028220 (0x180028220)
    - sub_18003D5A0 (0x18003D5A0)
    - sub_18002EC30 (0x18002EC30)
    - sub_180023850 (0x180023850)
    - sub_1800243B0 (0x1800243B0)
    - sub_180028950 (0x180028950)

函数: sub_18000E230 (0x18000E230)
  调用以下函数:
    - sub_18001AE10 (0x18001AE10)
    - sub_18000C030 (0x18000C030)
    - sub_180036A90 (0x180036A90)
    - sub_180031DC0 (0x180031DC0)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: sub_180012D50 (0x180012D50)
  调用以下函数:
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180009D70 (0x180009D70)

函数: sub_180016BF0 (0x180016BF0)
  被以下函数调用:
    - fxExportAllArtboardsWithEntitlementCheck (0x180011750)

函数: sub_180028950 (0x180028950)
  调用以下函数:
    - sub_180032600 (0x180032600)
    - sub_18002CA00 (0x18002CA00)
    - sub_180037800 (0x180037800)
    - sub_18002A600 (0x18002A600)
    - sub_18001AE10 (0x18001AE10)
    - sub_18001D820 (0x18001D820)
    - sub_180028220 (0x180028220)
    - sub_180018A30 (0x180018A30)
    - sub_18001E230 (0x18001E230)
    - sub_18002C840 (0x18002C840)
    - sub_180026840 (0x180026840)
    - sub_180004840 (0x180004840)
    - sub_18003D250 (0x18003D250)
    - sub_180032460 (0x180032460)
    - sub_18002CC60 (0x18002CC60)
    - sub_180021470 (0x180021470)
    - sub_18000BC80 (0x18000BC80)
    - sub_180036480 (0x180036480)
    - sub_180036A90 (0x180036A90)
    - sub_180006E90 (0x180006E90)
    - BuildExportFilePath (0x180004C90)
    - sub_180027890 (0x180027890)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
    - sub_180027CA0 (0x180027CA0)
    - sub_180012EA0 (0x180012EA0)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180006AB0 (0x180006AB0)
    - sub_18002CEB0 (0x18002CEB0)
    - sub_18001A2C0 (0x18001A2C0)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_18000C4E0 (0x18000C4E0)
    - sub_18000E4E0 (0x18000E4E0)
    - sub_180032AF0 (0x180032AF0)
    - sub_180017CF0 (0x180017CF0)
    - sub_180006EF0 (0x180006EF0)
    - sub_1800064F0 (0x1800064F0)
    - sub_180026F00 (0x180026F00)
    - _Init_thread_header (0x18004BF04)
    - sub_180032310 (0x180032310)
    - sub_180013B10 (0x180013B10)
    - sub_180016310 (0x180016310)
    - sub_18003CD20 (0x18003CD20)
    - sub_180031D20 (0x180031D20)
    - sub_18001A320 (0x18001A320)
    - sub_18000BB30 (0x18000BB30)
    - sub_180037530 (0x180037530)
    - sub_18002C930 (0x18002C930)
    - sub_180017D30 (0x180017D30)
    - unknown_libname_2 (0x180032540)
    - sub_180025F40 (0x180025F40)
    - sub_180039540 (0x180039540)
    - sub_180032550 (0x180032550)
    - sub_18000AF50 (0x18000AF50)
    - __security_check_cookie (0x18004C150)
    - sub_180026D60 (0x180026D60)
    - sub_180039170 (0x180039170)
    - sub_18000B770 (0x18000B770)
    - sub_18000D970 (0x18000D970)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_1 (0x180013D70)
    - sub_180008580 (0x180008580)
    - sub_180004B80 (0x180004B80)
    - sub_180007790 (0x180007790)
    - sub_180026D90 (0x180026D90)
    - sub_18002B190 (0x18002B190)
    - sub_18003D590 (0x18003D590)
    - sub_18000DB90 (0x18000DB90)
    - sub_180013D90 (0x180013D90)
    - sub_180027590 (0x180027590)
    - sub_18003D5A0 (0x18003D5A0)
    - sub_18002BFB0 (0x18002BFB0)
    - sub_18003CDB0 (0x18003CDB0)
    - sub_1800271C0 (0x1800271C0)
    - sub_1800267D0 (0x1800267D0)
    - sub_180016BE0 (0x180016BE0)
    - sub_1800183E0 (0x1800183E0)
    - sub_1800047E0 (0x1800047E0)
    - sub_1800261E0 (0x1800261E0)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: sub_18002CA00 (0x18002CA00)
  调用以下函数:
    - sub_180006EF0 (0x180006EF0)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180028950 (0x180028950)
    - sub_180024C90 (0x180024C90)
    - sub_18002BBC0 (0x18002BBC0)

函数: sub_180037800 (0x180037800)
  调用以下函数:
    - sub_180007F60 (0x180007F60)
    - sub_180012E90 (0x180012E90)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180007F60 (0x180007F60)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180037800 (0x180037800)

函数: sub_18002A600 (0x18002A600)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18002CEE0 (0x18002CEE0)
    - sub_180036480 (0x180036480)
    - sub_1800233C0 (0x1800233C0)
    - sub_18000D970 (0x18000D970)
    - sub_18001AE10 (0x18001AE10)
    - sub_180036A90 (0x180036A90)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_18002CEE0 (0x18002CEE0)
  调用以下函数:
    - sub_180039A20 (0x180039A20)
    - sub_180036320 (0x180036320)
    - sub_180035940 (0x180035940)
    - sub_1800363C0 (0x1800363C0)
    - sub_180035AA0 (0x180035AA0)
    - sub_180035F90 (0x180035F90)
    - sub_1800359F0 (0x1800359F0)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_18002A600 (0x18002A600)

函数: sub_180036320 (0x180036320)
  调用以下函数:
    - sub_180036270 (0x180036270)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_18002CEE0 (0x18002CEE0)

函数: sub_180036270 (0x180036270)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180036320 (0x180036320)
    - sub_180035940 (0x180035940)
    - sub_180035AA0 (0x180035AA0)
    - sub_1800363C0 (0x1800363C0)
    - sub_180035F90 (0x180035F90)
    - sub_1800359F0 (0x1800359F0)

函数: sub_180035940 (0x180035940)
  调用以下函数:
    - sub_180036270 (0x180036270)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_18002CEE0 (0x18002CEE0)

函数: sub_1800363C0 (0x1800363C0)
  调用以下函数:
    - sub_180036270 (0x180036270)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_18002CEE0 (0x18002CEE0)

函数: sub_180035AA0 (0x180035AA0)
  调用以下函数:
    - sub_180036270 (0x180036270)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_18002CEE0 (0x18002CEE0)

函数: sub_180035F90 (0x180035F90)
  调用以下函数:
    - sub_180036270 (0x180036270)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_18002CEE0 (0x18002CEE0)

函数: sub_1800359F0 (0x1800359F0)
  调用以下函数:
    - sub_180036270 (0x180036270)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_18002CEE0 (0x18002CEE0)

函数: sub_1800233C0 (0x1800233C0)
  调用以下函数:
    - sub_180024C90 (0x180024C90)
    - sub_180025880 (0x180025880)
    - sub_180017D30 (0x180017D30)
    - sub_180027790 (0x180027790)
  被以下函数调用:
    - sub_18002A600 (0x18002A600)

函数: sub_180024C90 (0x180024C90)
  调用以下函数:
    - sub_180032600 (0x180032600)
    - sub_18002CA00 (0x18002CA00)
    - sub_180026D90 (0x180026D90)
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
    - sub_18003D590 (0x18003D590)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
    - sub_180031D20 (0x180031D20)
    - sub_18003CD20 (0x18003CD20)
    - sub_18003D5A0 (0x18003D5A0)
    - sub_18002B3B0 (0x18002B3B0)
    - sub_180017D30 (0x180017D30)
    - sub_180025F40 (0x180025F40)
    - unknown_libname_2 (0x180032540)
    - sub_1800267D0 (0x1800267D0)
    - sub_180023850 (0x180023850)
    - sub_180032550 (0x180032550)
    - __security_check_cookie (0x18004C150)
    - sub_1800261E0 (0x1800261E0)
    - sub_18000B870 (0x18000B870)
  被以下函数调用:
    - sub_1800233C0 (0x1800233C0)

函数: sub_18003D590 (0x18003D590)
  被以下函数调用:
    - sub_180024C90 (0x180024C90)
    - sub_180028950 (0x180028950)

函数: sub_18003CD20 (0x18003CD20)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
  被以下函数调用:
    - sub_180024C90 (0x180024C90)
    - sub_180028950 (0x180028950)

函数: sub_18003D5A0 (0x18003D5A0)
  调用以下函数:
    - sub_180032600 (0x180032600)
    - sub_180039300 (0x180039300)
    - sub_180042000 (0x180042000)
    - sub_180036A90 (0x180036A90)
    - sub_180042BC0 (0x180042BC0)
    - sub_180042EC0 (0x180042EC0)
    - sub_1800271C0 (0x1800271C0)
    - sub_1800425D0 (0x1800425D0)
    - sub_180039350 (0x180039350)
    - sub_180032550 (0x180032550)
    - __security_check_cookie (0x18004C150)
    - sub_18003D3E0 (0x18003D3E0)
    - sub_1800427E0 (0x1800427E0)
    - ?internal_push_back@concurrent_vector_base_v3@internal@tbb@@IEAAPEAX_KAEA_K@Z (0x18004BC6A)
    - sub_18003CC70 (0x18003CC70)
    - sub_180039170 (0x180039170)
    - sub_180041F70 (0x180041F70)
    - sub_180042F70 (0x180042F70)
    - sub_180032AF0 (0x180032AF0)
    - sub_180041070 (0x180041070)
  被以下函数调用:
    - sub_180024C90 (0x180024C90)
    - sub_180028950 (0x180028950)

函数: sub_180039300 (0x180039300)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_180042000 (0x180042000)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_180042BC0 (0x180042BC0)
  调用以下函数:
    - sub_180042EC0 (0x180042EC0)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - sub_180042210 (0x180042210)
    - sub_180008570 (0x180008570)
    - sub_180043BD0 (0x180043BD0)
    - sub_180041FB0 (0x180041FB0)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_180042EC0 (0x180042EC0)
  调用以下函数:
    - sub_180015740 (0x180015740)
    - sub_1800153F0 (0x1800153F0)
    - sub_180042F70 (0x180042F70)
    - sub_180015530 (0x180015530)
  被以下函数调用:
    - sub_180042BC0 (0x180042BC0)
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_180042210 (0x180042210)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180042BC0 (0x180042BC0)

函数: sub_180043BD0 (0x180043BD0)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180042BC0 (0x180042BC0)

函数: sub_180041FB0 (0x180041FB0)
  调用以下函数:
    - sub_180042210 (0x180042210)
    - sub_180008570 (0x180008570)
  被以下函数调用:
    - sub_180042BC0 (0x180042BC0)

函数: sub_1800271C0 (0x1800271C0)
  调用以下函数:
    - sub_180032460 (0x180032460)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)
    - sub_180028950 (0x180028950)
    - sub_18003D250 (0x18003D250)
    - sub_18003CDF0 (0x18003CDF0)
    - sub_18003CDB0 (0x18003CDB0)

函数: sub_1800425D0 (0x1800425D0)
  调用以下函数:
    - sub_180015740 (0x180015740)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_1800153F0 (0x1800153F0)
    - sub_18003A510 (0x18003A510)
    - sub_180042F70 (0x180042F70)
    - sub_180012E90 (0x180012E90)
    - sub_180015530 (0x180015530)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_180015740 (0x180015740)
  被以下函数调用:
    - sub_1800425D0 (0x1800425D0)
    - sub_1800427E0 (0x1800427E0)

函数: sub_1800153F0 (0x1800153F0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180003F80 (0x180003F80)
    - sub_180007790 (0x180007790)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_1800425D0 (0x1800425D0)
    - sub_1800427E0 (0x1800427E0)

函数: sub_18003A510 (0x18003A510)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - sub_180039A20 (0x180039A20)
    - sub_180007790 (0x180007790)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_1800425D0 (0x1800425D0)

函数: sub_180042F70 (0x180042F70)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - sub_18003A510 (0x18003A510)
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - ceil (0x18004D13C)
    - sub_180043BD0 (0x180043BD0)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
    - sub_180008570 (0x180008570)
    - sub_18001E3F0 (0x18001E3F0)
  被以下函数调用:
    - sub_1800425D0 (0x1800425D0)
    - sub_1800427E0 (0x1800427E0)
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_180015530 (0x180015530)
  调用以下函数:
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_1800425D0 (0x1800425D0)
    - sub_1800427E0 (0x1800427E0)

函数: sub_180039350 (0x180039350)
  调用以下函数:
    - sub_180032460 (0x180032460)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_18003D3E0 (0x18003D3E0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18003EB40 (0x18003EB40)
    - ?allocate@allocate_root_with_context_proxy@internal@tbb@@QEBAAEAVtask@3@_K@Z (0x18004BC40)
    - sub_18003CC70 (0x18003CC70)
    - ?init@task_group_context@tbb@@IEAAXXZ (0x18004BC58)
    - memset (0x18004D0FA)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_18003EB40 (0x18003EB40)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
  被以下函数调用:
    - sub_18003D3E0 (0x18003D3E0)

函数: ?allocate@allocate_root_with_context_proxy@internal@tbb@@QEBAAEAVtask@3@_K@Z (0x18004BC40)
  被以下函数调用:
    - sub_18003D3E0 (0x18003D3E0)

函数: sub_18003CC70 (0x18003CC70)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18003EB40 (0x18003EB40)
  被以下函数调用:
    - sub_18003D3E0 (0x18003D3E0)
    - sub_18003D5A0 (0x18003D5A0)

函数: ?init@task_group_context@tbb@@IEAAXXZ (0x18004BC58)
  被以下函数调用:
    - sub_18003D3E0 (0x18003D3E0)

函数: sub_1800427E0 (0x1800427E0)
  调用以下函数:
    - sub_180015740 (0x180015740)
    - sub_1800439A0 (0x1800439A0)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_1800153F0 (0x1800153F0)
    - sub_180042F70 (0x180042F70)
    - sub_180012E90 (0x180012E90)
    - sub_180015530 (0x180015530)
    - sub_18000D970 (0x18000D970)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_1800439A0 (0x1800439A0)
  调用以下函数:
    - sub_180035940 (0x180035940)
    - sub_180035AA0 (0x180035AA0)
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_1800359F0 (0x1800359F0)
    - sub_180035F90 (0x180035F90)
    - sub_180012E90 (0x180012E90)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_1800427E0 (0x1800427E0)

函数: ?internal_push_back@concurrent_vector_base_v3@internal@tbb@@IEAAPEAX_KAEA_K@Z (0x18004BC6A)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_180039170 (0x180039170)
  调用以下函数:
    - unknown_libname_2 (0x180032540)
    - sub_180038C40 (0x180038C40)
    - sub_180038CC0 (0x180038CC0)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)
    - sub_180028950 (0x180028950)
    - sub_180023850 (0x180023850)

函数: sub_180038C40 (0x180038C40)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
  被以下函数调用:
    - sub_180039170 (0x180039170)

函数: sub_180038CC0 (0x180038CC0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
  被以下函数调用:
    - sub_180039170 (0x180039170)

函数: sub_180041F70 (0x180041F70)
  调用以下函数:
    - sub_180007340 (0x180007340)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_180041070 (0x180041070)
  被以下函数调用:
    - sub_18003D5A0 (0x18003D5A0)

函数: sub_18002B3B0 (0x18002B3B0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18000B000 (0x18000B000)
    - sub_180026B40 (0x180026B40)
    - sub_18000B870 (0x18000B870)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180024C90 (0x180024C90)

函数: sub_180026B40 (0x180026B40)
  调用以下函数:
    - sub_180026260 (0x180026260)
    - sub_180031D20 (0x180031D20)
    - sub_180013B10 (0x180013B10)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_1 (0x180013D70)
    - sub_180027C30 (0x180027C30)
  被以下函数调用:
    - sub_18002B3B0 (0x18002B3B0)

函数: sub_180026260 (0x180026260)
  调用以下函数:
    - sub_180027C30 (0x180027C30)
  被以下函数调用:
    - sub_180026B40 (0x180026B40)

函数: sub_180013B10 (0x180013B10)
  被以下函数调用:
    - sub_180026B40 (0x180026B40)
    - sub_180028950 (0x180028950)
    - sub_18003D250 (0x18003D250)

函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_1 (0x180013D70)
  调用以下函数:
    - ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E)
  被以下函数调用:
    - sub_180026B40 (0x180026B40)
    - sub_180028950 (0x180028950)
    - sub_18003D250 (0x18003D250)

函数: sub_180027C30 (0x180027C30)
  被以下函数调用:
    - sub_180026B40 (0x180026B40)

函数: sub_180017D30 (0x180017D30)
  调用以下函数:
    - sub_1800175C0 (0x1800175C0)
    - sub_18000E3B0 (0x18000E3B0)
  被以下函数调用:
    - sub_180024C90 (0x180024C90)
    - sub_180028950 (0x180028950)
    - sub_1800243B0 (0x1800243B0)
    - sub_1800233C0 (0x1800233C0)

函数: sub_1800175C0 (0x1800175C0)
  调用以下函数:
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_180018240 (0x180018240)
    - sub_1800182F0 (0x1800182F0)
    - sub_180036A90 (0x180036A90)
    - sub_1800178F0 (0x1800178F0)
  被以下函数调用:
    - sub_180017D30 (0x180017D30)

函数: sub_180018240 (0x180018240)
  调用以下函数:
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_1800175C0 (0x1800175C0)

函数: sub_1800178F0 (0x1800178F0)
  调用以下函数:
    - sub_180036480 (0x180036480)
  被以下函数调用:
    - sub_1800175C0 (0x1800175C0)

函数: sub_18000E3B0 (0x18000E3B0)
  调用以下函数:
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180017D30 (0x180017D30)

函数: sub_180025F40 (0x180025F40)
  调用以下函数:
    - sub_18000E460 (0x18000E460)
    - sub_180026160 (0x180026160)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_180036A90 (0x180036A90)
    - sub_18001AE10 (0x18001AE10)
    - sub_18000B8D0 (0x18000B8D0)
  被以下函数调用:
    - sub_180028220 (0x180028220)
    - sub_180025880 (0x180025880)
    - sub_18002B4E0 (0x18002B4E0)
    - sub_180024C90 (0x180024C90)
    - sub_180028950 (0x180028950)

函数: sub_180026160 (0x180026160)
  调用以下函数:
    - sub_180036B40 (0x180036B40)
  被以下函数调用:
    - sub_180025F40 (0x180025F40)

函数: sub_180023850 (0x180023850)
  调用以下函数:
    - sub_180032600 (0x180032600)
    - sub_180036A90 (0x180036A90)
    - sub_180006E90 (0x180006E90)
    - sub_18002B190 (0x18002B190)
    - BuildExportFilePath (0x180004C90)
    - sub_180027890 (0x180027890)
    - sub_18002BFB0 (0x18002BFB0)
    - sub_180006AB0 (0x180006AB0)
    - sub_180036B40 (0x180036B40)
    - unknown_libname_2 (0x180032540)
    - sub_180039540 (0x180039540)
    - sub_180005350 (0x180005350)
    - sub_18003D250 (0x18003D250)
    - sub_180032550 (0x180032550)
    - __security_check_cookie (0x18004C150)
    - sub_1800326E0 (0x1800326E0)
    - sub_180032AF0 (0x180032AF0)
    - sub_180039170 (0x180039170)
    - sub_18003CDF0 (0x18003CDF0)
    - sub_180017CF0 (0x180017CF0)
  被以下函数调用:
    - sub_180024C90 (0x180024C90)

函数: sub_18002B190 (0x18002B190)
  调用以下函数:
    - unknown_libname_2 (0x180032540)
    - sub_180006080 (0x180006080)
    - sub_180038D40 (0x180038D40)
    - sub_1800394A0 (0x1800394A0)
    - sub_180039250 (0x180039250)
    - sub_180006170 (0x180006170)
    - sub_180027AB0 (0x180027AB0)
    - sub_180038FD0 (0x180038FD0)
    - sub_180027890 (0x180027890)
    - sub_180038E90 (0x180038E90)
    - sub_1800060B0 (0x1800060B0)
    - sub_180032550 (0x180032550)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180023850 (0x180023850)
    - sub_180028950 (0x180028950)

函数: sub_180006080 (0x180006080)
  调用以下函数:
    - sub_1800388B0 (0x1800388B0)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_180038D40 (0x180038D40)
  调用以下函数:
    - sub_180032460 (0x180032460)
    - sub_180038C40 (0x180038C40)
    - sub_180038CC0 (0x180038CC0)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_1800394A0 (0x1800394A0)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_180039250 (0x180039250)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_180006170 (0x180006170)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_180027AB0 (0x180027AB0)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_180038FD0 (0x180038FD0)
  调用以下函数:
    - sub_180032460 (0x180032460)
    - unknown_libname_2 (0x180032540)
    - sub_180038C40 (0x180038C40)
    - sub_180038CC0 (0x180038CC0)
    - sub_18003B680 (0x18003B680)
    - sub_18001E370 (0x18001E370)
    - sub_180036A90 (0x180036A90)
    - sub_18003CAD0 (0x18003CAD0)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_180027890 (0x180027890)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)
    - sub_1800261E0 (0x1800261E0)
    - sub_180028950 (0x180028950)
    - sub_180023850 (0x180023850)

函数: sub_180038E90 (0x180038E90)
  调用以下函数:
    - sub_180032460 (0x180032460)
    - sub_180038C40 (0x180038C40)
    - sub_180038CC0 (0x180038CC0)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_1800060B0 (0x1800060B0)
  调用以下函数:
    - sub_180038A00 (0x180038A00)
  被以下函数调用:
    - sub_18002B190 (0x18002B190)

函数: sub_18002BFB0 (0x18002BFB0)
  调用以下函数:
    - sub_180006A00 (0x180006A00)
    - sub_180031D20 (0x180031D20)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
    - __security_check_cookie (0x18004C150)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180023850 (0x180023850)
    - sub_180028950 (0x180028950)
    - sub_1800243B0 (0x1800243B0)

函数: sub_180039540 (0x180039540)
  被以下函数调用:
    - sub_180023850 (0x180023850)
    - sub_180028950 (0x180028950)

函数: sub_180005350 (0x180005350)
  调用以下函数:
    - sub_1800395D0 (0x1800395D0)
    - __security_check_cookie (0x18004C150)
    - sub_1800053C0 (0x1800053C0)
  被以下函数调用:
    - sub_180023850 (0x180023850)
    - sub_1800243B0 (0x1800243B0)

函数: sub_1800395D0 (0x1800395D0)
  调用以下函数:
    - sub_180039A20 (0x180039A20)
    - sub_180007D50 (0x180007D50)
    - sub_180039810 (0x180039810)
    - sub_180007790 (0x180007790)
  被以下函数调用:
    - sub_180005350 (0x180005350)

函数: sub_18003D250 (0x18003D250)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_1800271C0 (0x1800271C0)
    - sub_18003CF30 (0x18003CF30)
    - sub_180013B10 (0x180013B10)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_1 (0x180013D70)
  被以下函数调用:
    - sub_180023850 (0x180023850)
    - sub_180028950 (0x180028950)

函数: sub_18003CF30 (0x18003CF30)
  调用以下函数:
    - unknown_libname_2 (0x180032540)
    - sub_1800271C0 (0x1800271C0)
    - sub_180039350 (0x180039350)
    - sub_1800372B0 (0x1800372B0)
    - sub_180032BF0 (0x180032BF0)
    - sub_180036A90 (0x180036A90)
    - sub_180032550 (0x180032550)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_18003D250 (0x18003D250)

函数: sub_1800326E0 (0x1800326E0)
  调用以下函数:
    - sub_180032E90 (0x180032E90)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_180023850 (0x180023850)
    - sub_1800243B0 (0x1800243B0)

函数: sub_18003CDF0 (0x18003CDF0)
  调用以下函数:
    - sub_1800271C0 (0x1800271C0)
  被以下函数调用:
    - sub_180023850 (0x180023850)

函数: sub_180017CF0 (0x180017CF0)
  调用以下函数:
    - sub_180036480 (0x180036480)
  被以下函数调用:
    - sub_180023850 (0x180023850)
    - sub_180028220 (0x180028220)
    - sub_180028950 (0x180028950)
    - sub_1800243B0 (0x1800243B0)

函数: sub_1800261E0 (0x1800261E0)
  调用以下函数:
    - sub_1800261E0 (0x1800261E0)
    - sub_18001AE10 (0x18001AE10)
    - sub_180027890 (0x180027890)
  被以下函数调用:
    - sub_180024C90 (0x180024C90)
    - sub_1800261E0 (0x1800261E0)
    - sub_180028950 (0x180028950)

函数: sub_180025880 (0x180025880)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180025F40 (0x180025F40)
    - unknown_libname_2 (0x180032540)
    - sub_180032600 (0x180032600)
    - sub_18002BBC0 (0x18002BBC0)
    - sub_18002B810 (0x18002B810)
    - sub_18000CDB0 (0x18000CDB0)
    - sub_1800272D0 (0x1800272D0)
    - sub_180026D90 (0x180026D90)
    - sub_1800267D0 (0x1800267D0)
    - sub_180036A90 (0x180036A90)
    - sub_1800243B0 (0x1800243B0)
    - sub_180032550 (0x180032550)
    - sub_18001AE10 (0x18001AE10)
    - sub_18000B870 (0x18000B870)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
  被以下函数调用:
    - sub_1800233C0 (0x1800233C0)

函数: sub_18002BBC0 (0x18002BBC0)
  调用以下函数:
    - sub_18002CA00 (0x18002CA00)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180025880 (0x180025880)

函数: sub_18002B810 (0x18002B810)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18000B000 (0x18000B000)
    - sub_18000B3E0 (0x18000B3E0)
    - sub_18002C1F0 (0x18002C1F0)
    - sub_18000B870 (0x18000B870)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180025880 (0x180025880)
    - sub_18002B4E0 (0x18002B4E0)

函数: sub_1800272D0 (0x1800272D0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180025880 (0x180025880)

函数: sub_1800243B0 (0x1800243B0)
  调用以下函数:
    - sub_180036B40 (0x180036B40)
    - unknown_libname_2 (0x180032540)
    - sub_180032600 (0x180032600)
    - sub_1800326E0 (0x1800326E0)
    - sub_180006CE0 (0x180006CE0)
    - sub_180017E80 (0x180017E80)
    - sub_180004840 (0x180004840)
    - sub_18002BFB0 (0x18002BFB0)
    - sub_180005350 (0x180005350)
    - sub_180006E90 (0x180006E90)
    - BuildExportFilePath (0x180004C90)
    - sub_180005C10 (0x180005C10)
    - sub_180032AF0 (0x180032AF0)
    - sub_180017CF0 (0x180017CF0)
    - sub_180036A90 (0x180036A90)
    - sub_180032550 (0x180032550)
    - sub_180017D30 (0x180017D30)
  被以下函数调用:
    - sub_180025880 (0x180025880)

函数: sub_180006CE0 (0x180006CE0)
  调用以下函数:
    - sub_180004430 (0x180004430)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
    - sub_180004A90 (0x180004A90)
    - memmove (0x18004D0F4)
  被以下函数调用:
    - sub_1800243B0 (0x1800243B0)

函数: sub_180004430 (0x180004430)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - memcpy (0x18004D0EE)
  被以下函数调用:
    - sub_180006CE0 (0x180006CE0)

函数: sub_180004A90 (0x180004A90)
  调用以下函数:
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180006CE0 (0x180006CE0)

函数: sub_180017E80 (0x180017E80)
  被以下函数调用:
    - sub_1800243B0 (0x1800243B0)

函数: sub_180004840 (0x180004840)
  被以下函数调用:
    - sub_1800243B0 (0x1800243B0)
    - sub_180028950 (0x180028950)

函数: sub_180005C10 (0x180005C10)
  调用以下函数:
    - sub_1800067F0 (0x1800067F0)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
    - sub_180032BF0 (0x180032BF0)
    - sub_180036A90 (0x180036A90)
  被以下函数调用:
    - sub_1800243B0 (0x1800243B0)

函数: sub_180032BF0 (0x180032BF0)
  调用以下函数:
    - unknown_libname_2 (0x180032540)
    - sub_180003F80 (0x180003F80)
    - sub_180012E90 (0x180012E90)
    - sub_180032E90 (0x180032E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180005C10 (0x180005C10)

函数: sub_180027790 (0x180027790)
  被以下函数调用:
    - sub_1800233C0 (0x1800233C0)

函数: sub_180028220 (0x180028220)
  调用以下函数:
    - sub_180032600 (0x180032600)
    - sub_18000B000 (0x18000B000)
    - sub_180026D90 (0x180026D90)
    - sub_180036A90 (0x180036A90)
    - sub_180032310 (0x180032310)
    - BuildExportFilePath (0x180004C90)
    - sub_18001AE10 (0x18001AE10)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
    - sub_180031D20 (0x180031D20)
    - sub_18001D820 (0x18001D820)
    - unknown_libname_2 (0x180032540)
    - sub_180025F40 (0x180025F40)
    - sub_1800267D0 (0x1800267D0)
    - sub_180032550 (0x180032550)
    - sub_180016BE0 (0x180016BE0)
    - sub_180021470 (0x180021470)
    - sub_180032AF0 (0x180032AF0)
    - sub_180017CF0 (0x180017CF0)
    - sub_18000B870 (0x18000B870)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180016BE0 (0x180016BE0)
  被以下函数调用:
    - sub_180028220 (0x180028220)
    - DispatchAssetProcessingTask (0x1800122F0)
    - sub_180028950 (0x180028950)
    - fxGetArtHandlesFromAsset (0x1800123D0)

函数: sub_180018A30 (0x180018A30)
  调用以下函数:
    - sub_18000B770 (0x18000B770)
    - sub_18000B6F0 (0x18000B6F0)
    - sub_18000B870 (0x18000B870)
    - sub_18000B7F0 (0x18000B7F0)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_18001E230 (0x18001E230)
  调用以下函数:
    - sub_18001E2C0 (0x18001E2C0)
    - sub_180003F80 (0x180003F80)
    - _CxxThrowException (0x18004D0DC)
    - sub_180012E90 (0x180012E90)
  被以下函数调用:
    - sub_180028950 (0x180028950)
    - sub_180007420 (0x180007420)

函数: sub_18001E2C0 (0x18001E2C0)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_18001E230 (0x18001E230)

函数: sub_18002C840 (0x18002C840)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180026840 (0x180026840)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_18001AE10 (0x18001AE10)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - memmove (0x18004D0F4)
    - memset (0x18004D0FA)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_18002CC60 (0x18002CC60)
  调用以下函数:
    - sub_18000D970 (0x18000D970)
    - sub_18001AE10 (0x18001AE10)
    - sub_180031D20 (0x180031D20)
    - __security_check_cookie (0x18004C150)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180027CA0 (0x180027CA0)
  调用以下函数:
    - sub_180006EF0 (0x180006EF0)
    - sub_18001AE10 (0x18001AE10)
    - __security_check_cookie (0x18004C150)
    - sub_180012EA0 (0x180012EA0)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180012EA0 (0x180012EA0)
  调用以下函数:
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180027CA0 (0x180027CA0)
    - sub_180028950 (0x180028950)

函数: sub_18002CEB0 (0x18002CEB0)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_18002B4E0 (0x18002B4E0)
  调用以下函数:
    - sub_180031D20 (0x180031D20)
    - sub_180025F40 (0x180025F40)
    - sub_18002B810 (0x18002B810)
    - sub_180026D90 (0x180026D90)
    - sub_1800267D0 (0x1800267D0)
    - sub_180036A90 (0x180036A90)
    - sub_180026470 (0x180026470)
    - sub_18001AE10 (0x18001AE10)
    - sub_18000B870 (0x18000B870)
    - ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_18000E4E0 (0x18000E4E0)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_1800064F0 (0x1800064F0)
  调用以下函数:
    - sub_180007340 (0x180007340)
    - DispatchAssetProcessingTask (0x1800122F0)
    - sub_180007420 (0x180007420)
    - sub_180008570 (0x180008570)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: DispatchAssetProcessingTask (0x1800122F0)
  调用以下函数:
    - sub_180016BE0 (0x180016BE0)
    - sub_18001D820 (0x18001D820)
    - sub_180006320 (0x180006320)
    - sub_180021470 (0x180021470)
  被以下函数调用:
    - sub_1800064F0 (0x1800064F0)

函数: sub_180007420 (0x180007420)
  调用以下函数:
    - sub_18001E230 (0x18001E230)
  被以下函数调用:
    - sub_1800064F0 (0x1800064F0)
    - sub_180004B80 (0x180004B80)

函数: sub_180026F00 (0x180026F00)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180016310 (0x180016310)
  调用以下函数:
    - ?uncaught_exception@std@@YA_NXZ (0x18004BCE8)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: ?uncaught_exception@std@@YA_NXZ (0x18004BCE8)
  被以下函数调用:
    - sub_180016310 (0x180016310)
    - sub_180013D90 (0x180013D90)

函数: sub_180037530 (0x180037530)
  调用以下函数:
    - sub_180036EE0 (0x180036EE0)
    - sub_180031D20 (0x180031D20)
    - sub_180003F80 (0x180003F80)
    - memcpy (0x18004D0EE)
    - sub_180007790 (0x180007790)
    - sub_18000C030 (0x18000C030)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180006ED0)
    - ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0)
    - memmove (0x18004D0F4)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_18002C930 (0x18002C930)
  调用以下函数:
    - sub_180006EF0 (0x180006EF0)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180026D60 (0x180026D60)
  调用以下函数:
    - sub_1800269C0 (0x1800269C0)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_1800269C0 (0x1800269C0)
  调用以下函数:
    - __std_exception_copy (0x18004D0D0)
    - sub_180027050 (0x180027050)
    - sub_18002C780 (0x18002C780)
    - __std_exception_destroy (0x18004D0D6)
  被以下函数调用:
    - sub_180026D60 (0x180026D60)

函数: __std_exception_copy (0x18004D0D0)
  被以下函数调用:
    - sub_1800269C0 (0x1800269C0)
    - sub_180027050 (0x180027050)
    - sub_180027590 (0x180027590)

函数: sub_180027050 (0x180027050)
  调用以下函数:
    - __std_exception_copy (0x18004D0D0)
  被以下函数调用:
    - sub_1800269C0 (0x1800269C0)

函数: sub_18002C780 (0x18002C780)
  被以下函数调用:
    - sub_1800269C0 (0x1800269C0)

函数: __std_exception_destroy (0x18004D0D6)
  被以下函数调用:
    - sub_1800269C0 (0x1800269C0)

函数: sub_180008580 (0x180008580)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180004B80 (0x180004B80)
  调用以下函数:
    - sub_18001A2C0 (0x18001A2C0)
    - sub_18001A320 (0x18001A320)
    - sub_180007420 (0x180007420)
    - sub_180007340 (0x180007340)
    - sub_180008570 (0x180008570)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180013D90 (0x180013D90)
  调用以下函数:
    - ?uncaught_exception@std@@YA_NXZ (0x18004BCE8)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_180027590 (0x180027590)
  调用以下函数:
    - __std_exception_copy (0x18004D0D0)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_18003CDB0 (0x18003CDB0)
  调用以下函数:
    - sub_1800271C0 (0x1800271C0)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_1800183E0 (0x1800183E0)
  调用以下函数:
    - sub_18000E460 (0x18000E460)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - sub_180018860 (0x180018860)
    - sub_180036480 (0x180036480)
    - sub_18001A0C0 (0x18001A0C0)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_1800047E0 (0x1800047E0)
  调用以下函数:
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - sub_180028950 (0x180028950)

函数: sub_18000CFE0 (0x18000CFE0)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - fxGetArtHandlesFromAsset (0x1800123D0)
    - sub_18001AE10 (0x18001AE10)
    - sub_180012E90 (0x180012E90)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - DispatchSmartExport (0x18000FB90)

函数: fxGetArtHandlesFromAsset (0x1800123D0)
  调用以下函数:
    - sub_180016BE0 (0x180016BE0)
    - sub_18001D820 (0x18001D820)
    - sub_18001AE10 (0x18001AE10)
    - sub_18000D970 (0x18000D970)
    - sub_1800211F0 (0x1800211F0)
  被以下函数调用:
    - sub_18000CFE0 (0x18000CFE0)

函数: sub_1800211F0 (0x1800211F0)
  调用以下函数:
    - sub_180045EE0 (0x180045EE0)
    - sub_18001A2C0 (0x18001A2C0)
    - sub_180045D40 (0x180045D40)
    - sub_18001A320 (0x18001A320)
    - sub_1800322F0 (0x1800322F0)
    - sub_180045D30 (0x180045D30)
    - sub_18000DE70 (0x18000DE70)
    - sub_18001E690 (0x18001E690)
    - ??1PixelPartInfo@AIDE@@QEAA@XZ (0x1800089B0)
    - sub_18001AE10 (0x18001AE10)
  被以下函数调用:
    - fxGetArtHandlesFromAsset (0x1800123D0)

函数: sub_180045EE0 (0x180045EE0)
  调用以下函数:
    - sub_180003F80 (0x180003F80)
    - _Init_thread_header (0x18004BF04)
    - _Init_thread_footer (0x18004BEA4)
    - sub_180012E90 (0x180012E90)
    - sub_180039810 (0x180039810)
    - sub_180046430 (0x180046430)
    - sub_180007D50 (0x180007D50)
    - sub_180007790 (0x180007790)
    - __security_check_cookie (0x18004C150)
    - _CxxThrowException (0x18004D0DC)
  被以下函数调用:
    - sub_1800211F0 (0x1800211F0)

函数: sub_180039810 (0x180039810)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180045EE0 (0x180045EE0)

函数: sub_180046430 (0x180046430)
  调用以下函数:
    - sub_180012E90 (0x180012E90)
    - _Init_thread_footer (0x18004BEA4)
    - _Init_thread_header (0x18004BF04)
  被以下函数调用:
    - sub_180045EE0 (0x180045EE0)

函数: sub_180045D40 (0x180045D40)
  被以下函数调用:
    - sub_1800211F0 (0x1800211F0)

函数: sub_180045D30 (0x180045D30)
  被以下函数调用:
    - sub_1800211F0 (0x1800211F0)

函数: sub_18001E690 (0x18001E690)
  调用以下函数:
    - sub_18001AE10 (0x18001AE10)
    - sub_1800182F0 (0x1800182F0)
    - ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440)
    - memmove (0x18004D0F4)
  被以下函数调用:
    - sub_1800211F0 (0x1800211F0)

函数: ??1PixelPartInfo@AIDE@@QEAA@XZ (0x1800089B0)
  被以下函数调用:
    - sub_1800211F0 (0x1800211F0)

// ========== 伪代码 ==========
// ===== 函数: DispatchSmartExport (0x18000FB90) =====
// 函数分析报告: sub_18000FB90
// 分析时间: 2025-09-22 14:25:04.436896
// 目标函数: sub_18000FB90
// 
// 1. 函数高级概述
// sub_18000FB90 函数是资产导出功能的核心分发器，很可能隶属于 Adobe Illustrator 的“智能导出”(Smart Export) 功能模块。其主要职责是根据系统配置（功能开关或调试选项）来决定使用两种不同的导出路径之一：一种是**“快速资产导出”路径，另一种是“标准导出”**路径。
// 
// 该函数执行以下关键操作：
// 
// 权限验证：检查用户是否拥有使用“AI APP ENTITLEMENT SUITE”的权限。如果验证失败，则提前返回错误码。
// 
// 路径选择：通过检查名为 "SwitchToFastAssetExport" 的功能开关或名为 "Debug_AssetExportSwitch" 的首选项，决定执行路径。
// 
// 执行导出：根据选择的路径，调用相应的核心处理函数 (sub_180011750 或 sub_180028950) 来完成资产导出。
// 
// 资源管理：在标准路径下，负责初始化和管理一个进度处理器 (SmartExport::ProgressHandler)，用于向用户显示导出进度。
// 
// 2. 执行流程分析
// 该函数包含两个主要的逻辑分支：
// 
// 分支 A：快速资产导出路径 (Fast Asset Export Path)
// 此路径在以下条件满足时被激活：
// 
// 系统功能开关 "SwitchToFastAssetExport" 被启用。
// 
// 或者，调试首选项 "SmartExport" -> "Debug_AssetExportSwitch" 被设置。
// 
// 执行步骤：
// 
// 前置条件检查：调用 sub_18000BC80, sub_18000D200 和 sub_18000CFE0 等函数进行一系列的条件检查，确保系统状态适合执行快速导出。
// 
// 启动异步导出：如果所有检查通过，调用核心函数 sub_180011750。此函数很可能启动一个异步的导出任务。
// 
// 轮询等待：进入一个 do-while 循环，该循环使用 _Query_perf_counter 和 _Thrd_sleep 函数，以 100 毫秒为间隔，轮询检查导出任务是否完成。这表明快速路径可能没有详细的UI进度条，而是采用一种简单的等待机制。
// 
// 返回结果：任务完成后，返回 sub_180011750 的执行结果。
// 
// 分支 B：标准导出路径 (Standard Export Path)
// 如果快速导出路径的条件未满足，则执行此默认路径。
// 
// 执行步骤：
// 
// 初始化进度处理器：创建一个 SmartExport::ProgressHandler 对象实例。这表明标准路径会与用户界面（如进度条）进行交互，以提供详细的导出反馈。
// 
// 执行标准导出：调用核心处理函数 sub_180028950，并将初始化好的进度处理器作为参数传入。此函数负责执行标准的、带UI反馈的导出流程。
// 
// 资源清理：导出完成后，调用 sub_18000DB90 和 sub_18000C440 等函数来释放进度处理器和其他相关资源。
// 
// 返回结果：返回 sub_180028950 的执行结果。
// 
// 3. 关键调用函数分析
// sub_180011750 (快速导出核心函数)
// 
// 根据提供的描述，此函数用于统计资产中包含的独立图稿数量。然而，从其在 sub_18000FB90 中的用法来看，它的功能远不止于计数。它很可能启动一个异步的、无UI的导出过程，并通过回调或状态标志通知调用者任务已完成。
// 
// sub_180028950 (标准导出核心函数)
// 
// 这是一个大型且复杂的函数，是标准导出流程的主要实现。它接收一个进度处理器对象，表明其执行过程会与UI紧密集成，逐步向用户报告进度。
// 
// sub_18000D200 & sub_18000CFE0
// 
// 这两个函数在快速导出路径的开头被调用，返回布尔类型的值。它们很可能是前置条件检查函数，用于验证当前文档或资产状态是否满足快速导出的要求。
// 
// sub_18000BC80
// 
// 在进入快速导出路径前被调用，用于准备或复制与导出任务相关的数据结构。
// 
// ai::GetFeatureManager 和 gAIPreferenceSuite
// 
// 这些是对 Adobe Illustrator 核心套件的调用，分别用于查询系统级功能开关和用户配置的首选项，是决定执行路径的关键。
// 
// sub_1800122F0
// 
// 功能：用于分类整理当前所有的"可导出资产"。它遍历全局的资产列表，检查每一个资产的导出标记。如果资产被标记为待导出（标志位为1），则将其唯一ID添加到输出参数 a2 指向的列表中。如果资产未被标记（标志位为0），则将其ID添加到输出参数 a3 指向的列表中。
// 
// 作用：此函数是导出或删除等批量操作之前的数据准备步骤。
// 
// sub_180004C90
// 
// 功能：作为核心功能 fxCreateAsset 的一个安全包装层。它在 try...catch 块中调用真正的资产创建函数，以捕获并处理可能发生的任何异常，从而增强程序的健壮性。
// 
// 4. 结论
// sub_18000FB90 是一个设计精良的调度函数，它为资产导出提供了两种模式：一种是为自动化或后台任务设计的快速、非交互式模式，另一种是为用户操作设计的标准、带UI反馈的模式。这种双路径设计体现了软件在性能和用户体验之间的权衡，允许根据不同的使用场景选择最优的执行策略。函数的逻辑清晰，通过功能开关和首选项进行控制，具有良好的可扩展性和可维护性。
// 
// 1. 推荐命名
// 根据其作为“智能导出”功能的分发器和流程控制器的核心作用，以下是一些推荐的名称：
// 
// 主要推荐名称: DispatchSmartExport 或 智能导出调度函数
// 
// 理由: 这个名称最能体现其核心职责——它本身不执行具体的导出操作，而是根据条件（“调度”）来决定调用哪个子流程（快速路径或标准路径）来完成任务。
// 
// 备选名称:
// 
// ExecuteExportWithModeSelection (根据模式选择执行导出)
// 
// 理由: 强调了其内部根据功能开关或调试选项在不同导出模式间进行选择的关键逻辑。
// 
// SmartExportEntry (智能导出入口)
// 
// 理由: 表明这是“智能导出”功能的主要入口点。
// 
// 2. 参数分析 (sub_18000FB90(__int64 a1, __int64 a2))
// 参数 a1：文档句柄 (Document Handle)
// 推测类型: _t_AIDocument* 或 AIDocumentRef
// 
// 分析依据:
// 
// 传递路径: 参数 a1 被直接传递给下层核心函数，如 sub_180011750 和 sub_180028950。
// 
// Lambda 签名: 在函数 sub_18000FB90 的“快速导出路径”分支中，定义了一个 Lambda 表达式，其类型签名明确显示了第一个参数是 _t_AIDocument *。这是最强有力的证据。
// 
// C++
// 
// // Lambda类型签名的一部分，明确指出了文档指针类型
// std::_Func_impl_no_alloc<_lambda_8d6df5191765ee878e62fd07fc0bcca5_,void,_t_AIDocument *, ...>
// 功能需求: 任何导出操作都需要一个上下文环境，即需要知道从哪个文档中导出资产。因此，传入一个指向当前文档的指针或句柄是完全符合逻辑的。
// 
// 结论: a1 是一个指向当前活动文档对象的指针或句柄，用于在整个导出流程中提供文档上下文，以便访问和处理其中的图稿、图层和资产信息。
// 
// 参数 a2：导出设置结构体指针 (Export Settings Struct Pointer)
// 推测类型: ExportSettings* 或 SmartExportParameters*
// 
// 分析依据:
// 
// 成员访问模式: 在函数的“标准导出路径”分支中，代码通过固定偏移量来访问 a2 的内部数据，例如：
// 
// C++
// 
// // 这种通过偏移量访问数据的模式是典型的结构体或类成员访问
// *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8LL)
// *(_QWORD *)(a2 + 24)
// 这强烈暗示 a2 是一个指向复杂数据结构（如 C++ 的 struct 或 class）的指针。
// 
// 数据传递: 与 a1 类似，a2 也被 consistently 地传递给所有主要的子功能函数，如 sub_18000BC80, sub_180011750 和 sub_180028950。这表明它包含了整个导出任务所需的所有配置信息。
// 
// 功能需求: 一个完整的导出任务需要大量参数，例如：
// 
// 要导出的资产列表。
// 
// 目标文件格式（PNG, SVG, JPG 等）。
// 
// 导出尺寸/缩放比例。
// 
// 颜色配置文件。
// 
// 输出路径和命名规则。
// 
// 其他高级选项（如是否包含出血、是否创建子文件夹等）。
// 将这些参数打包在一个结构体中并通过指针传递是一种高效且常见的编程实践。
// 
// 结论: a2 是一个指向包含所有“智能导出”任务所需参数和设置的结构体或对象的指针。它定义了本次导出任务的**“做什么”和“如何做”**。
__int64 __fastcall DispatchSmartExport(__int64 **a1, __int64 a2)
{
  char v4; // bl
  __int64 v5; // rsi
  _QWORD *v6; // rax
  int v7; // eax
  _QWORD *v8; // rax
  unsigned int (__fastcall *v9)(_QWORD, _QWORD *); // r8
  char v10; // di
  __int64 v11; // rcx
  __int64 v13; // rdx
  void **v14; // r8
  __int64 v15; // rax
  _QWORD *v16; // rdx
  _QWORD *v17; // rdx
  unsigned int v18; // esi
  __int64 perf_frequency; // rbx
  __int64 perf_counter; // rax
  __int64 v21; // rax
  __int64 v22; // rdi
  __int64 v23; // rbx
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // rbx
  __int64 v28; // rcx
  __int64 v29; // rax
  double v30; // xmm0_8
  int v31; // r8d
  __int64 v32; // rax
  __int64 v33; // rdx
  unsigned __int64 v34; // rdx
  _QWORD *v35; // rdx
  _QWORD *v36; // rdx
  __time64_t v37; // rax
  unsigned __int64 v38; // rax
  void **sec; // r8
  __time64_t v40; // rdx
  __time64_t i; // rcx
  __int64 v42; // rcx
  __int64 j; // rax
  unsigned __int64 v44; // rbx
  unsigned __int64 v45; // rax
  volatile signed __int32 *v46; // rsi
  volatile signed __int32 *v47; // r14
  __time64_t v48; // rcx
  __int64 v49; // rdi
  __int64 v50; // rbx
  unsigned int v51; // ebx
  ai *v52; // rcx
  struct ai::IFeatureManager *FeatureManager; // rdi
  __int64 (__fastcall *v54)(struct ai::IFeatureManager *, _QWORD *); // rbx
  __int64 v55; // rdx
  void **v56; // r8
  char *v57; // rax
  __int64 v58; // rcx
  int v59; // [rsp+28h] [rbp-E0h] BYREF
  int v60; // [rsp+2Ch] [rbp-DCh] BYREF
  __int64 v61; // [rsp+30h] [rbp-D8h]
  volatile signed __int32 *v62; // [rsp+38h] [rbp-D0h]
  volatile signed __int32 *v63; // [rsp+40h] [rbp-C8h]
  __int128 v64; // [rsp+48h] [rbp-C0h] BYREF
  _QWORD v65[5]; // [rsp+58h] [rbp-B0h] BYREF
  __int16 v66; // [rsp+80h] [rbp-88h]
  _QWORD *v67; // [rsp+90h] [rbp-78h]
  __int128 v68; // [rsp+98h] [rbp-70h] BYREF
  __int64 v69; // [rsp+A8h] [rbp-60h]
  xtime *v70; // [rsp+B0h] [rbp-58h]
  xtime *v71; // [rsp+B8h] [rbp-50h]
  __int128 v72; // [rsp+C0h] [rbp-48h]
  _BYTE v73[56]; // [rsp+D0h] [rbp-38h] BYREF
  __int64 v74; // [rsp+108h] [rbp+0h]
  char v75[56]; // [rsp+110h] [rbp+8h] BYREF
  __int64 v76; // [rsp+148h] [rbp+40h]
  char v77[56]; // [rsp+158h] [rbp+50h] BYREF
  __int64 v78; // [rsp+190h] [rbp+88h]
  xtime v79; // [rsp+1A8h] [rbp+A0h] BYREF
  _QWORD v80[2]; // [rsp+1B8h] [rbp+B0h] BYREF
  __int64 v81; // [rsp+1C8h] [rbp+C0h]
  unsigned __int64 v82; // [rsp+1D0h] [rbp+C8h]
  _QWORD *v83; // [rsp+1F0h] [rbp+E8h]
  _QWORD v84[3]; // [rsp+1F8h] [rbp+F0h] BYREF
  unsigned __int64 v85; // [rsp+210h] [rbp+108h]
  _QWORD *v86; // [rsp+230h] [rbp+128h]
  _QWORD pExceptionObject[7]; // [rsp+238h] [rbp+130h] BYREF
  _QWORD *v88; // [rsp+270h] [rbp+168h]

  v69 = -2LL;
  v4 = 0;
  LODWORD(v61) = 0;
  v5 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  if ( dword_1800740A8 > *(_DWORD *)(v5 + 4) )
  {
    Init_thread_header(&dword_1800740A8);
    if ( dword_1800740A8 == -1 )
    {
      xmmword_180074088 = 0LL;
      qword_180074098 = (__int64)"AI APP ENTITLEMENT SUITE";
      dword_1800740A0 = 1;
      byte_1800740A4 = 0;
      Init_thread_footer(&dword_1800740A8);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074088 + 1) && qword_1800740D8 )
  {
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074098,
           (unsigned int)dword_1800740A0,
           (char *)&xmmword_180074088 + 8) )
    {
      *((_QWORD *)&xmmword_180074088 + 1) = 0LL;
    }
    else if ( !byte_1800740A4 )
    {
      v6 = sub_180012E90();
      *(_QWORD *)&xmmword_180074088 = *v6;
      *v6 = &xmmword_180074088;
    }
  }
  if ( !*((_QWORD *)&xmmword_180074088 + 1) )
    goto LABEL_17;
  if ( dword_1800740A8 > *(_DWORD *)(v5 + 4) )
  {
    Init_thread_header(&dword_1800740A8);
    if ( dword_1800740A8 == -1 )
    {
      xmmword_180074088 = 0LL;
      qword_180074098 = (__int64)"AI APP ENTITLEMENT SUITE";
      dword_1800740A0 = 1;
      byte_1800740A4 = 0;
      Init_thread_footer(&dword_1800740A8);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074088 + 1) && qword_1800740D8 )
  {
    v7 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074098,
           (unsigned int)dword_1800740A0,
           (char *)&xmmword_180074088 + 8);
    if ( v7 )
    {
      sub_180003F80((__int64)pExceptionObject, v7, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !byte_1800740A4 )
    {
      v8 = sub_180012E90();
      *(_QWORD *)&xmmword_180074088 = *v8;
      *v8 = &xmmword_180074088;
    }
  }
  v9 = (unsigned int (__fastcall *)(_QWORD, _QWORD *))**((_QWORD **)&xmmword_180074088 + 1);
  v84[0] = 0LL;
  v85 = 15LL;
  v84[2] = 0LL;
  v4 = 1;
  LODWORD(v61) = 1;
  if ( v9(0LL, v84) )
LABEL_17:
    v10 = 0;
  else
    v10 = 1;
  if ( (v4 & 1) != 0 && v85 >= 0x10 )
  {
    v11 = v84[0];
    if ( v85 + 1 >= 0x1000 )
    {
      v11 = *(_QWORD *)(v84[0] - 8LL);
      if ( (unsigned __int64)(v84[0] - v11 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10(v11);
  }
  if ( v10 )
    return 2110LL;
  if ( dword_180074080 > *(_DWORD *)(v5 + 4) )
  {
    Init_thread_header(&dword_180074080);
    if ( dword_180074080 == -1 )
    {
      FeatureManager = ai::GetFeatureManager(v52);
      v54 = *(__int64 (__fastcall **)(struct ai::IFeatureManager *, _QWORD *))(*(_QWORD *)FeatureManager + 8LL);
      v80[0] = 0LL;
      v81 = 0LL;
      v82 = 15LL;
      v57 = (char *)sub_180031D20((ai *)0x20, v55, v56);
      v81 = 23LL;
      v82 = 31LL;
      strcpy(v57, "SwitchToFastAssetExport");
      v80[0] = v57;
      byte_18007407C = v54(FeatureManager, v80);
      if ( v82 >= 0x10 )
      {
        v58 = v80[0];
        if ( v82 + 1 >= 0x1000 )
        {
          v58 = *(_QWORD *)(v80[0] - 8LL);
          if ( (unsigned __int64)(v80[0] - v58 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v58);
      }
      v81 = 0LL;
      v82 = 15LL;
      LOBYTE(v80[0]) = 0;
      Init_thread_footer(&dword_180074080);
    }
  }
  v60 = 0;
  (*(void (__fastcall **)(const char *, const char *, int *))gAIPreferenceSuite)(
    "SmartExport",
    "Debug_AssetExportSwitch",
    &v60);
  if ( (byte_18007407C || v60)
    && (v15 = sub_18000BC80((__int64)v77, a2), sub_18000D200(v15))
    && !sub_18000CFE0((__int64 *)a1) )
  {
    v83 = 0LL;
    v78 = 0LL;
    LOBYTE(v59) = 0;
    pExceptionObject[0] = &std::_Func_impl_no_alloc<_lambda_8d6df5191765ee878e62fd07fc0bcca5_,void,_t_AIDocument *,unsigned int,unsigned int,int,std::vector<ai::UnicodeString>>::`vftable';
    pExceptionObject[1] = &v59;
    v88 = pExceptionObject;
    v62 = (volatile signed __int32 *)v65;
    v67 = 0LL;
    v67 = std::_Func_impl_no_alloc<_lambda_8d6df5191765ee878e62fd07fc0bcca5_,void,_t_AIDocument *,unsigned int,unsigned int,int,std::vector<ai::UnicodeString>>::`vftable'(
            (__int64)pExceptionObject,
            v65);
    v62 = (volatile signed __int32 *)v84;
    v86 = 0LL;
    v74 = 0LL;
    sub_18000DF40((__int64)v73, (__int64)v84);
    v76 = 0LL;
    sub_18000DF40((__int64)v75, (__int64)v65);
    if ( v86 )
    {
      v16 = v84;
      LOBYTE(v16) = v86 != v84;
      (*(void (__fastcall **)(_QWORD *, _QWORD *))(*v86 + 32LL))(v86, v16);
      v86 = 0LL;
    }
    if ( v67 )
    {
      v17 = v65;
      LOBYTE(v17) = v67 != v65;
      (*(void (__fastcall **)(_QWORD *, _QWORD *))(*v67 + 32LL))(v67, v17);
      v67 = 0LL;
    }
    v18 = fxExportAllArtboardsWithEntitlementCheck((int)a1, a2, (__int64)v73, (__int64)v80);
    if ( !v18 && !(_BYTE)v59 )
    {
      do
      {
        perf_frequency = Query_perf_frequency();
        perf_counter = Query_perf_counter();
        if ( perf_frequency == 10000000 )
          v21 = 100 * perf_counter;
        else
          v21 = 1000000000 * (perf_counter / perf_frequency)
              + 1000000000 * (perf_counter % perf_frequency) / perf_frequency;
        v22 = v21 + 100000000;
        if ( v21 >= 0x7FFFFFFFFA0A1EFFLL )
          v22 = 0x7FFFFFFFFFFFFFFFLL;
        while ( 1 )
        {
          v23 = Query_perf_frequency();
          v24 = Query_perf_counter();
          if ( v23 == 10000000 )
          {
            v27 = 100 * v24;
          }
          else
          {
            v26 = 1000000000 * (v24 / v23);
            v25 = 1000000000 * (v24 % v23) % v23;
            v27 = 1000000000 * (v24 % v23) / v23 + v26;
          }
          if ( v27 >= v22 )
            break;
          v28 = 100 * Xtime_get_ticks();
          v29 = v22 - v27;
          v30 = (double)((int)v22 - (int)v27);
          v31 = v28 - 1391067136;
          if ( v30 <= 8.64e14 )
            v31 = v28 + v29;
          v32 = v28 + v29;
          v33 = v28 + 864000000000000LL;
          if ( v30 <= 8.64e14 )
            v33 = v32;
          v34 = (__int64)((unsigned __int128)(v33 * (__int128)0x112E0BE826D694B3LL) >> 64) >> 26;
          v79.sec = (v34 >> 63) + v34;
          v79.nsec = v31 - 1000000000 * LODWORD(v79.sec);
          Thrd_sleep(&v79);
        }
        (*(void (__fastcall **)(__int64, __int64, __int64))(gAIUserSuite + 144))(v26, v25, v24);
      }
      while ( !(_BYTE)v59 );
    }
    if ( v88 )
    {
      v35 = pExceptionObject;
      LOBYTE(v35) = v88 != pExceptionObject;
      (*(void (__fastcall **)(_QWORD *, _QWORD *))(*v88 + 32LL))(v88, v35);
      v88 = 0LL;
    }
    if ( v83 )
    {
      v36 = v80;
      LOBYTE(v36) = v83 != v80;
      (*(void (__fastcall **)(_QWORD *, _QWORD *))(*v83 + 32LL))(v83, v36);
    }
    return v18;
  }
  else
  {
    LOBYTE(v65[0]) = 0;
    if ( gAIDevUtilsSuite )
    {
      v65[1] = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
      v65[2] = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
    }
    v65[3] = "fxExportAssets";
    v65[4] = "SmartExport";
    v66 = 0;
    v72 = 0LL;
    v79 = 0LL;
    v70 = &v79;
    v71 = &v79;
    v37 = sub_180031D20((ai *)0x28, v13, v14);
    *(_QWORD *)v37 = v37;
    *(_QWORD *)(v37 + 8) = v37;
    *(_QWORD *)(v37 + 16) = v37;
    *(_WORD *)(v37 + 24) = 257;
    v79.sec = v37;
    v38 = sub_18000B220((unsigned __int64 *)&v79, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8LL), (void **)v37, v59);
    *(_QWORD *)(v79.sec + 8) = v38;
    *(_QWORD *)&v79.nsec = *(_QWORD *)(a2 + 24);
    sec = (void **)v79.sec;
    v40 = *(_QWORD *)(v79.sec + 8);
    if ( *(_BYTE *)(v40 + 25) )
    {
      *(_QWORD *)v79.sec = v79.sec;
      *(_QWORD *)(v79.sec + 16) = v79.sec;
    }
    else
    {
      for ( i = *(_QWORD *)v40; !*(_BYTE *)(i + 25); i = *(_QWORD *)i )
        v40 = i;
      *(_QWORD *)v79.sec = v40;
      v40 = v79.sec;
      v42 = *(_QWORD *)(v79.sec + 8);
      for ( j = *(_QWORD *)(v42 + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
        v42 = j;
      *(_QWORD *)(v79.sec + 16) = v42;
    }
    v44 = *(_QWORD *)&v79.nsec;
    v45 = sub_180031D20((ai *)0x90, v40, sec);
    v46 = (volatile signed __int32 *)v45;
    v62 = (volatile signed __int32 *)v45;
    if ( v45 )
    {
      *(_OWORD *)v45 = 0LL;
      *(_DWORD *)(v45 + 8) = 1;
      *(_DWORD *)(v45 + 12) = 1;
      *(_QWORD *)v45 = &std::_Ref_count_obj2<SmartExport::ProgressHandler>::`vftable';
      v68 = 0LL;
      sub_180017990(v45 + 16, v44, &v68);
    }
    else
    {
      v46 = 0LL;
    }
    v47 = v46 + 4;
    v62 = v46 + 4;
    v63 = v46;
    v48 = v79.sec;
    v49 = *(_QWORD *)(v79.sec + 8);
    if ( !*(_BYTE *)(v49 + 25) )
    {
      do
      {
        sub_18000B770((__int64)&v79, (__int64)&v79, *(_QWORD *)(v49 + 16));
        v50 = v49;
        v49 = *(_QWORD *)v49;
        sub_180032550((_QWORD *)(v50 + 32));
        sub_18001AE10(v50);
      }
      while ( !*(_BYTE *)(v49 + 25) );
      v48 = v79.sec;
    }
    sub_18001AE10(v48);
    v64 = 0LL;
    if ( v46 )
    {
      _InterlockedIncrement(v46 + 2);
      v47 = v62;
    }
    *(_QWORD *)&v64 = v47;
    *((_QWORD *)&v64 + 1) = v46;
    v51 = sub_180028950(a1, a2, (__int64 *)&v64);
    if ( v46 )
      sub_18000DB90(v46);
    sub_18000C440((__int64)v65);
    return v51;
  }
}


// ===== 函数: sub_18000D200 (0x18000D200) =====
_BOOL8 __fastcall sub_18000D200(__int64 a1)
{
  int v2; // r8d
  __int64 *v3; // rcx
  __int64 **v4; // rax
  __int64 *i; // rax
  __int64 *j; // rdx
  bool v7; // si
  __int64 v8; // r8
  _QWORD *v9; // rdi
  _QWORD *v10; // rbx
  __int64 v11; // rax
  __int128 v13; // [rsp+28h] [rbp-30h] BYREF
  __int64 v14; // [rsp+38h] [rbp-20h]

  v13 = 0LL;
  v14 = 0LL;
  sub_18002DF30(a1, (__int64)&v13);
  v2 = 0;
  v3 = **(__int64 ***)(a1 + 48);
  while ( !*((_BYTE *)v3 + 25) )
  {
    v2 += (v3[6] - v3[5]) / 40;
    v4 = (__int64 **)v3[2];
    if ( *((_BYTE *)v4 + 25) )
    {
      for ( i = (__int64 *)v3[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( v3 != (__int64 *)i[2] )
          break;
        v3 = i;
      }
      v3 = i;
    }
    else
    {
      v3 = (__int64 *)v3[2];
      for ( j = *v4; !*((_BYTE *)j + 25); j = (__int64 *)*j )
        v3 = j;
    }
  }
  v7 = v2 == 0;
  v8 = v13;
  if ( (_QWORD)v13 )
  {
    v9 = (_QWORD *)*((_QWORD *)&v13 + 1);
    if ( (_QWORD)v13 != *((_QWORD *)&v13 + 1) )
    {
      v10 = (_QWORD *)(v13 + 8);
      do
      {
        sub_180036A90(v10 + 1);
        sub_180036A90(v10);
        v10 += 5;
      }
      while ( v10 - 1 != v9 );
      v8 = v13;
    }
    v11 = v8;
    if ( (unsigned __int64)(40 * ((v14 - v8) / 40)) >= 0x1000 )
    {
      v8 = *(_QWORD *)(v8 - 8);
      if ( (unsigned __int64)(v11 - v8 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10(v8);
    v13 = 0LL;
    v14 = 0LL;
  }
  sub_18000C4E0((_QWORD *)a1);
  return v7;
}


// ===== 函数: sub_18002DF30 (0x18002DF30) =====
__int64 __fastcall sub_18002DF30(__int64 a1, __int64 a2)
{
  char v2; // bl
  char *v3; // r15
  __int64 *v5; // r12
  __int64 v6; // rsi
  unsigned __int8 v7; // r8
  __int64 v8; // rdx
  __int64 result; // rax
  char v10; // r9
  __int64 *v11; // rcx
  __int64 v12; // rdi
  __int64 v13; // rax
  _QWORD *v14; // rbp
  __int64 v15; // r14
  _QWORD *v16; // rdi
  int v17; // [rsp+20h] [rbp-48h]
  char v18; // [rsp+80h] [rbp+18h] BYREF
  __int64 v19; // [rsp+88h] [rbp+20h] BYREF

  v2 = v18;
  v3 = (char *)&unk_1800592D8;
  v5 = (__int64 *)(a1 + 48);
  do
  {
    v6 = *v5;
    v7 = *v3;
    v8 = v6;
    v18 = *v3;
    result = *(_QWORD *)(v6 + 8);
    v10 = *(_BYTE *)(result + 25);
    if ( !v10 )
    {
      v11 = *(__int64 **)(v6 + 8);
      do
      {
        if ( *((_BYTE *)v11 + 32) >= v7 )
        {
          v8 = (__int64)v11;
          v11 = (__int64 *)*v11;
        }
        else
        {
          v11 = (__int64 *)v11[2];
        }
      }
      while ( !*((_BYTE *)v11 + 25) );
    }
    if ( !*(_BYTE *)(v8 + 25) && v7 >= *(_BYTE *)(v8 + 32) && v8 != v6 )
    {
      if ( !v10 )
      {
        do
        {
          if ( *(_BYTE *)(result + 32) >= v7 )
          {
            v6 = result;
            result = *(_QWORD *)result;
          }
          else
          {
            result = *(_QWORD *)(result + 16);
          }
        }
        while ( !*(_BYTE *)(result + 25) );
      }
      if ( *(_BYTE *)(v6 + 25) || v7 < *(_BYTE *)(v6 + 32) )
      {
        std::_Xout_of_range("invalid map<K, T> key");
        JUMPOUT(0x18002E0ADLL);
      }
      v12 = *(_QWORD *)(v6 + 48);
      sub_180026D90(&v19, *(_QWORD *)(v6 + 40), v12);
      if ( v19 != v12 )
      {
        v13 = sub_1800267D0(v12, *(_QWORD *)(v6 + 48), v19);
        v14 = *(_QWORD **)(v6 + 48);
        v15 = v13;
        if ( (_QWORD *)v13 != v14 )
        {
          v16 = (_QWORD *)(v13 + 8);
          do
          {
            sub_180036A90(v16 + 1);
            sub_180036A90(v16);
            v16 += 5;
          }
          while ( v16 - 1 != v14 );
        }
        *(_QWORD *)(v6 + 48) = v15;
      }
      LOBYTE(v17) = v2;
      sub_180026470(a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(v6 + 40), *(_QWORD *)(v6 + 48), v17);
      result = sub_18002F200(v5, &v18);
    }
    ++v3;
  }
  while ( v3 != (char *)&unk_1800592DF );
  return result;
}


// ===== 函数: sub_18002F200 (0x18002F200) =====
__int64 __fastcall sub_18002F200(__int64 **a1, unsigned __int8 *a2)
{
  __int64 *v2; // rdi
  __int64 *m; // rbx
  __int64 *v6; // rsi
  __int64 v7; // r9
  __int64 v8; // rax
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // cl
  __int64 v11; // rax
  __int64 v12; // rbp
  __int64 *j; // rax
  __int64 **v14; // rcx
  __int64 i; // rcx
  __int64 *v16; // rdx
  __int64 v17; // r8
  __int64 *v18; // rdx
  __int64 v19; // rax
  __int64 *k; // rcx
  __int64 v21; // rcx
  __int64 *v22; // rax
  __int64 v23; // rcx
  __int64 *v24; // rcx
  __int64 *v25; // rdi

  v2 = *a1;
  m = *a1;
  v6 = *a1;
  v7 = (*a1)[1];
  v8 = v7;
  if ( !*(_BYTE *)(v7 + 25) )
  {
    v9 = *a2;
    do
    {
      v10 = *(_BYTE *)(v8 + 32);
      if ( v10 >= v9 )
      {
        if ( *((_BYTE *)v6 + 25) && v9 < v10 )
          v6 = (__int64 *)v8;
        m = (__int64 *)v8;
        v8 = *(_QWORD *)v8;
      }
      else
      {
        v8 = *(_QWORD *)(v8 + 16);
      }
    }
    while ( !*(_BYTE *)(v8 + 25) );
  }
  v11 = v7;
  if ( !*((_BYTE *)v6 + 25) )
    v11 = *v6;
  while ( !*(_BYTE *)(v11 + 25) )
  {
    if ( *a2 >= *(_BYTE *)(v11 + 32) )
    {
      v11 = *(_QWORD *)(v11 + 16);
    }
    else
    {
      v6 = (__int64 *)v11;
      v11 = *(_QWORD *)v11;
    }
  }
  v12 = 0LL;
  j = m;
  while ( j != v6 )
  {
    v14 = (__int64 **)j[2];
    ++v12;
    if ( *((_BYTE *)v14 + 25) )
    {
      for ( i = j[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( j != *(__int64 **)(i + 16) )
          break;
        j = (__int64 *)i;
      }
      j = (__int64 *)i;
    }
    else
    {
      v16 = *v14;
      for ( j = (__int64 *)j[2]; !*((_BYTE *)v16 + 25); v16 = (__int64 *)*v16 )
        j = v16;
    }
  }
  if ( m == (__int64 *)*v2 && *((_BYTE *)v6 + 25) )
  {
    sub_18000B6F0((__int64)a1, (__int64)a1, v7);
    v2[1] = (__int64)v2;
    *v2 = (__int64)v2;
    v2[2] = (__int64)v2;
    a1[1] = 0LL;
  }
  else
  {
    while ( m != v6 )
    {
      v17 = m[2];
      v18 = m;
      if ( *(_BYTE *)(v17 + 25) )
      {
        v19 = m[1];
        for ( k = m + 1; !*(_BYTE *)(v19 + 25); v19 = *(_QWORD *)(v19 + 8) )
        {
          if ( m != *(__int64 **)(v19 + 16) )
            break;
          m = (__int64 *)v19;
        }
        v21 = *k;
        m = (__int64 *)v19;
        if ( !*(_BYTE *)(v21 + 25) )
        {
          v22 = v18;
          do
          {
            if ( v22 != *(__int64 **)(v21 + 16) )
              break;
            v22 = (__int64 *)v21;
            v21 = *(_QWORD *)(v21 + 8);
          }
          while ( !*(_BYTE *)(v21 + 25) );
        }
      }
      else
      {
        v23 = *(_QWORD *)v17;
        for ( m = (__int64 *)m[2]; !*(_BYTE *)(v23 + 25); v23 = *(_QWORD *)v23 )
          m = (__int64 *)v23;
        v24 = *(__int64 **)v17;
        if ( !*(_BYTE *)(*(_QWORD *)v17 + 25LL) )
        {
          do
            v24 = (__int64 *)*v24;
          while ( !*((_BYTE *)v24 + 25) );
        }
      }
      v25 = sub_18002C1F0(a1, v18);
      sub_18000DFF0(v25 + 5);
      sub_18001AE10((__int64)v25);
    }
  }
  return v12;
}


// ===== 函数: sub_18000B6F0 (0x18000B6F0) =====
__int64 __fastcall sub_18000B6F0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*(_BYTE *)(i + 25); result = sub_18001AE10(v6) )
  {
    sub_18000B6F0(a1, a2, *(_QWORD *)(i + 16));
    v6 = i;
    i = *(_QWORD *)i;
    sub_18000DFF0(v6 + 40);
  }
  return result;
}


// ===== 函数: sub_18001AE10 (0x18001AE10) =====
// attributes: thunk
__int64 __fastcall sub_18001AE10(__int64 a1)
{
  return sub_180031DC0(a1);
}


// ===== 函数: sub_18000DFF0 (0x18000DFF0) =====
__int64 __fastcall sub_18000DFF0(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 i; // rsi
  __int64 v4; // r8
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != i; v1 += 40LL )
    {
      sub_180036A90((_QWORD *)(v1 + 16));
      sub_180036A90((_QWORD *)(v1 + 8));
    }
    v4 = *a1;
    if ( (unsigned __int64)(40 * ((a1[2] - *a1) / 40)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_18001AE10(v4);
    result = 0LL;
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }
  return result;
}


// ===== 函数: sub_180036A90 (0x180036A90) =====
void __fastcall sub_180036A90(_QWORD *a1)
{
  __int128 *v2; // rax
  __int128 *v3; // rbx
  _QWORD *v4; // rax
  __int128 *v5; // rax
  __int64 v6; // rax

  if ( *a1 )
  {
    v2 = sub_180036EE0();
    v3 = v2;
    if ( !*((_QWORD *)v2 + 1) && qword_1800740D8 )
    {
      if ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
             *((_QWORD *)v2 + 2),
             *((unsigned int *)v2 + 6),
             (__int64)v2 + 8) )
      {
        *((_QWORD *)v3 + 1) = 0LL;
      }
      else if ( !*((_BYTE *)v3 + 28) )
      {
        v4 = sub_180012E90();
        *(_QWORD *)v3 = *v4;
        *v4 = v3;
      }
    }
    if ( *((_QWORD *)v3 + 1) )
    {
      v5 = sub_180036EE0();
      v6 = sub_180007790((__int64)v5);
      (*(void (__fastcall **)(_QWORD *))(v6 + 24))(a1);
    }
  }
}


// ===== 函数: sub_180036EE0 (0x180036EE0) =====
__int128 *sub_180036EE0()
{
  __int64 v1; // rcx
  _QWORD *v2; // rax

  if ( dword_180074620 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180074600;
  Init_thread_header(&dword_180074620);
  if ( dword_180074620 != -1 )
    return &xmmword_180074600;
  xmmword_180074600 = 0LL;
  qword_180074610 = (__int64)"AI Unicode String Suite";
  dword_180074618 = 9;
  byte_18007461C = 1;
  v2 = (_QWORD *)sub_180012E90(v1);
  *(_QWORD *)&xmmword_180074600 = *v2;
  *v2 = &xmmword_180074600;
  Init_thread_footer(&dword_180074620);
  return &xmmword_180074600;
}


// ===== 函数: sub_180012E90 (0x180012E90) =====
void *sub_180012E90()
{
  return &unk_1800740E0;
}


// ===== 函数: sub_180007790 (0x180007790) =====
__int64 __fastcall sub_180007790(__int64 a1)
{
  int v2; // eax
  _QWORD *v3; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  if ( !*(_QWORD *)(a1 + 8) && qword_1800740D8 )
  {
    v2 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *(_QWORD *)(a1 + 16),
           *(unsigned int *)(a1 + 24),
           a1 + 8);
    if ( v2 )
    {
      sub_180003F80((__int64)pExceptionObject, v2, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*(_BYTE *)(a1 + 28) )
    {
      v3 = sub_180012E90();
      *(_QWORD *)a1 = *v3;
      *v3 = a1;
    }
  }
  return *(_QWORD *)(a1 + 8);
}


// ===== 函数: sub_18002C1F0 (0x18002C1F0) =====
__int64 *__fastcall sub_18002C1F0(_QWORD *a1, __int64 *a2)
{
  __int64 *v2; // rax
  __int64 *v3; // r9
  __int64 *v5; // r14
  __int64 ***i; // r8
  __int64 *v7; // rdx
  __int64 *v8; // rdi
  __int64 **v9; // rbx
  __int64 **v10; // rdx
  __int64 *v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 *j; // rcx
  __int64 **v15; // rcx
  char v16; // dl
  __int64 **v17; // r10
  __int64 *v18; // rcx
  __int64 ***v19; // rcx
  __int64 ***v20; // rdx
  __int64 ***v21; // rax
  __int64 *v22; // rcx
  __int64 v23; // rax
  __int64 **v24; // rax
  __int64 v25; // r8
  __int64 v26; // rcx
  __int64 *result; // rax

  v2 = (__int64 *)a2[2];
  v3 = a2 + 2;
  v5 = a2;
  if ( *((_BYTE *)v2 + 25) )
  {
    v2 = (__int64 *)a2[1];
    for ( i = (__int64 ***)(a2 + 1); !*((_BYTE *)v2 + 25); v2 = (__int64 *)v2[1] )
    {
      if ( a2 != (__int64 *)v2[2] )
        break;
      a2 = v2;
    }
  }
  else
  {
    v7 = (__int64 *)*v2;
    if ( !*(_BYTE *)(*v2 + 25) )
    {
      do
      {
        v2 = v7;
        v7 = (__int64 *)*v7;
      }
      while ( !*((_BYTE *)v7 + 25) );
    }
    i = (__int64 ***)(v5 + 1);
  }
  v8 = (__int64 *)*v3;
  if ( *(_BYTE *)(*v5 + 25) )
    goto LABEL_13;
  if ( *((_BYTE *)v8 + 25) )
  {
    v8 = (__int64 *)*v5;
LABEL_13:
    v9 = *i;
    if ( !*((_BYTE *)v8 + 25) )
      v8[1] = (__int64)v9;
    if ( *(__int64 **)(*a1 + 8LL) == v5 )
    {
      *(_QWORD *)(*a1 + 8LL) = v8;
    }
    else if ( *v9 == v5 )
    {
      *v9 = v8;
    }
    else
    {
      v9[2] = v8;
    }
    if ( *(__int64 **)*a1 == v5 )
    {
      if ( *((_BYTE *)v8 + 25) )
      {
        v10 = v9;
      }
      else
      {
        v11 = (__int64 *)*v8;
        v10 = (__int64 **)v8;
        if ( !*(_BYTE *)(*v8 + 25) )
        {
          do
          {
            v10 = (__int64 **)v11;
            v11 = (__int64 *)*v11;
          }
          while ( !*((_BYTE *)v11 + 25) );
        }
      }
      *(_QWORD *)*a1 = v10;
    }
    v12 = *a1;
    if ( *(__int64 **)(*a1 + 16LL) == v5 )
    {
      if ( *((_BYTE *)v8 + 25) )
      {
        *(_QWORD *)(v12 + 16) = v9;
      }
      else
      {
        v13 = v8[2];
        for ( j = v8; !*(_BYTE *)(v13 + 25); v13 = *(_QWORD *)(v13 + 16) )
          j = (__int64 *)v13;
        *(_QWORD *)(v12 + 16) = j;
      }
    }
    goto LABEL_43;
  }
  v8 = (__int64 *)v2[2];
  if ( v2 == v5 )
    goto LABEL_13;
  *(_QWORD *)(*v5 + 8) = v2;
  *v2 = *v5;
  if ( v2 == (__int64 *)*v3 )
  {
    v9 = (__int64 **)v2;
  }
  else
  {
    v9 = (__int64 **)v2[1];
    if ( !*((_BYTE *)v8 + 25) )
      v8[1] = (__int64)v9;
    *v9 = v8;
    v2[2] = *v3;
    *(_QWORD *)(*v3 + 8) = v2;
  }
  if ( *(__int64 **)(*a1 + 8LL) == v5 )
  {
    *(_QWORD *)(*a1 + 8LL) = v2;
  }
  else
  {
    v15 = *i;
    if ( **i == v5 )
      *v15 = v2;
    else
      v15[2] = v2;
  }
  v16 = *((_BYTE *)v2 + 24);
  v2[1] = (__int64)*i;
  *((_BYTE *)v2 + 24) = *((_BYTE *)v5 + 24);
  *((_BYTE *)v5 + 24) = v16;
LABEL_43:
  if ( *((_BYTE *)v5 + 24) == 1 )
  {
    if ( v8 != *(__int64 **)(*a1 + 8LL) )
    {
      do
      {
        v17 = v9;
        if ( *((_BYTE *)v8 + 24) != 1 )
          break;
        v18 = *v9;
        if ( v8 == *v9 )
        {
          v18 = v9[2];
          if ( *((_BYTE *)v18 + 24) )
          {
            v20 = (__int64 ***)(v9 + 1);
          }
          else
          {
            *((_BYTE *)v18 + 24) = 1;
            v19 = (__int64 ***)v9[2];
            *((_BYTE *)v9 + 24) = 0;
            v9[2] = (__int64 *)*v19;
            if ( !*((_BYTE *)*v19 + 25) )
              (*v19)[1] = (__int64 *)v9;
            v20 = (__int64 ***)(v9 + 1);
            v19[1] = (__int64 **)v9[1];
            if ( v9 == *(__int64 ***)(*a1 + 8LL) )
            {
              *(_QWORD *)(*a1 + 8LL) = v19;
              *v19 = v9;
              *v20 = (__int64 **)v19;
              v18 = v9[2];
            }
            else
            {
              v21 = (__int64 ***)*v20;
              if ( v9 == (__int64 **)**v20 )
                *v21 = (__int64 **)v19;
              else
                v21[2] = (__int64 **)v19;
              *v19 = v9;
              *v20 = (__int64 **)v19;
              v18 = v9[2];
            }
          }
          if ( *((_BYTE *)v18 + 25) )
            goto LABEL_77;
          if ( *(_BYTE *)(*v18 + 24) != 1 || *(_BYTE *)(v18[2] + 24) != 1 )
          {
            if ( *(_BYTE *)(v18[2] + 24) == 1 )
            {
              *(_BYTE *)(*v18 + 24) = 1;
              *((_BYTE *)v18 + 24) = 0;
              sub_18002C620(a1, v18);
              v18 = v9[2];
            }
            *((_BYTE *)v18 + 24) = *((_BYTE *)v9 + 24);
            *((_BYTE *)v9 + 24) = 1;
            *(_BYTE *)(v18[2] + 24) = 1;
            sub_18002C5C0(a1, v9);
            break;
          }
        }
        else
        {
          if ( *((_BYTE *)v18 + 24) )
          {
            v20 = (__int64 ***)(v9 + 1);
          }
          else
          {
            *((_BYTE *)v18 + 24) = 1;
            v22 = *v9;
            *((_BYTE *)v9 + 24) = 0;
            *v9 = (__int64 *)v22[2];
            v23 = v22[2];
            if ( !*(_BYTE *)(v23 + 25) )
              *(_QWORD *)(v23 + 8) = v9;
            v20 = (__int64 ***)(v9 + 1);
            v22[1] = (__int64)v9[1];
            if ( v9 == *(__int64 ***)(*a1 + 8LL) )
            {
              *(_QWORD *)(*a1 + 8LL) = v22;
              v22[2] = (__int64)v9;
              *v20 = (__int64 **)v22;
              v18 = *v9;
            }
            else
            {
              v24 = *v20;
              if ( v9 == (__int64 **)(*v20)[2] )
                v24[2] = v22;
              else
                *v24 = v22;
              v22[2] = (__int64)v9;
              *v20 = (__int64 **)v22;
              v18 = *v9;
            }
          }
          if ( *((_BYTE *)v18 + 25) )
            goto LABEL_77;
          v25 = v18[2];
          if ( *(_BYTE *)(v25 + 24) != 1 || *(_BYTE *)(*v18 + 24) != 1 )
          {
            if ( *(_BYTE *)(*v18 + 24) == 1 )
            {
              *(_BYTE *)(v25 + 24) = 1;
              *((_BYTE *)v18 + 24) = 0;
              sub_18002C5C0(a1, v18);
              v18 = *v9;
            }
            *((_BYTE *)v18 + 24) = *((_BYTE *)v9 + 24);
            *((_BYTE *)v9 + 24) = 1;
            *(_BYTE *)(*v18 + 24) = 1;
            sub_18002C620(a1, v9);
            break;
          }
        }
        *((_BYTE *)v18 + 24) = 0;
LABEL_77:
        v8 = (__int64 *)v9;
        v9 = *v20;
      }
      while ( v17 != *(__int64 ***)(*a1 + 8LL) );
    }
    *((_BYTE *)v8 + 24) = 1;
  }
  v26 = a1[1];
  result = v5;
  if ( v26 )
    a1[1] = v26 - 1;
  return result;
}


// ===== 函数: sub_18002C620 (0x18002C620) =====
_QWORD *__fastcall sub_18002C620(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax
  _QWORD *result; // rax

  v2 = *a2;
  *a2 = *(_QWORD *)(*a2 + 16LL);
  v3 = *(_QWORD *)(v2 + 16);
  if ( !*(_BYTE *)(v3 + 25) )
    *(_QWORD *)(v3 + 8) = a2;
  *(_QWORD *)(v2 + 8) = a2[1];
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD **)(*(_QWORD *)a1 + 8LL) )
  {
    result[1] = v2;
    *(_QWORD *)(v2 + 16) = a2;
    a2[1] = v2;
  }
  else
  {
    result = (_QWORD *)a2[1];
    if ( a2 == (_QWORD *)result[2] )
      result[2] = v2;
    else
      *result = v2;
    *(_QWORD *)(v2 + 16) = a2;
    a2[1] = v2;
  }
  return result;
}


// ===== 函数: sub_18002C5C0 (0x18002C5C0) =====
_QWORD *__fastcall sub_18002C5C0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // r8
  _QWORD *result; // rax

  v2 = *(_QWORD **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *v2;
  if ( !*(_BYTE *)(*v2 + 25LL) )
    *(_QWORD *)(*v2 + 8LL) = a2;
  v2[1] = *(_QWORD *)(a2 + 8);
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
  {
    result[1] = v2;
    *v2 = a2;
    *(_QWORD *)(a2 + 8) = v2;
  }
  else
  {
    result = *(_QWORD **)(a2 + 8);
    if ( a2 == *result )
      *result = v2;
    else
      result[2] = v2;
    *v2 = a2;
    *(_QWORD *)(a2 + 8) = v2;
  }
  return result;
}


// ===== 函数: sub_180026D90 (0x180026D90) =====
_QWORD *__fastcall sub_180026D90(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdi
  __int64 v6; // rsi
  char v7; // al
  __int64 i; // rsi
  char v10; // al
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx

  v4 = a2;
  if ( a2 == a3 || (v6 = a2 + 40, a2 + 40 == a3) )
  {
LABEL_10:
    *a1 = a3;
  }
  else
  {
    while ( 1 )
    {
      v7 = *(_BYTE *)(v4 + 24);
      if ( v7 == *(_BYTE *)(v6 + 24)
        && ((unsigned __int8)(v7 - 6) <= 1u || *(double *)v4 == *(double *)v6)
        && *(_DWORD *)(v4 + 28) == *(_DWORD *)(v6 + 28)
        && !(unsigned int)sub_1800372B0(v4 + 8, v6 + 8)
        && !(unsigned int)sub_1800372B0(v4 + 16, v6 + 16) )
      {
        break;
      }
      v4 = v6;
      v6 += 40LL;
      if ( v6 == a3 )
        goto LABEL_10;
    }
    for ( i = v6 + 40; i != a3; i += 40LL )
    {
      v10 = *(_BYTE *)(v4 + 24);
      if ( v10 != *(_BYTE *)(i + 24)
        || (unsigned __int8)(v10 - 6) > 1u && *(double *)v4 != *(double *)i
        || *(_DWORD *)(v4 + 28) != *(_DWORD *)(i + 28)
        || (unsigned int)sub_1800372B0(v4 + 8, i + 8)
        || (unsigned int)sub_1800372B0(v4 + 16, i + 16) )
      {
        v4 += 40LL;
        v11 = *(_QWORD *)(v4 + 8);
        *(_QWORD *)v4 = *(_QWORD *)i;
        *(_QWORD *)(v4 + 8) = *(_QWORD *)(i + 8);
        v12 = *(_QWORD *)(i + 16);
        *(_QWORD *)(i + 8) = v11;
        v13 = *(_QWORD *)(v4 + 16);
        *(_QWORD *)(v4 + 16) = v12;
        *(_QWORD *)(i + 16) = v13;
        *(_BYTE *)(v4 + 24) = *(_BYTE *)(i + 24);
        *(_DWORD *)(v4 + 28) = *(_DWORD *)(i + 28);
        *(_DWORD *)(v4 + 32) = *(_DWORD *)(i + 32);
        *(_DWORD *)(v4 + 36) = *(_DWORD *)(i + 36);
      }
    }
    *a1 = v4 + 40;
  }
  return a1;
}


// ===== 函数: sub_1800372B0 (0x1800372B0) =====
__int64 __fastcall sub_1800372B0(__int64 a1, __int64 a2)
{
  __int128 *v4; // rax
  __int64 (__fastcall *v5)(__int64, _QWORD, __int64, __int64, _QWORD, __int64); // rdi
  __int128 *v6; // rax
  __int64 v7; // rax
  __int64 v8; // rbx
  __int128 *v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax

  v4 = sub_180036EE0();
  v5 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, _QWORD, __int64))(sub_180007790((__int64)v4) + 80);
  v6 = sub_180036EE0();
  v7 = sub_180007790((__int64)v6);
  v8 = (*(__int64 (__fastcall **)(__int64))(v7 + 128))(a2);
  v9 = sub_180036EE0();
  v10 = sub_180007790((__int64)v9);
  v11 = (*(__int64 (__fastcall **)(__int64))(v10 + 128))(a1);
  return v5(a1, 0LL, v11, a2, 0LL, v8);
}


// ===== 函数: sub_180026470 (0x180026470) =====
__int64 __fastcall sub_180026470(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v6; // r14
  _QWORD *v7; // r12
  __int64 v8; // r13
  __int64 v9; // r15
  __int64 v10; // r9
  __int64 result; // rax
  __int64 v12; // rdx
  unsigned __int64 v13; // rsi
  void **v14; // r8
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // r12
  __int64 v19; // rdx
  unsigned __int64 v20; // r8
  __int64 v21; // rsi
  __int64 *v22; // r14
  __int64 *v23; // r9
  __int64 *v24; // r8
  __int64 *v25; // rcx
  __int64 v26; // rdx
  __int64 *v27; // r8
  __int64 v28; // rdx
  __int64 *v29; // [rsp+20h] [rbp-68h]
  unsigned __int64 v30; // [rsp+20h] [rbp-68h]
  __int64 v31; // [rsp+28h] [rbp-60h]
  __int64 v32; // [rsp+30h] [rbp-58h]
  unsigned __int64 v33; // [rsp+38h] [rbp-50h]
  unsigned __int64 v34; // [rsp+40h] [rbp-48h]
  __int64 v37; // [rsp+98h] [rbp+10h]

  v6 = (a4 - a3) / 40;
  v7 = a1 + 1;
  v29 = a1 + 1;
  v8 = *a1;
  v9 = a1[1];
  v10 = a1[2];
  result = (unsigned __int64)((unsigned __int128)((v10 - v9) * (__int128)0x6666666666666667LL) >> 64) >> 63;
  if ( v6 )
  {
    if ( v6 <= (v10 - v9) / 40 )
    {
      v21 = 40 * v6;
      if ( v6 >= (v9 - a2) / 40 )
      {
        v31 = v21 + a2;
        *v7 = sub_180018860(a2, v9, v21 + a2, a1);
        sub_180018360(a2, v9, a1);
        try
        {
          result = sub_18000B8D0(a3, a4, a2);
        }
        catch ( ... )
        {
          sub_180018860(v31, *v29, a2, a1);
          sub_180018360(v31, *v29, a1);
          *v29 = v9;
          throw;
        }
      }
      else
      {
        v22 = (__int64 *)(v9 - v21);
        *v7 = sub_180018860(v9 - v21, v9, v9, a1);
        if ( v9 - v21 != a2 )
        {
          v23 = (__int64 *)(v9 + 16);
          do
          {
            v24 = v23;
            v22 -= 5;
            v23 -= 5;
            *(v24 - 7) = *v22;
            v25 = v24 - 6;
            v26 = *(v24 - 6);
            v27 = &v24[v21 / 0xFFFFFFFFFFFFFFF8uLL];
            *v25 = *(v27 - 6);
            *(v27 - 6) = v26;
            v28 = *v23;
            *v23 = v23[v21 / 0xFFFFFFFFFFFFFFF8uLL];
            v23[v21 / 0xFFFFFFFFFFFFFFF8uLL] = v28;
            *((_BYTE *)v23 + 8) = *((_BYTE *)v23 + 8 - v21);
            *((_DWORD *)v23 + 3) = *(_DWORD *)((char *)v23 + 12 - v21);
            *((_DWORD *)v23 + 4) = *(_DWORD *)((char *)v23 + 16 - v21);
            *((_DWORD *)v23 + 5) = *(_DWORD *)((char *)v23 + 20 - v21);
          }
          while ( v22 != (__int64 *)a2 );
        }
        sub_180018360(a2, v21 + a2, a1);
        return sub_18000B8D0(a3, a4, a2);
      }
    }
    else
    {
      v12 = (v9 - v8) / 40;
      v13 = 0x666666666666666LL;
      if ( v6 > 0x666666666666666LL - v12 )
        std::vector<void *>::_Xlen();
      v14 = (void **)(v12 + v6);
      v33 = v12 + v6;
      v15 = (v10 - v8) / 40;
      v16 = v15 >> 1;
      if ( v15 <= 0x666666666666666LL - (v15 >> 1) )
      {
        v13 = v16 + v15;
        if ( v16 + v15 < (unsigned __int64)v14 )
          v13 = (unsigned __int64)v14;
      }
      v17 = sub_18000E460((__int64)a1, v13, v14);
      try
      {
        v18 = v17;
        v34 = v17;
        v19 = (a2 - v8) / 40;
        v30 = v17 + 40 * (v19 + v6);
        v32 = v17 + 40 * v19;
        sub_18000B8D0(a3, a4, v32);
        v37 = v32;
        if ( v6 == 1 && a2 == v9 )
        {
          v20 = v18;
        }
        else
        {
          sub_180018860(v8, a2, v18, a1);
          v37 = v18;
          v8 = a2;
          v20 = v30;
        }
        sub_180018860(v8, v9, v20, a1);
        result = sub_18001A0C0(a1, v18, v33, v13);
      }
      catch ( ... )
      {
        sub_180018360(v37, v30, a1);
        sub_18001A220(a1, v34, v13);
        throw;
      }
    }
  }
  return result;
}


// ===== 函数: sub_18000E460 (0x18000E460) =====
unsigned __int64 __fastcall sub_18000E460(__int64 a1, unsigned __int64 a2, void **a3)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 result; // rax

  if ( a2 > 0x666666666666666LL )
    goto LABEL_10;
  v3 = 40 * a2;
  if ( 40 * a2 < 0x1000 )
  {
    if ( v3 )
      return sub_180031D20((ai *)v3, a2, a3);
    else
      return 0LL;
  }
  if ( v3 + 39 < v3 )
LABEL_10:
    Concurrency::cancel_current_task();
  v4 = sub_180031D20((ai *)(v3 + 39), a2, a3);
  v5 = v4;
  if ( !v4 )
    invalid_parameter_noinfo_noreturn();
  result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(result - 8) = v5;
  return result;
}


// ===== 函数: sub_180031D20 (0x180031D20) =====
unsigned __int64 __fastcall sub_180031D20(ai *a1, __int64 a2, void **a3)
{
  unsigned __int64 result; // rax
  _BYTE pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 v5; // [rsp+58h] [rbp+10h] BYREF

  v5 = 0LL;
  if ( ai::SPBasicAllocateBlock(a1, (unsigned __int64)&v5, a3) )
  {
    v5 = 0LL;
    goto LABEL_4;
  }
  result = v5;
  if ( !v5 )
  {
LABEL_4:
    sub_180031CF0(pExceptionObject);
    throw (std::bad_alloc *)pExceptionObject;
  }
  return result;
}


// ===== 函数: sub_180031CF0 (0x180031CF0) =====
_QWORD *__fastcall sub_180031CF0(_QWORD *a1)
{
  a1[2] = 0LL;
  a1[1] = "bad allocation";
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}


// ===== 函数: _CxxThrowException (0x18004D0DC) =====
// attributes: thunk
void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _CxxThrowException(pExceptionObject, pThrowInfo);
}


// ===== 函数: ?SPBasicAllocateBlock@ai@@YAH_KPEAPEAX@Z (0x180043FA7) =====
// attributes: thunk
int __fastcall ai::SPBasicAllocateBlock(ai *this, unsigned __int64 a2, void **a3)
{
  return __imp_?SPBasicAllocateBlock@ai@@YAH_KPEAPEAX@Z(this, a2, a3);
}


// ===== 函数: ?cancel_current_task@Concurrency@@YAXXZ (0x180006EB0) =====
void __noreturn Concurrency::cancel_current_task(void)
{
  _BYTE pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  sub_1800047B0(pExceptionObject);
  throw (std::bad_array_new_length *)pExceptionObject;
}


// ===== 函数: sub_1800047B0 (0x1800047B0) =====
_QWORD *__fastcall sub_1800047B0(_QWORD *a1)
{
  a1[2] = 0LL;
  a1[1] = "bad array new length";
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}


// ===== 函数: sub_18001A0C0 (0x18001A0C0) =====
__int64 __fastcall sub_18001A0C0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 i; // rdi
  __int64 v10; // r8
  __int64 result; // rax

  v4 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v4 != i; v4 += 40LL )
    {
      sub_180036A90((_QWORD *)(v4 + 16));
      sub_180036A90((_QWORD *)(v4 + 8));
    }
    v10 = *a1;
    if ( (unsigned __int64)(40 * ((a1[2] - *a1) / 40)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v10 - *(_QWORD *)(v10 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = *(_QWORD *)(v10 - 8);
    }
    sub_18001AE10(v10);
  }
  *a1 = a2;
  a1[1] = a2 + 40 * a3;
  result = 5 * a4;
  a1[2] = a2 + 40 * a4;
  return result;
}


// ===== 函数: sub_180018860 (0x180018860) =====
_QWORD *__fastcall sub_180018860(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v4; // r8
  char *v5; // r9
  __int64 v6; // rax
  __int64 v7; // rax

  if ( a1 != a2 )
  {
    v4 = a1 + 16;
    v5 = (char *)a3 - a1;
    do
    {
      v6 = *(_QWORD *)(v4 - 16);
      v4 += 40LL;
      *a3 = v6;
      a3 += 5;
      *(_QWORD *)&v5[v4 - 48] = *(_QWORD *)(v4 - 48);
      v7 = *(_QWORD *)(v4 - 40);
      *(_QWORD *)(v4 - 48) = 0LL;
      *(_QWORD *)&v5[v4 - 40] = v7;
      *(_QWORD *)(v4 - 40) = 0LL;
      v5[v4 - 32] = *(_BYTE *)(v4 - 32);
      *(_DWORD *)&v5[v4 - 28] = *(_DWORD *)(v4 - 28);
      *(_DWORD *)&v5[v4 - 24] = *(_DWORD *)(v4 - 24);
      *(_DWORD *)&v5[v4 - 20] = *(_DWORD *)(v4 - 20);
    }
    while ( v4 - 16 != a2 );
  }
  return a3;
}


// ===== 函数: sub_180018360 (0x180018360) =====
_QWORD *__fastcall sub_180018360(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3; // rbx
  _QWORD *result; // rax

  if ( a1 != a2 )
  {
    v3 = a1 + 1;
    do
    {
      sub_180036A90(v3 + 1);
      sub_180036A90(v3);
      v3 += 5;
      result = v3 - 1;
    }
    while ( v3 - 1 != a2 );
  }
  return result;
}


// ===== 函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_0 (0x18000E440) =====
void __noreturn std::vector<void *>::_Xlen()
{
  std::_Xlength_error("vector too long");
}


// ===== 函数: ?_Xlength_error@std@@YAXPEBD@Z (0x18004BC8E) =====
// attributes: thunk
void __fastcall __noreturn std::_Xlength_error(const char *a1)
{
  __imp_?_Xlength_error@std@@YAXPEBD@Z(a1);
}


// ===== 函数: sub_18000B8D0 (0x18000B8D0) =====
__int64 __fastcall sub_18000B8D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rdi

  if ( a1 != a2 )
  {
    v5 = a1 + 16;
    do
    {
      *(_QWORD *)a3 = *(_QWORD *)(v5 - 16);
      sub_180036480((_QWORD *)(a3 + 8), v5 - 8);
      sub_180036480((_QWORD *)(a3 + 16), v5);
      *(_BYTE *)(a3 + 24) = *(_BYTE *)(v5 + 8);
      *(_DWORD *)(a3 + 28) = *(_DWORD *)(v5 + 12);
      *(_DWORD *)(a3 + 32) = *(_DWORD *)(v5 + 16);
      *(_DWORD *)(a3 + 36) = *(_DWORD *)(v5 + 20);
      a3 += 40LL;
      v5 += 40LL;
    }
    while ( v5 - 16 != a2 );
  }
  return a3;
}


// ===== 函数: sub_180036480 (0x180036480) =====
_QWORD *__fastcall sub_180036480(_QWORD *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rax
  unsigned int v6; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  v4 = sub_180036EE0(&unk_1800745D5);
  v5 = sub_180007790(v4);
  v6 = (*(__int64 (__fastcall **)(_QWORD *, __int64))(v5 + 56))(a1, a2);
  if ( v6 )
  {
    sub_180003F80(pExceptionObject, v6, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_180003F80 (0x180003F80) =====
__int64 __fastcall sub_180003F80(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // rax

  *(_OWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)a1 = &ai::Error::`vftable';
  result = a1;
  *(_DWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a3;
  return result;
}


// ===== 函数: sub_1800267D0 (0x1800267D0) =====
__int64 __fastcall sub_1800267D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx

  if ( a1 != a2 )
  {
    v3 = a1 + 16;
    do
    {
      v4 = *(_QWORD *)(v3 - 16);
      v3 += 40LL;
      v5 = *(_QWORD *)(a3 + 8);
      *(_QWORD *)a3 = v4;
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(v3 - 48);
      v6 = *(_QWORD *)(v3 - 40);
      *(_QWORD *)(v3 - 48) = v5;
      v7 = *(_QWORD *)(a3 + 16);
      *(_QWORD *)(a3 + 16) = v6;
      *(_QWORD *)(v3 - 40) = v7;
      *(_BYTE *)(a3 + 24) = *(_BYTE *)(v3 - 32);
      *(_DWORD *)(a3 + 28) = *(_DWORD *)(v3 - 28);
      *(_DWORD *)(a3 + 32) = *(_DWORD *)(v3 - 24);
      *(_DWORD *)(a3 + 36) = *(_DWORD *)(v3 - 20);
      a3 += 40LL;
    }
    while ( v3 - 16 != a2 );
  }
  return a3;
}


// ===== 函数: ?_Xout_of_range@std@@YAXPEBD@Z (0x18004BC94) =====
// attributes: thunk
void __fastcall std::_Xout_of_range(const char *a1)
{
  __imp_?_Xout_of_range@std@@YAXPEBD@Z(a1);
}


// ===== 函数: sub_18000C4E0 (0x18000C4E0) =====
void __fastcall sub_18000C4E0(_QWORD *a1)
{
  sub_18000B670(a1 + 8, a1 + 8);
  sub_18000B6F0((__int64)(a1 + 6), (__int64)(a1 + 6), *(_QWORD *)(a1[6] + 8LL));
  sub_18001AE10(a1[6]);
  sub_18000B7F0((__int64)(a1 + 4), (__int64)(a1 + 4), *(_QWORD *)(a1[4] + 8LL));
  sub_18001AE10(a1[4]);
  sub_18000B770((__int64)(a1 + 2), (__int64)(a1 + 2), *(_QWORD *)(a1[2] + 8LL));
  sub_18001AE10(a1[2]);
  sub_180032550(a1);
}


// ===== 函数: sub_18000B670 (0x18000B670) =====
__int64 __fastcall sub_18000B670(__int64 *a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rcx

  v4 = *(_QWORD *)(*a1 + 8);
  while ( !*(_BYTE *)(v4 + 25) )
  {
    sub_18000B870((__int64)a1, a2, *(_QWORD *)(v4 + 16));
    v5 = v4;
    v4 = *(_QWORD *)v4;
    sub_18001AE10(v5);
  }
  return sub_18001AE10(*a1);
}


// ===== 函数: sub_18000B870 (0x18000B870) =====
__int64 __fastcall sub_18000B870(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rcx
  __int64 result; // rax

  for ( i = a3; !*(_BYTE *)(i + 25); result = sub_18001AE10(v6) )
  {
    sub_18000B870(a1, a2, *(_QWORD *)(i + 16));
    v6 = i;
    i = *(_QWORD *)i;
  }
  return result;
}


// ===== 函数: sub_18000B770 (0x18000B770) =====
__int64 __fastcall sub_18000B770(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*(_BYTE *)(i + 25); result = sub_18001AE10(v6) )
  {
    sub_18000B770(a1, a2, *(_QWORD *)(i + 16));
    v6 = i;
    i = *(_QWORD *)i;
    sub_180032550((_QWORD *)(v6 + 32));
  }
  return result;
}


// ===== 函数: sub_180032550 (0x180032550) =====
void __fastcall sub_180032550(_QWORD *a1)
{
  __int128 *v2; // rax
  __int128 *v3; // rbx
  int v4; // eax
  _QWORD *v5; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  if ( *a1 )
  {
    try
    {
      v2 = sub_180032E90();
      v3 = v2;
      if ( !*((_QWORD *)v2 + 1) && qword_1800740D8 )
      {
        v4 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
               *((_QWORD *)v2 + 2),
               *((unsigned int *)v2 + 6),
               (__int64)v2 + 8);
        if ( v4 )
        {
          sub_180003F80((__int64)pExceptionObject, v4, 0LL);
          throw (ai::Error *)pExceptionObject;
        }
        if ( !*((_BYTE *)v3 + 28) )
        {
          v5 = sub_180012E90();
          *(_QWORD *)v3 = *v5;
          *v5 = v3;
        }
      }
      (*(void (__fastcall **)(_QWORD *))(*((_QWORD *)v3 + 1) + 8LL))(a1);
    }
    catch ( ... )
    {
    }
  }
}


// ===== 函数: sub_180032E90 (0x180032E90) =====
__int128 *sub_180032E90()
{
  _QWORD *v1; // rax

  if ( dword_180074550 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180074530;
  Init_thread_header(&dword_180074550);
  if ( dword_180074550 != -1 )
    return &xmmword_180074530;
  xmmword_180074530 = 0LL;
  qword_180074540 = (__int64)"AI File Path Suite";
  dword_180074548 = 8;
  byte_18007454C = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180074530 = *v1;
  *v1 = &xmmword_180074530;
  Init_thread_footer(&dword_180074550);
  return &xmmword_180074530;
}


// ===== 函数: _Init_thread_footer (0x18004BEA4) =====
__int64 __fastcall Init_thread_footer(_DWORD *a1)
{
  __int64 v2; // rdx

  EnterCriticalSection(&CriticalSection);
  v2 = (unsigned int)TlsIndex;
  *a1 = ++dword_180072650;
  *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + v2) + 4LL) = dword_180072650;
  LeaveCriticalSection(&CriticalSection);
  return Init_thread_notify();
}


// ===== 函数: _Init_thread_header (0x18004BF04) =====
void __fastcall Init_thread_header(_DWORD *a1)
{
  EnterCriticalSection(&CriticalSection);
  while ( 1 )
  {
    if ( !*a1 )
    {
      *a1 = -1;
      goto LABEL_7;
    }
    if ( *a1 != -1 )
      break;
    Init_thread_wait(0x64u);
  }
  *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL) = dword_180072650;
LABEL_7:
  LeaveCriticalSection(&CriticalSection);
}


// ===== 函数: _Init_thread_wait (0x18004BFB0) =====
void __fastcall Init_thread_wait(DWORD dwMilliseconds)
{
  if ( qword_1800751C8 )
  {
    qword_1800751C8(&unk_180075190, &CriticalSection, dwMilliseconds);
  }
  else
  {
    LeaveCriticalSection(&CriticalSection);
    WaitForSingleObjectEx(hHandle, dwMilliseconds, 0);
    EnterCriticalSection(&CriticalSection);
  }
}


// ===== 函数: sub_18000B7F0 (0x18000B7F0) =====
__int64 __fastcall sub_18000B7F0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*(_BYTE *)(i + 25); result = sub_18001AE10(v6) )
  {
    sub_18000B7F0(a1, a2, *(_QWORD *)(i + 16));
    v6 = i;
    i = *(_QWORD *)i;
    sub_180036A90((_QWORD *)(v6 + 32));
  }
  return result;
}


// ===== 函数: sub_18000BC80 (0x18000BC80) =====
__int64 __fastcall sub_18000BC80(__int64 a1, __int64 a2)
{
  __int64 *v4; // rbx
  __int64 v5; // rdx
  void **v6; // r8
  unsigned __int64 v7; // rax
  __int64 v8; // r8
  __int64 v9; // rdx
  __int64 i; // rcx
  __int64 v11; // rcx
  __int64 j; // rax
  unsigned __int64 v13; // rax
  unsigned __int8 v15; // [rsp+50h] [rbp+8h]

  v15 = a1;
  sub_180032460((_QWORD *)a1, a2);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  sub_18000BB30(a1 + 16, a2 + 16);
  sub_18000BBA0(a1 + 32, a2 + 32);
  v4 = (__int64 *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  v7 = sub_180031D20((ai *)0x40, v5, v6);
  *(_QWORD *)v7 = v7;
  *(_QWORD *)(v7 + 8) = v7;
  *(_QWORD *)(v7 + 16) = v7;
  *(_WORD *)(v7 + 24) = 257;
  *(_QWORD *)(a1 + 48) = v7;
  *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8LL) = sub_18000B0B0(
                                              (unsigned __int64 *)(a1 + 48),
                                              *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8LL),
                                              (void **)v7,
                                              v15);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  v8 = *(_QWORD *)(a1 + 48);
  v9 = *(_QWORD *)(v8 + 8);
  if ( *(_BYTE *)(v9 + 25) )
  {
    *(_QWORD *)v8 = v8;
    *(_QWORD *)(*v4 + 16) = *v4;
  }
  else
  {
    for ( i = *(_QWORD *)v9; !*(_BYTE *)(i + 25); i = *(_QWORD *)i )
      v9 = i;
    *(_QWORD *)v8 = v9;
    v9 = *v4;
    v11 = *(_QWORD *)(*v4 + 8);
    for ( j = *(_QWORD *)(v11 + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
      v11 = j;
    *(_QWORD *)(v9 + 16) = v11;
  }
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  v13 = sub_180031D20((ai *)0x20, v9, (void **)v8);
  *(_QWORD *)v13 = v13;
  *(_QWORD *)(v13 + 8) = v13;
  *(_QWORD *)(v13 + 16) = v13;
  *(_WORD *)(v13 + 24) = 257;
  *(_QWORD *)(a1 + 64) = v13;
  sub_18000B000((_QWORD *)(a1 + 64), (_QWORD *)(a2 + 64), v15);
  return a1;
}


// ===== 函数: sub_180032460 (0x180032460) =====
_QWORD *__fastcall sub_180032460(_QWORD *a1, __int64 a2)
{
  __int128 *v4; // rax
  __int128 *v5; // rbx
  int v6; // eax
  _QWORD *v7; // rax
  int v8; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  v4 = sub_180032E90();
  v5 = v4;
  if ( !*((_QWORD *)v4 + 1) && qword_1800740D8 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v4 + 2),
           *((unsigned int *)v4 + 6),
           (__int64)v4 + 8);
    if ( v6 )
    {
      sub_180003F80((__int64)pExceptionObject, v6, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v5 + 28) )
    {
      v7 = sub_180012E90();
      *(_QWORD *)v5 = *v7;
      *v7 = v5;
    }
  }
  v8 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*((_QWORD *)v5 + 1) + 16LL))(a2, a1);
  if ( v8 )
  {
    sub_180003F80((__int64)pExceptionObject, v8, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_18000BBA0 (0x18000BBA0) =====
unsigned __int64 *__fastcall sub_18000BBA0(unsigned __int64 *a1, _QWORD *a2, void **a3)
{
  unsigned __int64 v5; // rax
  _QWORD *v6; // r8
  __int64 **v7; // rdx
  __int64 *i; // rcx
  __int64 v9; // rcx
  __int64 j; // rax
  unsigned __int8 v14; // [rsp+50h] [rbp+8h]

  v14 = (unsigned __int8)a1;
  *a1 = 0LL;
  a1[1] = 0LL;
  v5 = sub_180031D20((ai *)0x28, (__int64)a2, a3);
  *(_QWORD *)v5 = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)(v5 + 16) = v5;
  *(_WORD *)(v5 + 24) = 257;
  *a1 = v5;
  *(_QWORD *)(*a1 + 8) = sub_18000B300(a1, *(_QWORD *)(*a2 + 8LL), v5, v14, -2LL, a1, a1);
  a1[1] = a2[1];
  v6 = (_QWORD *)*a1;
  v7 = *(__int64 ***)(*a1 + 8);
  if ( *((_BYTE *)v7 + 25) )
  {
    *v6 = v6;
    *(_QWORD *)(*a1 + 16) = *a1;
  }
  else
  {
    for ( i = *v7; !*((_BYTE *)i + 25); i = (__int64 *)*i )
      v7 = (__int64 **)i;
    *v6 = v7;
    v9 = *(_QWORD *)(*a1 + 8);
    for ( j = *(_QWORD *)(v9 + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
      v9 = j;
    *(_QWORD *)(*a1 + 16) = v9;
  }
  return a1;
}


// ===== 函数: sub_18000B300 (0x18000B300) =====
unsigned __int64 __fastcall sub_18000B300(unsigned __int64 *a1, __int64 a2, void **a3, unsigned __int8 a4)
{
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rsi
  __int64 v11; // rax
  __int64 v12; // [rsp+20h] [rbp-48h]
  __int64 v14; // [rsp+28h] [rbp-40h]
  __int64 v15; // [rsp+30h] [rbp-38h]

  v8 = *a1;
  if ( !*(_BYTE *)(a2 + 25) )
  {
    v9 = sub_180031D20((ai *)0x28, a2, a3);
    sub_180036480((_QWORD *)(v9 + 32), a2 + 32);
    *(_QWORD *)v9 = v8;
    *(_QWORD *)(v9 + 16) = v8;
    *(_WORD *)(v9 + 24) = 0;
    *(_QWORD *)(v9 + 8) = a3;
    *(_BYTE *)(v9 + 24) = *(_BYTE *)(a2 + 24);
    if ( *(_BYTE *)(v8 + 25) )
      v8 = v9;
    try
    {
      *(_QWORD *)v9 = sub_18000B300(a1, *(_QWORD *)a2, v9, a4, -2LL, a1, v9);
      *(_QWORD *)(v9 + 16) = sub_18000B300(a1, *(_QWORD *)(a2 + 16), v9, a4, v12, v14, v15);
    }
    catch ( ... )
    {
      v11 = sub_18000DE70(a1);
      sub_18000B7F0(a1, v11, v8);
      throw;
    }
  }
  return v8;
}


// ===== 函数: sub_18000B000 (0x18000B000) =====
__int64 __fastcall sub_18000B000(_QWORD *a1, _QWORD *a2, unsigned __int8 a3)
{
  _QWORD *v5; // r8
  __int64 **v6; // rdx
  __int64 *i; // rcx
  __int64 v8; // rcx
  __int64 result; // rax

  *(_QWORD *)(*a1 + 8LL) = sub_18000B3E0(a1, *(_QWORD *)(*a2 + 8LL), *a1, a3);
  v5 = (_QWORD *)*a1;
  a1[1] = a2[1];
  v6 = (__int64 **)v5[1];
  if ( *((_BYTE *)v6 + 25) )
  {
    *v5 = v5;
    result = *a1;
    *(_QWORD *)(*a1 + 16LL) = *a1;
  }
  else
  {
    for ( i = *v6; !*((_BYTE *)i + 25); i = (__int64 *)*i )
      v6 = (__int64 **)i;
    *v5 = v6;
    v8 = *(_QWORD *)(*a1 + 8LL);
    for ( result = *(_QWORD *)(v8 + 16); !*(_BYTE *)(result + 25); result = *(_QWORD *)(result + 16) )
      v8 = result;
    *(_QWORD *)(*a1 + 16LL) = v8;
  }
  return result;
}


// ===== 函数: sub_18000B3E0 (0x18000B3E0) =====
unsigned __int64 __fastcall sub_18000B3E0(unsigned __int64 *a1, __int64 a2, void **a3, unsigned __int8 a4)
{
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdi
  __int64 v11; // rax

  v8 = *a1;
  if ( !*(_BYTE *)(a2 + 25) )
  {
    v9 = sub_180031D20((ai *)0x20, a2, a3);
    *(_BYTE *)(v9 + 26) = *(_BYTE *)(a2 + 26);
    *(_QWORD *)v9 = v8;
    *(_QWORD *)(v9 + 16) = v8;
    *(_WORD *)(v9 + 24) = 0;
    *(_QWORD *)(v9 + 8) = a3;
    *(_BYTE *)(v9 + 24) = *(_BYTE *)(a2 + 24);
    if ( *(_BYTE *)(v8 + 25) )
      v8 = v9;
    try
    {
      *(_QWORD *)v9 = sub_18000B3E0(a1, *(_QWORD *)a2, v9, a4);
      *(_QWORD *)(v9 + 16) = sub_18000B3E0(a1, *(_QWORD *)(a2 + 16), v9, a4);
    }
    catch ( ... )
    {
      v11 = sub_18000DE70(a1);
      sub_18000B870(a1, v11, v8);
      throw;
    }
  }
  return v8;
}


// ===== 函数: sub_18000BB30 (0x18000BB30) =====
unsigned __int64 *__fastcall sub_18000BB30(unsigned __int64 *a1, __int64 a2, void **a3)
{
  unsigned __int64 v5; // rax
  unsigned __int8 v7; // [rsp+50h] [rbp+8h]

  v7 = (unsigned __int8)a1;
  *a1 = 0LL;
  a1[1] = 0LL;
  v5 = sub_180031D20((ai *)0x28, a2, a3);
  *(_QWORD *)v5 = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)(v5 + 16) = v5;
  *(_WORD *)(v5 + 24) = 257;
  *a1 = v5;
  sub_18000AF50(a1, a2, v7);
  return a1;
}


// ===== 函数: sub_18000AF50 (0x18000AF50) =====
unsigned __int64 __fastcall sub_18000AF50(unsigned __int64 *a1, _QWORD *a2, unsigned __int8 a3)
{
  _QWORD *v5; // r8
  __int64 **v6; // rdx
  __int64 *i; // rcx
  unsigned __int64 v8; // rcx
  unsigned __int64 result; // rax

  *(_QWORD *)(*a1 + 8) = sub_18000B220(a1, *(_QWORD *)(*a2 + 8LL), (void **)*a1, a3);
  v5 = (_QWORD *)*a1;
  a1[1] = a2[1];
  v6 = (__int64 **)v5[1];
  if ( *((_BYTE *)v6 + 25) )
  {
    *v5 = v5;
    result = *a1;
    *(_QWORD *)(*a1 + 16) = *a1;
  }
  else
  {
    for ( i = *v6; !*((_BYTE *)i + 25); i = (__int64 *)*i )
      v6 = (__int64 **)i;
    *v5 = v6;
    v8 = *(_QWORD *)(*a1 + 8);
    for ( result = *(_QWORD *)(v8 + 16); !*(_BYTE *)(result + 25); result = *(_QWORD *)(result + 16) )
      v8 = result;
    *(_QWORD *)(*a1 + 16) = v8;
  }
  return result;
}


// ===== 函数: sub_18000B220 (0x18000B220) =====
unsigned __int64 __fastcall sub_18000B220(unsigned __int64 *a1, __int64 a2, void **a3, unsigned __int8 a4)
{
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rsi
  __int64 v11; // rax

  v8 = *a1;
  if ( !*(_BYTE *)(a2 + 25) )
  {
    v9 = sub_180031D20((ai *)0x28, a2, a3);
    sub_180032460(v9 + 32, a2 + 32);
    *(_QWORD *)v9 = v8;
    *(_QWORD *)(v9 + 16) = v8;
    *(_WORD *)(v9 + 24) = 0;
    *(_QWORD *)(v9 + 8) = a3;
    *(_BYTE *)(v9 + 24) = *(_BYTE *)(a2 + 24);
    if ( *(_BYTE *)(v8 + 25) )
      v8 = v9;
    try
    {
      *(_QWORD *)v9 = sub_18000B220(a1, *(_QWORD *)a2, v9, a4);
      *(_QWORD *)(v9 + 16) = sub_18000B220(a1, *(_QWORD *)(a2 + 16), v9, a4);
    }
    catch ( ... )
    {
      v11 = sub_18000DE70(a1);
      sub_18000B770(a1, v11, v8);
      throw;
    }
  }
  return v8;
}


// ===== 函数: sub_18000B0B0 (0x18000B0B0) =====
unsigned __int64 __fastcall sub_18000B0B0(unsigned __int64 *a1, __int64 a2, void **a3, unsigned __int8 a4)
{
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rdi
  __int64 v9; // r8
  __int64 *v10; // r13
  __int64 v11; // rcx
  unsigned __int64 v12; // r12
  __int64 v13; // rax
  __int64 v15; // rax

  v7 = *a1;
  if ( !*(_BYTE *)(a2 + 25) )
  {
    v8 = sub_180031D20((ai *)0x40, a2, a3);
    *(_BYTE *)(v8 + 32) = *(_BYTE *)(a2 + 32);
    v10 = (__int64 *)(v8 + 40);
    *(_QWORD *)(v8 + 40) = 0LL;
    *(_QWORD *)(v8 + 48) = 0LL;
    *(_QWORD *)(v8 + 56) = 0LL;
    v11 = *(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40);
    v12 = v11 / 40;
    if ( v11 / 40 )
    {
      if ( v12 > 0x666666666666666LL )
        std::vector<void *>::_Xlen();
      v13 = sub_18000E460(v10, v11 / 40, v9);
      *v10 = v13;
      *(_QWORD *)(v8 + 48) = v13;
      *(_QWORD *)(v8 + 56) = v13 + 40 * v12;
      *(_QWORD *)(v8 + 48) = sub_18000B8D0(*(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 48), *(_QWORD *)(v8 + 40), v8 + 40);
    }
    *(_QWORD *)v8 = v7;
    *(_QWORD *)(v8 + 16) = v7;
    *(_WORD *)(v8 + 24) = 0;
    *(_QWORD *)(v8 + 8) = a3;
    *(_BYTE *)(v8 + 24) = *(_BYTE *)(a2 + 24);
    if ( *(_BYTE *)(v7 + 25) )
      v7 = v8;
    try
    {
      *(_QWORD *)v8 = sub_18000B0B0(a1, *(_QWORD *)a2, v8, a4);
      *(_QWORD *)(v8 + 16) = sub_18000B0B0(a1, *(_QWORD *)(a2 + 16), v8, a4);
    }
    catch ( ... )
    {
      v15 = sub_18000DE70(a1);
      sub_18000B6F0(a1, v15, v7);
      throw;
    }
  }
  return v7;
}


// ===== 函数: sub_180017990 (0x180017990) =====
__int64 __fastcall sub_180017990(__int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  __int64 v6; // rax
  void (__fastcall **v7)(_QWORD, __int64); // r8
  volatile signed __int32 *v8; // rdi

  *(_QWORD *)a1 = &SmartExport::ProgressHandler::`vftable';
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_DWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_QWORD *)(a1 + 112) = 0LL;
  *(_QWORD *)(a1 + 120) = 0LL;
  v6 = a3[1];
  if ( v6 )
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 8));
  *(_QWORD *)(a1 + 112) = *a3;
  *(_QWORD *)(a1 + 120) = a3[1];
  *(_QWORD *)(a1 + 16) = sub_180017DB0;
  *(_QWORD *)(a1 + 24) = sub_180017E60;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)(a1 + 64) = a1;
  sub_180017F60(a1, 0LL);
  v7 = (void (__fastcall **)(_QWORD, __int64))gAICustomProgressBarSuite;
  if ( gAICustomProgressBarSuite )
  {
    *(_DWORD *)(a1 + 72) = (*(__int64 (__fastcall **)(__int64))(gAICustomProgressBarSuite + 16))(1LL);
    v7 = (void (__fastcall **)(_QWORD, __int64))gAICustomProgressBarSuite;
  }
  if ( *(int *)(a1 + 12) > 1 && gAIUserSuite )
  {
    (*(void (__fastcall **)(_QWORD))(gAIUserSuite + 8))(0LL);
    v7 = (void (__fastcall **)(_QWORD, __int64))gAICustomProgressBarSuite;
  }
  if ( a2 > 1 && v7 && !*(_DWORD *)(a1 + 76) )
  {
    (*v7)(*(_QWORD *)(qword_180074190 + 8), a1 + 16);
    *(_DWORD *)(a1 + 76) = 1;
  }
  v8 = (volatile signed __int32 *)a3[1];
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd(v8 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v8)(v8);
      if ( _InterlockedExchangeAdd(v8 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v8 + 8LL))(v8);
    }
  }
  return a1;
}


// ===== 函数: sub_180017F60 (0x180017F60) =====
void __fastcall sub_180017F60(__int64 a1)
{
  __int64 *v1; // rdx
  __int64 v2; // [rsp+20h] [rbp-28h] BYREF
  _QWORD v3[4]; // [rsp+28h] [rbp-20h] BYREF
  __int64 v4; // [rsp+50h] [rbp+8h] BYREF
  __int64 v5; // [rsp+60h] [rbp+18h] BYREF
  __int64 v6; // [rsp+68h] [rbp+20h] BYREF

  v3[1] = -2LL;
  if ( *(int *)(a1 + 12) > 1 && gAIUserSuite )
  {
    v1 = &qword_180072190;
    if ( (unsigned __int64)qword_1800721A8 >= 0x10 )
      v1 = (__int64 *)qword_180072190;
    sub_1800367E0(&v4, v1);
    unknown_libname_2(&v6);
    (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *))(gAIUserSuite + 40))(*(_QWORD *)(gAIUserSuite + 40), 0LL, &v6);
    unknown_libname_2(&v5);
    (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *))(gAIUserSuite + 40))(*(_QWORD *)(gAIUserSuite + 40), 0LL, &v5);
    sub_1800366C0(v3, "^1", 0LL);
    sub_1800366C0(&v2, "^2", 0LL);
    sub_1800180B0(&v4, v3, &v5);
    sub_1800180B0(&v4, &v2, &v6);
    (*(void (__fastcall **)(__int64 *))(gAIUserSuite + 24))(&v4);
    sub_180036A90(&v2);
    sub_180036A90(v3);
    sub_180036A90(&v5);
    sub_180036A90(&v6);
    sub_180036A90(&v4);
  }
}


// ===== 函数: sub_1800367E0 (0x1800367E0) =====
_QWORD *__fastcall sub_1800367E0(_QWORD *a1, __int64 a2)
{
  __int128 *v4; // rax
  __int64 v5; // rax
  int v6; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  v4 = sub_180036EE0();
  v5 = sub_180007790((__int64)v4);
  v6 = (*(__int64 (__fastcall **)(_QWORD *, __int64))(v5 + 304))(a1, a2);
  if ( v6 )
  {
    sub_180003F80((__int64)pExceptionObject, v6, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a1;
}


// ===== 函数: unknown_libname_2 (0x180032540) =====
// Microsoft VisualC v7/14 64bit runtime
_QWORD *__fastcall unknown_libname_2(_QWORD *a1)
{
  *a1 = 0LL;
  return a1;
}


// ===== 函数: sub_1800366C0 (0x1800366C0) =====
_QWORD *__fastcall sub_1800366C0(_QWORD *a1, __int64 a2, unsigned int a3)
{
  __int128 *v6; // rax
  __int64 (__fastcall **v7)(_QWORD *, __int64, __int64, _QWORD); // rax
  __int64 v8; // r8
  int v9; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  if ( a2 )
  {
    v6 = sub_180036EE0();
    v7 = (__int64 (__fastcall **)(_QWORD *, __int64, __int64, _QWORD))sub_180007790((__int64)v6);
    v8 = -1LL;
    do
      ++v8;
    while ( *(_BYTE *)(a2 + v8) );
    v9 = (*v7)(a1, a2, v8, a3);
    if ( v9 )
    {
      sub_180003F80((__int64)pExceptionObject, v9, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
  }
  return a1;
}


// ===== 函数: sub_1800180B0 (0x1800180B0) =====
void __fastcall sub_1800180B0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // rdi
  __int64 v7; // rsi
  __int64 v8; // rax
  _QWORD v9[2]; // [rsp+20h] [rbp-78h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+30h] [rbp-68h] BYREF
  _BYTE v11[40]; // [rsp+58h] [rbp-40h] BYREF
  __int64 v12; // [rsp+B8h] [rbp+20h] BYREF

  v9[1] = -2LL;
  if ( sub_1800376E0(a2) )
  {
    v6 = sub_180037420(a1, a2, 0LL);
    if ( v6 != -1LL )
    {
      v7 = sub_1800376E0(a2);
      if ( v6 > sub_1800376E0(a1) )
      {
        sub_180003F80((__int64)v11, 1431511369, 0LL);
        throw (ai::Error *)v11;
      }
      sub_1800376E0(a3);
      sub_1800373A0(a1, v6, v7);
      if ( v6 > sub_1800376E0(a1) )
      {
        sub_180003F80((__int64)pExceptionObject, 1431511369, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      sub_1800376E0(a3);
      sub_180037710(a1, &v12, 0LL, v6);
      sub_180037000(&v12, a3, 0LL, -1LL);
      v8 = sub_180037710(a1, v9, v6, -1LL);
      sub_180036F90(&v12, v8);
      sub_180036A90(v9);
      sub_180036B40(a1, &v12);
      sub_180036A90(&v12);
    }
  }
}


// ===== 函数: sub_1800376E0 (0x1800376E0) =====
__int64 __fastcall sub_1800376E0(__int64 a1)
{
  __int128 *v2; // rax
  __int64 v3; // rax

  v2 = sub_180036EE0();
  v3 = sub_180007790((__int64)v2);
  return (*(__int64 (__fastcall **)(__int64))(v3 + 128))(a1);
}


// ===== 函数: sub_180037420 (0x180037420) =====
__int64 __fastcall sub_180037420(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 *v6; // rax
  __int64 v7; // rax

  v6 = sub_180036EE0();
  v7 = sub_180007790((__int64)v6);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v7 + 160))(a1, a2, a3);
}


// ===== 函数: sub_1800373A0 (0x1800373A0) =====
__int64 __fastcall sub_1800373A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int128 *v6; // rax
  __int64 v7; // rax
  int v8; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v6 = sub_180036EE0();
  v7 = sub_180007790((__int64)v6);
  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v7 + 144))(a1, a2, a3);
  if ( v8 )
  {
    sub_180003F80((__int64)pExceptionObject, v8, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_180037000 (0x180037000) =====
__int64 __fastcall sub_180037000(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int128 *v8; // rax
  __int64 v9; // rax
  int v10; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v8 = sub_180036EE0();
  v9 = sub_180007790((__int64)v8);
  v10 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(v9 + 40))(a1, a2, a3, a4);
  if ( v10 )
  {
    sub_180003F80((__int64)pExceptionObject, v10, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_180036B40 (0x180036B40) =====
__int64 __fastcall sub_180036B40(__int64 a1, __int64 a2)
{
  __int128 *v4; // rax
  __int64 v5; // rax
  int v6; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v4 = sub_180036EE0();
  v5 = sub_180007790((__int64)v4);
  v6 = (*(__int64 (__fastcall **)(__int64, __int64))(v5 + 48))(a1, a2);
  if ( v6 )
  {
    sub_180003F80((__int64)pExceptionObject, v6, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_180037710 (0x180037710) =====
_QWORD *__fastcall sub_180037710(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int128 *v8; // rax
  __int64 v9; // rax
  int v10; // eax
  _BYTE pExceptionObject[48]; // [rsp+30h] [rbp-38h] BYREF

  *a2 = 0LL;
  v8 = sub_180036EE0();
  v9 = sub_180007790((__int64)v8);
  v10 = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64, __int64, int, __int64))(v9 + 264))(
          a2,
          a1,
          a3,
          a4,
          1,
          -2LL);
  if ( v10 )
  {
    sub_180003F80((__int64)pExceptionObject, v10, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a2;
}


// ===== 函数: sub_180036F90 (0x180036F90) =====
__int64 __fastcall sub_180036F90(__int64 a1, __int64 a2)
{
  __int128 *v4; // rax
  __int64 v5; // rax
  int v6; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v4 = sub_180036EE0();
  v5 = sub_180007790((__int64)v4);
  v6 = (*(__int64 (__fastcall **)(__int64, __int64))(v5 + 32))(a1, a2);
  if ( v6 )
  {
    sub_180003F80((__int64)pExceptionObject, v6, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a1;
}


// ===== 函数: sub_18000DB90 (0x18000DB90) =====
__int64 __fastcall sub_18000DB90(volatile signed __int32 *a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedExchangeAdd(a1 + 2, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
  {
    result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))a1)(a1);
    if ( _InterlockedExchangeAdd(a1 + 3, 0xFFFFFFFF) == 1 )
      return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)a1 + 8LL))(a1);
  }
  return result;
}


// ===== 函数: _Xtime_get_ticks (0x18004BC9A) =====
// attributes: thunk
__int64 __cdecl Xtime_get_ticks()
{
  return _Xtime_get_ticks();
}


// ===== 函数: _Query_perf_counter (0x18004BCA0) =====
// attributes: thunk
__int64 __cdecl Query_perf_counter()
{
  return _Query_perf_counter();
}


// ===== 函数: _Query_perf_frequency (0x18004BCA6) =====
// attributes: thunk
__int64 __cdecl Query_perf_frequency()
{
  return _Query_perf_frequency();
}


// ===== 函数: _Thrd_sleep (0x18004BCAC) =====
// attributes: thunk
void __cdecl Thrd_sleep(const xtime *a1)
{
  _Thrd_sleep(a1);
}


// ===== 函数: sub_18000DB30 (0x18000DB30) =====
_QWORD *__fastcall sub_18000DB30(__int64 a1, _QWORD *a2)
{
  *a2 = &std::_Func_impl_no_alloc<_lambda_8d6df5191765ee878e62fd07fc0bcca5_,void,_t_AIDocument *,unsigned int,unsigned int,int,std::vector<ai::UnicodeString>>::`vftable';
  a2[1] = *(_QWORD *)(a1 + 8);
  return a2;
}


// ===== 函数: sub_18000DF40 (0x18000DF40) =====
void __fastcall sub_18000DF40(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // rcx

  v4 = *(_QWORD *)(a2 + 56);
  if ( v4 )
  {
    if ( v4 == a2 )
    {
      *(_QWORD *)(a1 + 56) = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 8LL))(v4, a1);
      v6 = *(_QWORD *)(a2 + 56);
      if ( v6 )
      {
        LOBYTE(v5) = v6 != a2;
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 32LL))(v6, v5);
        *(_QWORD *)(a2 + 56) = 0LL;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 56) = v4;
      *(_QWORD *)(a2 + 56) = 0LL;
    }
  }
}


// ===== 函数: sub_18000C440 (0x18000C440) =====
_UNKNOWN **__fastcall sub_18000C440(__int64 a1)
{
  _UNKNOWN **result; // rax
  unsigned int v3; // r14d
  unsigned int v4; // edi
  __int64 v5; // rsi
  __int64 v6; // rbp
  __int64 (*v7)(__int64, __int64, _QWORD, _QWORD, __int64, const char *, ...); // rbx
  __int64 v8; // rax
  int v9; // [rsp+30h] [rbp-38h]
  _UNKNOWN *retaddr; // [rsp+68h] [rbp+0h] BYREF

  result = &retaddr;
  if ( !*(_BYTE *)(a1 + 41) )
  {
    v3 = *(unsigned __int8 *)(a1 + 40);
    v4 = sub_18000CDB0(a1);
    v5 = *(_QWORD *)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(__int64 (**)(__int64, __int64, _QWORD, _QWORD, __int64, const char *, ...))(gAIDevUtilsSuite + 248);
    v8 = sub_18000D970();
    v9 = v4;
    return (_UNKNOWN **)v7(v6, v5, v4, v3, v8, "%u,%s,%s", v9, v6, v5);
  }
  return result;
}


// ===== 函数: sub_18000CDB0 (0x18000CDB0) =====
__int64 __fastcall sub_18000CDB0(__int64 a1)
{
  __int64 result; // rax
  __int64 (__fastcall *v2)(__int64); // rsi
  __int64 v3; // rdi
  __int64 (__fastcall *v4)(__int64, __int64); // rbx
  __int64 v5; // rax

  result = gAIDevUtilsSuite;
  if ( gAIDevUtilsSuite )
  {
    v2 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
    v3 = *(_QWORD *)(a1 + 8);
    if ( !*(_BYTE *)a1 )
    {
      v4 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
      v5 = (*(__int64 (__fastcall **)(_QWORD))(gAIDevUtilsSuite + 112))(*(_QWORD *)(a1 + 16));
      v3 = v4(v5, v3);
    }
    return v2(v3);
  }
  return result;
}


// ===== 函数: sub_18000D970 (0x18000D970) =====
__int64 sub_18000D970()
{
  __int64 v1; // rcx
  __int64 (__fastcall *v2)(__int64); // rbx
  __int64 v3; // rax
  __int64 (__fastcall *v4)(_QWORD); // rdi
  __int64 v5; // rbx
  __int64 v6; // rcx
  __int64 (__fastcall *v7)(__int64); // rbx
  __int64 v8; // rax
  __int64 v9; // rax

  if ( dword_180074078 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return qword_180074070;
  Init_thread_header(&dword_180074078);
  if ( dword_180074078 != -1 )
    return qword_180074070;
  v2 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 120);
  v3 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 232))(v1);
  v4 = *(__int64 (__fastcall **)(_QWORD))(gAIDevUtilsSuite + 120);
  v5 = v2(v3);
  if ( v5 == v4(0LL) )
  {
    v9 = 0LL;
  }
  else
  {
    v7 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 120);
    v8 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 232))(v6);
    v9 = v7(v8);
  }
  qword_180074070 = v9;
  Init_thread_footer(&dword_180074078);
  return qword_180074070;
}


// ===== 函数: fxExportAllArtboardsWithEntitlementCheck (0x180011750) =====
// 函数名称定义
// 根据伪代码的行为和内部字符串，可以为其定义一个清晰的名称：
// 
// fxExportAllArtboardsWithEntitlementCheck
// 
// 这个名称准确地概括了其核心职责：在执行“导出所有画板”操作之前，先进行授权（Entitlement）检查。
// 
// 功能分析
// 该函数是“导出所有画板”这一用户命令的顶层入口点。它的主要职责是作为一个安全网关，首先验证用户是否有权使用此功能，然后在一个受保护的（try...catch）环境中调用核心的导出工作流程，并负责最终的性能日志记录和资源清理。
// 
// 核心工作流程如下：
// 
// 授权检查 (Entitlement Check)
// 
// 函数首先会检查 "AI APP ENTITLEMENT SUITE"，以验证用户是否有权限执行该导出操作 。
// 
// 如果授权检查失败，函数将立即返回错误码 
// 
// 2110LL，终止后续操作 。
// 
// 调用预处理函数
// 
// 它调用 
// 
// sub_18000CB80，该函数似乎用于准备导出命令或将其记录到某个内部系统（提到了 "AIAIRobinClientSuite"） 。
// 
// 
// 执行核心导出逻辑 (在 try...catch 块中)
// 
// 
// 设置进度/撤销状态: 调用 sub_18000BDF0 来初始化一个进度处理器或为后续操作准备撤销（Undo）状态 。
// 
// 
// 调用主导出模块: 核心的导出工作被委托给 sub_1800286B0 函数。此函数接收所有必要的参数（如进度处理器、导出设置等）来完成所有画板的导出任务 。
// 
// 
// 
// 性能日志: 操作完成后，它会记录本次操作的性能指标，比如执行时间 。
// 
// 
// 
// 
// 
// 资源清理: 最后调用 sub_18000C610 来释放 sub_18000BDF0 创建的资源 。
// 
// 异常处理
// 
// 整个核心逻辑被一个 
// 
// try...catch 块包围，能够捕获多种类型的异常（如 ai::Error, std::exception 等），确保程序在出错时不会崩溃，而是返回一个明确的错误码 。
// 
// 参数作用解释
// 该函数接收四个参数，它们共同定义了导出任务的配置和上下文。
// 
// int a1 (可能是 ProgressHandler*)
// 
// 
// 作用: 输入参数。这是一个进度处理器，用于在耗时较长的导出过程中向用户界面报告进度。它被传递给核心工作函数 sub_1800286B0 。
// 
// 
// 
// int a2 (未使用)
// 
// 
// 作用: 在当前函数的伪代码中，此参数没有被直接使用，但被传递给了下游函数 。
// 
// 
// 
// __int64 a3 (可能是 ExportSettings*)
// 
// 
// 作用: 输入参数。这是一个指向导出设置的指针，很可能是一个包含所有导出参数（如格式、分辨率、路径等）的JSON对象或类似的数据结构。它被传递给核心工作函数 sub_1800286B0 。
// 
// 
// 
// __int64 a4 (可能是 ExportStatus*)
// 
// 
// 作用: 输出参数。这是一个指针，用于返回整个导出操作的最终状态码。函数通过它将成功或失败的结果传递给调用者 。
__int64 __fastcall fxExportAllArtboardsWithEntitlementCheck(int a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  char v7; // r14
  __int64 v8; // rdx
  _DWORD *v9; // r15
  int v10; // eax
  _QWORD *v11; // rax
  _QWORD *v12; // rax
  unsigned int (__fastcall *v13)(_QWORD, __int128 *); // r8
  unsigned int v14; // esi
  char v15; // bl
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v20; // rbx
  __int64 v21; // r14
  __int64 v22; // rdx
  unsigned int v23; // r12d
  __int64 v24; // rcx
  __int64 v25; // rax
  __int64 (__fastcall *v26)(__int64); // r15
  __int64 v27; // rsi
  __int64 (__fastcall *v28)(__int64, __int64); // rbx
  __int64 v29; // rax
  void (*v30)(const char *, const char *, _QWORD, _QWORD, __int64, const char *, ...); // rbx
  __int64 v31; // rax
  __int64 v32; // rcx
  __int64 v33; // rcx
  _BYTE v34[32]; // [rsp+0h] [rbp-228h] BYREF
  __int64 v35; // [rsp+30h] [rbp-1F8h]
  __int64 v36; // [rsp+50h] [rbp-1D8h]
  unsigned int v37; // [rsp+58h] [rbp-1D0h]
  unsigned int v38; // [rsp+60h] [rbp-1C8h] BYREF
  _BYTE v39[8]; // [rsp+68h] [rbp-1C0h] BYREF
  __int64 v40; // [rsp+70h] [rbp-1B8h]
  __int64 v41; // [rsp+78h] [rbp-1B0h]
  const char *v42; // [rsp+80h] [rbp-1A8h]
  const char *v43; // [rsp+88h] [rbp-1A0h]
  __int16 v44; // [rsp+90h] [rbp-198h]
  __int64 v45; // [rsp+98h] [rbp-190h]
  __int64 v46; // [rsp+A0h] [rbp-188h]
  const ai::Error *v47; // [rsp+A8h] [rbp-180h] BYREF
  __int128 v48; // [rsp+B0h] [rbp-178h]
  __int128 v49; // [rsp+C0h] [rbp-168h]
  __int64 v50; // [rsp+D0h] [rbp-158h]
  _OWORD v51[2]; // [rsp+E0h] [rbp-148h] BYREF
  __int64 v52; // [rsp+100h] [rbp-128h]
  _BYTE pExceptionObject[40]; // [rsp+110h] [rbp-118h] BYREF
  _BYTE v54[56]; // [rsp+138h] [rbp-F0h] BYREF
  __int64 v55; // [rsp+170h] [rbp-B8h]
  _BYTE v56[56]; // [rsp+178h] [rbp-B0h] BYREF
  __int64 v57; // [rsp+1B0h] [rbp-78h]
  __int128 v58; // [rsp+1B8h] [rbp-70h] BYREF
  __int64 v59; // [rsp+1C8h] [rbp-60h]
  unsigned __int64 v60; // [rsp+1D0h] [rbp-58h]
  const std::exception *v61; // [rsp+1D8h] [rbp-50h] BYREF

  v46 = -2LL;
  v45 = a4;
  v36 = a3;
  v7 = 0;
  v37 = 0;
  v8 = 4LL;
  v9 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL);
  if ( dword_1800740A8 > *v9 )
  {
    Init_thread_header(&dword_1800740A8);
    if ( dword_1800740A8 == -1 )
    {
      xmmword_180074088 = 0LL;
      qword_180074098 = (__int64)"AI APP ENTITLEMENT SUITE";
      dword_1800740A0 = 1;
      byte_1800740A4 = 0;
      Init_thread_footer(&dword_1800740A8);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074088 + 1) && qword_1800740D8 )
  {
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074098,
           (unsigned int)dword_1800740A0,
           (char *)&xmmword_180074088 + 8) )
    {
      *((_QWORD *)&xmmword_180074088 + 1) = 0LL;
    }
    else if ( !byte_1800740A4 )
    {
      v11 = sub_180012E90();
      *(_QWORD *)&xmmword_180074088 = *v11;
      *v11 = &xmmword_180074088;
    }
  }
  if ( !*((_QWORD *)&xmmword_180074088 + 1) )
  {
    v14 = 0;
LABEL_19:
    v15 = 0;
    goto LABEL_20;
  }
  if ( dword_1800740A8 > *v9 )
  {
    Init_thread_header(&dword_1800740A8);
    if ( dword_1800740A8 == -1 )
    {
      xmmword_180074088 = 0LL;
      qword_180074098 = (__int64)"AI APP ENTITLEMENT SUITE";
      dword_1800740A0 = 1;
      byte_1800740A4 = 0;
      Init_thread_footer(&dword_1800740A8);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074088 + 1) && qword_1800740D8 )
  {
    v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
            qword_180074098,
            (unsigned int)dword_1800740A0,
            (char *)&xmmword_180074088 + 8);
    if ( v10 )
    {
      sub_180003F80((__int64)pExceptionObject, v10, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !byte_1800740A4 )
    {
      v12 = sub_180012E90();
      *(_QWORD *)&xmmword_180074088 = *v12;
      *v12 = &xmmword_180074088;
    }
  }
  v13 = (unsigned int (__fastcall *)(_QWORD, __int128 *))**((_QWORD **)&xmmword_180074088 + 1);
  v14 = 0;
  *(_QWORD *)&v58 = 0LL;
  v60 = 15LL;
  v59 = 0LL;
  v7 = 1;
  v37 = 1;
  if ( v13(0LL, &v58) )
    goto LABEL_19;
  v15 = 1;
LABEL_20:
  if ( (v7 & 1) != 0 )
  {
    v8 = v60;
    if ( v60 >= 0x10 )
    {
      v16 = v58;
      if ( v60 + 1 >= 0x1000 )
      {
        v16 = *(_QWORD *)(v58 - 8);
        if ( (unsigned __int64)(v58 - v16 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18001AE10(v16);
    }
  }
  if ( v15 )
  {
    v17 = *(_QWORD *)(a3 + 120);
    if ( v17 )
    {
      LOBYTE(v8) = v17 != a3 + 64;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v17 + 32LL))(v17, v8);
      *(_QWORD *)(a3 + 120) = 0LL;
    }
    v18 = *(_QWORD *)(a3 + 56);
    if ( v18 )
    {
      LOBYTE(v8) = v18 != a3;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v18 + 32LL))(v18, v8);
      *(_QWORD *)(a3 + 56) = 0LL;
    }
    return 2110LL;
  }
  else
  {
    try
    {
      v39[0] = 0;
      if ( gAIDevUtilsSuite )
      {
        v40 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
        v41 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
      }
      v42 = "fxExportFastAssets";
      v43 = "SmartExport";
      v44 = 0;
      v58 = 0LL;
      v59 = 0LL;
      v20 = sub_180016BF0(qword_180074190);
      LOBYTE(v50) = 0;
      v55 = 0LL;
      sub_18000DF40((__int64)v54, a3);
      v57 = 0LL;
      v21 = a3 + 64;
      sub_18000DF40((__int64)v56, a3 + 64);
      v51[0] = v48;
      v51[1] = v49;
      v52 = v50;
      v23 = sub_180008D60(v20, a1, a2, (__int64)v54, v45, (__int64)v39, (__int64)&v58, (__int64)v51);
      v24 = v58;
      if ( (_QWORD)v58 )
      {
        if ( ((v59 - (_QWORD)v58) & 0xFFFFFFFFFFFFFFF0uLL) >= 0x1000 )
        {
          v24 = *(_QWORD *)(v58 - 8);
          if ( (unsigned __int64)(v58 - v24 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v24);
        v58 = 0LL;
        v59 = 0LL;
      }
      if ( !HIBYTE(v44) )
      {
        v25 = gAIDevUtilsSuite;
        if ( gAIDevUtilsSuite )
        {
          v26 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
          v27 = v40;
          if ( !v39[0] )
          {
            v28 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
            v29 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v41);
            v27 = v28(v29, v27);
          }
          v14 = v26(v27);
          v25 = gAIDevUtilsSuite;
        }
        v30 = *(void (**)(const char *, const char *, _QWORD, _QWORD, __int64, const char *, ...))(v25 + 248);
        v31 = sub_18000D970();
        LODWORD(v35) = v14;
        v30(v43, v42, v14, (unsigned __int8)v44, v31, "%u,%s,%s", v35, v43, v42);
      }
    }
    catch ( const ai::Error *v47 )
    {
      if ( *((_DWORD *)v47 + 6) && *((_DWORD *)v47 + 6) != 1398034256 )
        goto LABEL_50;
      v37 = *((_DWORD *)v47 + 6);
      sub_18000C590(v36, (__int64)v34);
      return v37;
    }
    catch ( const std::exception *v61 )
    {
      goto LABEL_50;
    }
    catch ( int v38 )
    {
      if ( v38 && v38 != 1398034256 )
        goto LABEL_50;
      sub_18000C590(v36, (__int64)v34);
      return v38;
    }
    catch ( ... )
    {
LABEL_50:
      sub_18000C590(v36, (__int64)v34);
      return 1128353364LL;
    }
    v32 = *(_QWORD *)(v21 + 56);
    if ( v32 )
    {
      LOBYTE(v22) = v32 != v21;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v32 + 32LL))(v32, v22);
      *(_QWORD *)(v21 + 56) = 0LL;
    }
    v33 = *(_QWORD *)(a3 + 56);
    if ( v33 )
    {
      LOBYTE(v22) = v33 != a3;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v33 + 32LL))(v33, v22);
      *(_QWORD *)(a3 + 56) = 0LL;
    }
    return v23;
  }
}


// ===== 函数: sub_180008D60 (0x180008D60) =====
__int64 __fastcall sub_180008D60(
        __int64 a1,
        int a2,
        _QWORD *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int64 v8; // rdi
  __int64 v12; // rdx
  unsigned int v13; // r14d
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v17; // rdx
  void **v18; // r8
  unsigned int v19; // r15d
  __int64 v20; // rdx
  __int64 v21; // r8
  _QWORD *v22; // r14
  _QWORD *v23; // rbx
  __int64 v24; // rax
  __int64 v25; // [rsp+50h] [rbp-178h] BYREF
  __int64 v26; // [rsp+58h] [rbp-170h] BYREF
  __int128 v27; // [rsp+60h] [rbp-168h] BYREF
  __int64 v28; // [rsp+70h] [rbp-158h]
  __int64 v29; // [rsp+78h] [rbp-150h] BYREF
  unsigned __int64 v30[5]; // [rsp+88h] [rbp-140h] BYREF
  _OWORD v31[2]; // [rsp+B0h] [rbp-118h] BYREF
  __int64 v32; // [rsp+D0h] [rbp-F8h]
  _BYTE v33[56]; // [rsp+E0h] [rbp-E8h] BYREF
  __int64 v34; // [rsp+118h] [rbp-B0h]
  _BYTE v35[56]; // [rsp+120h] [rbp-A8h] BYREF
  __int64 v36; // [rsp+158h] [rbp-70h]
  _QWORD v37[10]; // [rsp+160h] [rbp-68h] BYREF

  v30[2] = -2LL;
  v8 = a4;
  v29 = 0LL;
  v13 = (*(__int64 (__fastcall **)(__int64 *))(gAIDocumentSuite + 160))(&v29);
  if ( v13 )
  {
    v14 = *(_QWORD *)(v8 + 120);
    if ( v14 )
    {
      LOBYTE(v12) = v14 != v8 + 64;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v14 + 32LL))(v14, v12);
      *(_QWORD *)(v8 + 120) = 0LL;
    }
    v15 = *(_QWORD *)(v8 + 56);
    if ( v15 )
    {
      LOBYTE(v12) = v15 != v8;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v15 + 32LL))(v15, v12);
      *(_QWORD *)(v8 + 56) = 0LL;
    }
    return v13;
  }
  else if ( sub_180015FC0(a1 + 16, v29) )
  {
    sub_18000C590(v8, v17);
    return 2050LL;
  }
  else
  {
    v27 = 0LL;
    v28 = 0LL;
    sub_18000BC80((__int64)v37, (__int64)a3);
    sub_18002DF30((__int64)v37, (__int64)&v27);
    unknown_libname_2(&v26);
    sub_180032600(&v26, a3);
    try
    {
      v30[3] = (unsigned __int64)v33;
      v34 = 0LL;
      sub_18000DF40((__int64)v33, v8);
      v36 = 0LL;
      sub_18000DF40((__int64)v35, v8 + 64);
      sub_18000BBA0(v30, a3 + 4, v18);
      v25 = v26;
      v26 = 0LL;
      v31[0] = *(_OWORD *)a8;
      v31[1] = *(_OWORD *)(a8 + 16);
      v32 = *(_QWORD *)(a8 + 32);
      v19 = sub_180009D70(
              a1,
              a2,
              (unsigned int)&v27,
              (unsigned int)&v25,
              (__int64)v30,
              (__int64)v33,
              a5,
              a6,
              a7,
              (__int64)v31);
    }
    catch ( ... )
    {
      LODWORD(v25) = 1128353364;
      v8 = a4;
      v19 = 1128353364;
    }
    sub_180032550(&v26);
    sub_18000C4E0(v37);
    v21 = v27;
    if ( (_QWORD)v27 )
    {
      v22 = (_QWORD *)*((_QWORD *)&v27 + 1);
      if ( (_QWORD)v27 != *((_QWORD *)&v27 + 1) )
      {
        v23 = (_QWORD *)(v27 + 8);
        do
        {
          sub_180036A90(v23 + 1);
          sub_180036A90(v23);
          v23 += 5;
        }
        while ( v23 - 1 != v22 );
        v21 = v27;
      }
      v24 = v21;
      if ( (unsigned __int64)(40 * ((v28 - v21) / 40)) >= 0x1000 )
      {
        v21 = *(_QWORD *)(v21 - 8);
        if ( (unsigned __int64)(v24 - v21 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18001AE10(v21);
      v27 = 0LL;
      v28 = 0LL;
    }
    sub_18000C590(v8, v20);
    return v19;
  }
}


// ===== 函数: sub_180015FC0 (0x180015FC0) =====
bool __fastcall sub_180015FC0(__int64 a1, __int64 a2)
{
  struct _Mtx_internal_imp_t *v2; // rdi
  int v5; // eax
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rsi
  unsigned __int64 v9; // rcx
  __int64 v10; // rbx
  __int64 v11; // rax

  v2 = (struct _Mtx_internal_imp_t *)(a1 + 64);
  v5 = Mtx_lock((_Mtx_t)(a1 + 64));
  if ( v5 )
  {
    std::_Throw_C_error(v5);
    JUMPOUT(0x1800160D4LL);
  }
  v6 = *(_QWORD *)(a1 + 24);
  v7 = *(_QWORD *)(a1 + 48);
  v8 = *(_QWORD *)(a1 + 8);
  v9 = 2
     * ((0x100000001B3LL
       * (HIBYTE(a2) ^ (0x100000001B3LL
                      * (BYTE6(a2) ^ (0x100000001B3LL
                                    * (BYTE5(a2) ^ (0x100000001B3LL
                                                  * (BYTE4(a2) ^ (0x100000001B3LL
                                                                * (BYTE3(a2) ^ (0x100000001B3LL
                                                                              * (BYTE2(a2) ^ (0x100000001B3LL
                                                                                            * (BYTE1(a2) ^ (0x100000001B3LL * ((unsigned __int8)a2 ^ 0xCBF29CE484222325uLL)))))))))))))))) & v7);
  v10 = *(_QWORD *)(v6 + 8 * v9 + 8);
  if ( v10 != v8 )
  {
    v11 = *(_QWORD *)(v6 + 8 * v9);
    if ( a2 == *(_QWORD *)(v10 + 16) )
      goto LABEL_8;
    while ( v10 != v11 )
    {
      v10 = *(_QWORD *)(v10 + 8);
      if ( a2 == *(_QWORD *)(v10 + 16) )
        goto LABEL_8;
    }
  }
  v10 = 0LL;
LABEL_8:
  if ( !v10 )
    v10 = v8;
  Mtx_unlock(v2);
  return v10 != v8;
}


// ===== 函数: ?_Throw_C_error@std@@YAXH@Z (0x18004BD00) =====
// attributes: thunk
void __fastcall std::_Throw_C_error(int a1)
{
  __imp_?_Throw_C_error@std@@YAXH@Z(a1);
}


// ===== 函数: _Mtx_unlock (0x18004BCFA) =====
// attributes: thunk
int __cdecl Mtx_unlock(_Mtx_t a1)
{
  return _Mtx_unlock(a1);
}


// ===== 函数: _Mtx_lock (0x18004BCF4) =====
// attributes: thunk
int __cdecl Mtx_lock(_Mtx_t a1)
{
  return _Mtx_lock(a1);
}


// ===== 函数: sub_180032600 (0x180032600) =====
_QWORD *__fastcall sub_180032600(_QWORD *a1, _QWORD *a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  int v6; // eax
  _QWORD *v7; // rax
  int v8; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  if ( *a2 || *a1 )
  {
    v4 = sub_180032E90(&unk_18007452C);
    v5 = v4;
    if ( !*(_QWORD *)(v4 + 8) && qword_1800740D8 )
    {
      v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
             *(_QWORD *)(v4 + 16),
             *(unsigned int *)(v4 + 24),
             v4 + 8);
      if ( v6 )
      {
        sub_180003F80((__int64)pExceptionObject, v6, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      if ( !*(_BYTE *)(v5 + 28) )
      {
        v7 = sub_180012E90();
        *(_QWORD *)v5 = *v7;
        *v7 = v5;
      }
    }
    v8 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD *))(*(_QWORD *)(v5 + 8) + 16LL))(a2, a1);
    if ( v8 )
    {
      sub_180003F80((__int64)pExceptionObject, v8, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
  }
  return a1;
}


// ===== 函数: sub_18000C590 (0x18000C590) =====
__int64 __fastcall sub_18000C590(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v4; // rcx
  __int64 result; // rax
  __int64 v6; // rcx

  v2 = a1 + 64;
  v4 = *(_QWORD *)(a1 + 120);
  if ( v4 )
  {
    LOBYTE(a2) = v4 != v2;
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 32LL))(v4, a2);
    *(_QWORD *)(v2 + 56) = 0LL;
  }
  v6 = *(_QWORD *)(a1 + 56);
  if ( v6 )
  {
    LOBYTE(a2) = v6 != a1;
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 32LL))(v6, a2);
    *(_QWORD *)(a1 + 56) = 0LL;
  }
  return result;
}


// ===== 函数: sub_180009D70 (0x180009D70) =====
__int64 __fastcall sub_180009D70(
        __int64 a1,
        _QWORD *a2,
        __int64 *a3,
        _QWORD *a4,
        void *a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v16; // rax
  void (__fastcall *v17)(__int64); // rbx
  __int64 v18; // rax
  char *v19; // rbx
  char *v20; // rdi
  char *v21; // rax
  __int64 v22; // r8
  __int64 *v23; // r13
  __int64 *v24; // rdi
  __int64 v25; // rbx
  __int64 i; // r14
  __int64 v27; // r8
  __int64 v28; // rax
  __int64 v29; // rdx
  _QWORD *v30; // rbx
  char *v31; // rbx
  char *v32; // rdi
  char *v33; // rax
  __int64 v34; // r8
  __int64 *v35; // r13
  __int64 *v36; // rdi
  __int64 v37; // rbx
  __int64 k; // r14
  __int64 v39; // r8
  __int64 v40; // rax
  unsigned __int128 v41; // kr00_16
  __int64 v42; // rcx
  __int64 v43; // rdx
  _QWORD *v44; // rdx
  char *v45; // rbx
  char *v46; // rdi
  char *v47; // rax
  __int64 v48; // r8
  __int64 *v49; // r13
  __int64 *v50; // rdi
  __int64 v51; // rbx
  __int64 j; // r14
  __int64 v53; // r8
  __int64 v54; // rax
  __int64 v55; // rdx
  __int64 v56; // [rsp+40h] [rbp-C0h] BYREF
  _OWORD v57[3]; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v58; // [rsp+78h] [rbp-88h]
  int v59; // [rsp+80h] [rbp-80h] BYREF
  unsigned int v60; // [rsp+84h] [rbp-7Ch]
  _QWORD *v61; // [rsp+88h] [rbp-78h]
  unsigned __int128 v62; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int128 v63; // [rsp+A0h] [rbp-60h] BYREF
  void *v64[6]; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int128 v65; // [rsp+E0h] [rbp-20h]
  __int128 v66; // [rsp+F0h] [rbp-10h]
  __int128 v67; // [rsp+100h] [rbp+0h]
  __int64 v68; // [rsp+110h] [rbp+10h]
  __int64 v69; // [rsp+120h] [rbp+20h]
  _QWORD v70[7]; // [rsp+130h] [rbp+30h] BYREF
  _QWORD *v71; // [rsp+168h] [rbp+68h]

  v64[3] = (void *)-2LL;
  v61 = a4;
  *(_QWORD *)&v63 = a2;
  v64[4] = a4;
  v64[5] = a5;
  v58 = a6;
  v69 = a6;
  v56 = a10;
  if ( *a3 != a3[1] )
  {
    v16 = (__int64)(a2[1] - *a2) >> 3;
    v59 = 1;
    v60 = v16 + 1;
    v17 = *(void (__fastcall **)(__int64))(gAIUserSuite + 24);
    v18 = sub_180004150((__int64 *)&off_180072168);
    v17(v18);
    (*(void (__fastcall **)(__int64, _QWORD))(gAIUserSuite + 8))(1LL, v60);
    memset(v57, 0, sizeof(v57));
    v66 = *(_OWORD *)v56;
    v67 = *(_OWORD *)(v56 + 16);
    v68 = *(_QWORD *)(v56 + 32);
    LODWORD(v56) = sub_18002E370(a1, v63, (_DWORD)a3, (unsigned int)v57, (__int64)&v59);
    if ( (_DWORD)v56 )
    {
      v19 = (char *)*((_QWORD *)&v57[1] + 1);
      if ( *((_QWORD *)&v57[1] + 1) )
      {
        v20 = *(char **)&v57[2];
        if ( *((_QWORD *)&v57[1] + 1) != *(_QWORD *)&v57[2] )
        {
          do
          {
            sub_18000C810(v19);
            v19 += 8;
          }
          while ( v19 != v20 );
          v19 = (char *)*((_QWORD *)&v57[1] + 1);
        }
        v21 = v19;
        if ( (unsigned __int64)(8 * ((__int64)(*((_QWORD *)&v57[2] + 1) - (_QWORD)v19) >> 3)) >= 0x1000 )
        {
          v19 = (char *)*((_QWORD *)v19 - 1);
          if ( (unsigned __int64)(v21 - v19 - 8) > 0x1F )
            goto LABEL_85;
        }
        sub_18001AE10((__int64)v19);
        memset((char *)&v57[1] + 8, 0, 24);
      }
      v22 = *(_QWORD *)&v57[0];
      if ( !*(_QWORD *)&v57[0] )
      {
LABEL_30:
        (*(void (**)(void))(gAIUserSuite + 32))();
        sub_180032550(v61);
        sub_18000B7F0((__int64)a5, (__int64)a5, *(_QWORD *)(*(_QWORD *)a5 + 8LL));
        sub_18001AE10(*(_QWORD *)a5);
        sub_18000C590(v58, v29);
        return (unsigned int)v56;
      }
      v23 = (__int64 *)*((_QWORD *)&v57[0] + 1);
      if ( *(_QWORD *)&v57[0] != *((_QWORD *)&v57[0] + 1) )
      {
        v24 = (__int64 *)(*(_QWORD *)&v57[0] + 8LL);
        do
        {
          v25 = *v24;
          if ( *v24 )
          {
            for ( i = v24[1]; v25 != i; v25 += 88LL )
            {
              sub_180036A90((_QWORD *)(v25 + 16));
              sub_180036A90((_QWORD *)(v25 + 8));
            }
            v27 = *v24;
            if ( (unsigned __int64)(88 * ((v24[2] - *v24) / 88)) >= 0x1000 )
            {
              if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
                goto LABEL_85;
              v27 = *(_QWORD *)(v27 - 8);
            }
            sub_18001AE10(v27);
            *v24 = 0LL;
            v24[1] = 0LL;
            v24[2] = 0LL;
          }
          sub_180036A90(v24 - 1);
          v24 += 5;
        }
        while ( v24 - 1 != v23 );
        v22 = *(_QWORD *)&v57[0];
      }
      v28 = v22;
      if ( (unsigned __int64)(40 * ((*(_QWORD *)&v57[1] - v22) / 40)) < 0x1000
        || (v22 = *(_QWORD *)(v22 - 8), (unsigned __int64)(v28 - v22 - 8) <= 0x1F) )
      {
        sub_18001AE10(v22);
        memset(v57, 0, 24);
        goto LABEL_30;
      }
    }
    else
    {
      sub_1800305C0(v64, 7u);
      sub_1800311C0((__int64 *)v64, a3);
      v30 = v61;
      LODWORD(v56) = sub_18002EC30(a1, (__int64)v57, (__int64)v64, (__int64 **)a5, v61, a9);
      if ( !(_DWORD)v56 )
      {
        LODWORD(v56) = sub_18000CDB0(a8);
        sub_18000B980(&v62, (__int64)v57, v64, v30, (unsigned __int64 *)a5, v58, a1 + 16, (int *)&v56);
        v41 = 0uLL;
        if ( *((_QWORD *)&v62 + 1) )
        {
          _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v62 + 1) + 12LL));
          v41 = v62;
        }
        v65 = v41;
        v42 = 0LL;
        v43 = 0LL;
        if ( *((_QWORD *)&v41 + 1) )
        {
          _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v41 + 1) + 12LL));
          v43 = v41 >> 64;
          v42 = v41;
        }
        v70[0] = &std::_Func_impl_no_alloc<_lambda_9e3a4d60660026a397d4ed18b731fb14_,void,>::`vftable';
        v70[1] = v42;
        v70[2] = v43;
        v71 = v70;
        sub_180012D50((__int64)v70, a7);
        if ( v71 )
        {
          v44 = v70;
          LOBYTE(v44) = v71 != v70;
          (*(void (__fastcall **)(_QWORD *, _QWORD *))(*v71 + 32LL))(v71, v44);
        }
        sub_1800160E0(a1 + 16, *(_QWORD *)(v62 + 112));
        v63 = v62;
        v62 = 0LL;
        sub_18000DA40(*(tbb::internal::concurrent_queue_base_v8 **)(a1 + 8), &v63);
        if ( *((_QWORD *)&v41 + 1)
          && _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v41 + 1) + 12LL), 0xFFFFFFFF) == 1 )
        {
          (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v41 + 1) + 8LL))(*((_QWORD *)&v41 + 1));
        }
        sub_18000E230((__int64 *)v64);
        v45 = (char *)*((_QWORD *)&v57[1] + 1);
        if ( *((_QWORD *)&v57[1] + 1) )
        {
          v46 = *(char **)&v57[2];
          if ( *((_QWORD *)&v57[1] + 1) != *(_QWORD *)&v57[2] )
          {
            do
            {
              sub_18000C810(v45);
              v45 += 8;
            }
            while ( v45 != v46 );
            v45 = (char *)*((_QWORD *)&v57[1] + 1);
          }
          v47 = v45;
          if ( (unsigned __int64)(8 * ((__int64)(*((_QWORD *)&v57[2] + 1) - (_QWORD)v45) >> 3)) >= 0x1000 )
          {
            v45 = (char *)*((_QWORD *)v45 - 1);
            if ( (unsigned __int64)(v47 - v45 - 8) > 0x1F )
              goto LABEL_85;
          }
          sub_18001AE10((__int64)v45);
          memset((char *)&v57[1] + 8, 0, 24);
        }
        v48 = *(_QWORD *)&v57[0];
        if ( *(_QWORD *)&v57[0] )
        {
          v49 = (__int64 *)*((_QWORD *)&v57[0] + 1);
          if ( *(_QWORD *)&v57[0] != *((_QWORD *)&v57[0] + 1) )
          {
            v50 = (__int64 *)(*(_QWORD *)&v57[0] + 8LL);
            do
            {
              v51 = *v50;
              if ( *v50 )
              {
                for ( j = v50[1]; v51 != j; v51 += 88LL )
                {
                  sub_180036A90((_QWORD *)(v51 + 16));
                  sub_180036A90((_QWORD *)(v51 + 8));
                }
                v53 = *v50;
                if ( (unsigned __int64)(88 * ((v50[2] - *v50) / 88)) >= 0x1000 )
                {
                  if ( (unsigned __int64)(v53 - *(_QWORD *)(v53 - 8) - 8) > 0x1F )
                    goto LABEL_85;
                  v53 = *(_QWORD *)(v53 - 8);
                }
                sub_18001AE10(v53);
                *v50 = 0LL;
                v50[1] = 0LL;
                v50[2] = 0LL;
              }
              sub_180036A90(v50 - 1);
              v50 += 5;
            }
            while ( v50 - 1 != v49 );
            v48 = *(_QWORD *)&v57[0];
          }
          v54 = v48;
          if ( (unsigned __int64)(40 * ((*(_QWORD *)&v57[1] - v48) / 40)) >= 0x1000 )
          {
            v48 = *(_QWORD *)(v48 - 8);
            if ( (unsigned __int64)(v54 - v48 - 8) > 0x1F )
              goto LABEL_85;
          }
          sub_18001AE10(v48);
          memset(v57, 0, 24);
        }
        (*(void (**)(void))(gAIUserSuite + 32))();
        sub_180032550(v61);
        sub_18000B7F0((__int64)a5, (__int64)a5, *(_QWORD *)(*(_QWORD *)a5 + 8LL));
        sub_18001AE10(*(_QWORD *)a5);
        sub_18000C590(v58, v55);
        return 0LL;
      }
      sub_18000E230((__int64 *)v64);
      v31 = (char *)*((_QWORD *)&v57[1] + 1);
      if ( *((_QWORD *)&v57[1] + 1) )
      {
        v32 = *(char **)&v57[2];
        if ( *((_QWORD *)&v57[1] + 1) != *(_QWORD *)&v57[2] )
        {
          do
          {
            sub_18000C810(v31);
            v31 += 8;
          }
          while ( v31 != v32 );
          v31 = (char *)*((_QWORD *)&v57[1] + 1);
        }
        v33 = v31;
        if ( (unsigned __int64)(8 * ((__int64)(*((_QWORD *)&v57[2] + 1) - (_QWORD)v31) >> 3)) >= 0x1000 )
        {
          v31 = (char *)*((_QWORD *)v31 - 1);
          if ( (unsigned __int64)(v33 - v31 - 8) > 0x1F )
            goto LABEL_85;
        }
        sub_18001AE10((__int64)v31);
        memset((char *)&v57[1] + 8, 0, 24);
      }
      v34 = *(_QWORD *)&v57[0];
      if ( !*(_QWORD *)&v57[0] )
        goto LABEL_30;
      v35 = (__int64 *)*((_QWORD *)&v57[0] + 1);
      if ( *(_QWORD *)&v57[0] != *((_QWORD *)&v57[0] + 1) )
      {
        v36 = (__int64 *)(*(_QWORD *)&v57[0] + 8LL);
        do
        {
          v37 = *v36;
          if ( *v36 )
          {
            for ( k = v36[1]; v37 != k; v37 += 88LL )
            {
              sub_180036A90((_QWORD *)(v37 + 16));
              sub_180036A90((_QWORD *)(v37 + 8));
            }
            v39 = *v36;
            if ( (unsigned __int64)(88 * ((v36[2] - *v36) / 88)) >= 0x1000 )
            {
              if ( (unsigned __int64)(v39 - *(_QWORD *)(v39 - 8) - 8) > 0x1F )
                goto LABEL_85;
              v39 = *(_QWORD *)(v39 - 8);
            }
            sub_18001AE10(v39);
            *v36 = 0LL;
            v36[1] = 0LL;
            v36[2] = 0LL;
          }
          sub_180036A90(v36 - 1);
          v36 += 5;
        }
        while ( v36 - 1 != v35 );
        v34 = *(_QWORD *)&v57[0];
      }
      v40 = v34;
      if ( (unsigned __int64)(40 * ((*(_QWORD *)&v57[1] - v34) / 40)) < 0x1000
        || (v34 = *(_QWORD *)(v34 - 8), (unsigned __int64)(v40 - v34 - 8) <= 0x1F) )
      {
        sub_18001AE10(v34);
        memset(v57, 0, 24);
        goto LABEL_30;
      }
    }
LABEL_85:
    invalid_parameter_noinfo_noreturn();
  }
  sub_180032550(a4);
  sub_18000B7F0((__int64)a5, (__int64)a5, *(_QWORD *)(*(_QWORD *)a5 + 8LL));
  sub_18001AE10(*(_QWORD *)a5);
  v13 = *(_QWORD *)(a6 + 120);
  if ( v13 )
  {
    LOBYTE(v12) = v13 != a6 + 64;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 32LL))(v13, v12);
    *(_QWORD *)(a6 + 120) = 0LL;
  }
  v14 = *(_QWORD *)(v58 + 56);
  if ( v14 )
  {
    LOBYTE(v12) = v14 != v58;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v14 + 32LL))(v14, v12);
    *(_QWORD *)(v58 + 56) = 0LL;
  }
  return 1128353364LL;
}


// ===== 函数: sub_1800305C0 (0x1800305C0) =====
_QWORD *__fastcall sub_1800305C0(_QWORD *a1, unsigned __int8 a2)
{
  char v4; // [rsp+48h] [rbp+10h] BYREF

  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if ( a2 )
    sub_180030060(a1, a2, &v4);
  return a1;
}


// ===== 函数: sub_180030060 (0x180030060) =====
unsigned __int64 __fastcall sub_180030060(__int64 *a1, unsigned __int64 a2, void **a3)
{
  __int64 v5; // r13
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rbx
  _DWORD *v12; // r10
  _DWORD *v13; // rcx
  _DWORD *v14; // r9
  unsigned __int64 v15; // r8
  _DWORD *v16; // rdx
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // r8
  unsigned __int64 result; // rax
  __int64 v22; // [rsp+20h] [rbp-58h]
  unsigned __int64 v24; // [rsp+88h] [rbp+10h]
  unsigned __int64 v25; // [rsp+98h] [rbp+20h]

  if ( a2 > 0x249249249249249LL )
    std::vector<void *>::_Xlen();
  v5 = (a1[1] - *a1) / 112;
  v6 = (a1[2] - *a1) / 112;
  v7 = v6 >> 1;
  if ( v6 > 0x249249249249249LL - (v6 >> 1) )
    goto LABEL_25;
  v8 = v7 + v6;
  if ( v7 + v6 >= a2 )
  {
    if ( v8 > 0x249249249249249LL )
      goto LABEL_25;
  }
  else
  {
    v8 = a2;
  }
  v9 = 112 * v8;
  v24 = v8;
  if ( 112 * v8 >= 0x1000 )
  {
    if ( v9 + 39 >= v9 )
    {
      v10 = sub_180031D20((ai *)(v9 + 39), v6, a3);
      if ( !v10 )
        goto LABEL_24;
      v11 = (v10 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v11 - 8) = v10;
      goto LABEL_13;
    }
LABEL_25:
    Concurrency::cancel_current_task();
  }
  if ( v9 )
  {
    v11 = sub_180031D20((ai *)(112 * v8), v6, a3);
    v25 = v11;
    v24 = v8;
    goto LABEL_27;
  }
  v11 = 0LL;
  v24 = v8;
LABEL_13:
  v25 = v11;
LABEL_27:
  try
  {
    v22 = sub_180030450(v11 + 112 * v5, a2 - v5, a1);
    v12 = (_DWORD *)a1[1];
    v13 = (_DWORD *)v11;
    v14 = (_DWORD *)*a1;
    if ( (_DWORD *)*a1 != v12 )
    {
      v15 = v11 + 48;
      v16 = v14 + 12;
      do
      {
        *v13 = *v14;
        v17 = *((_QWORD *)v16 - 5);
        *((_QWORD *)v16 - 5) = 0LL;
        *(_QWORD *)(v15 - 40) = v17;
        v18 = *((_QWORD *)v16 - 4);
        *((_QWORD *)v16 - 4) = 0LL;
        *(_QWORD *)(v15 - 32) = v18;
        v19 = *((_QWORD *)v16 - 3);
        *((_QWORD *)v16 - 3) = 0LL;
        *(_QWORD *)(v15 - 24) = v19;
        *(_DWORD *)(v15 - 16) = *(v16 - 4);
        *(_QWORD *)(v15 - 8) = *((_QWORD *)v16 - 1);
        *(_WORD *)v15 = *(_WORD *)v16;
        *(_DWORD *)(v15 + 4) = v16[1];
        *(_DWORD *)(v15 + 8) = v16[2];
        *(_DWORD *)(v15 + 12) = v16[3];
        *(_QWORD *)(v15 + 16) = *((_QWORD *)v16 + 2);
        *(_QWORD *)(v15 + 24) = *((_QWORD *)v16 + 3);
        *((_QWORD *)v16 + 3) = 0LL;
        *(_QWORD *)(v15 + 32) = 0LL;
        *(_QWORD *)(v15 + 48) = 0LL;
        *(_QWORD *)(v15 + 56) = 0LL;
        *(_OWORD *)(v15 + 32) = *((_OWORD *)v16 + 2);
        *(_OWORD *)(v15 + 48) = *((_OWORD *)v16 + 3);
        *((_QWORD *)v16 + 6) = 0LL;
        *((_QWORD *)v16 + 7) = 15LL;
        *((_BYTE *)v16 + 32) = 0;
        v13 += 28;
        v15 += 112LL;
        v14 += 28;
        v16 += 28;
      }
      while ( v14 != v12 );
    }
    sub_18002F4A0(v13, v13, a1);
  }
  catch ( ... )
  {
    sub_18002F4A0(v11 + 112 * v5, v22, a1);
    sub_180031CB0(a1, v25, v24);
    throw;
  }
  if ( *a1 )
  {
    sub_18002F4A0(*a1, a1[1], a1);
    v20 = *a1;
    if ( (unsigned __int64)(112 * ((a1[2] - *a1) / 112)) < 0x1000 )
    {
LABEL_22:
      sub_18001AE10(v20);
      goto LABEL_23;
    }
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  *a1 = v11;
  a1[1] = v11 + 112 * a2;
  result = v9 + v11;
  a1[2] = v9 + v11;
  return result;
}


// ===== 函数: sub_18002F4A0 (0x18002F4A0) =====
void __fastcall sub_18002F4A0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3; // rbx
  __int64 v4; // rcx
  void *v5; // rdx
  ai *v6; // rcx
  ai *v7; // rcx
  ai *v8; // rdi
  void *v9; // rdx

  if ( a1 != a2 )
  {
    v3 = a1 + 13;
    do
    {
      if ( *v3 >= 0x10uLL )
      {
        v4 = *(v3 - 3);
        if ( (unsigned __int64)(*v3 + 1LL) >= 0x1000 )
        {
          if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
          v4 = *(_QWORD *)(v4 - 8);
        }
        sub_18001AE10(v4);
      }
      *(v3 - 1) = 0LL;
      *v3 = 15LL;
      *((_BYTE *)v3 - 24) = 0;
      sub_18000C030((__int64)(v3 - 5));
      v6 = (ai *)*(v3 - 10);
      if ( v6 )
        sub_180031DC0(v6, v5);
      v7 = (ai *)*(v3 - 11);
      if ( v7 )
        sub_180031DC0(v7, v5);
      v8 = (ai *)*(v3 - 12);
      if ( v8 )
      {
        sub_180036A90((_QWORD *)v8 + 19);
        sub_180036A90((_QWORD *)v8 + 17);
        sub_180036A90((_QWORD *)v8 + 15);
        sub_180031DC0(v8, v9);
      }
      v3 += 14;
    }
    while ( v3 - 13 != a2 );
  }
}


// ===== 函数: sub_18000C030 (0x18000C030) =====
__int64 __fastcall sub_18000C030(__int64 a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 8);
  if ( v1 )
  {
    try
    {
      result = sub_180036D10(v1);
    }
    catch ( ... )
    {
    }
  }
  return result;
}


// ===== 函数: sub_180031DC0 (0x180031DC0) =====
int __fastcall sub_180031DC0(ai *a1, void *a2)
{
  int result; // eax

  if ( a1 )
    return ai::SPBasicFreeBlock(a1, a2);
  return result;
}


// ===== 函数: sub_180030450 (0x180030450) =====
__int64 __fastcall sub_180030450(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rcx

  v2 = a1;
  if ( a2 )
  {
    v3 = a1 + 48;
    do
    {
      *(_OWORD *)v2 = 0LL;
      *(_OWORD *)(v2 + 16) = 0LL;
      *(_OWORD *)(v2 + 32) = 0LL;
      *(_OWORD *)(v2 + 48) = 0LL;
      *(_OWORD *)(v2 + 64) = 0LL;
      *(_OWORD *)(v2 + 80) = 0LL;
      *(_OWORD *)(v2 + 96) = 0LL;
      *(_DWORD *)v2 = 0;
      *(_QWORD *)(v3 - 40) = 0LL;
      *(_QWORD *)(v3 - 32) = 0LL;
      *(_QWORD *)(v3 - 24) = 0LL;
      *(_DWORD *)(v3 - 16) = 2;
      *(_QWORD *)(v3 - 8) = 0LL;
      *(_WORD *)v3 = 1;
      *(_QWORD *)(v3 + 4) = 0LL;
      *(_DWORD *)(v3 + 12) = 0;
      *(_QWORD *)(v3 + 16) = 0LL;
      *(_QWORD *)(v3 + 24) = 0LL;
      *(_QWORD *)(v3 + 32) = 0LL;
      *(_QWORD *)(v3 + 48) = 0LL;
      *(_QWORD *)(v3 + 56) = 15LL;
      v2 += 112LL;
      v3 += 112LL;
      --a2;
    }
    while ( a2 );
  }
  sub_18002F4A0((_QWORD *)v2, (_QWORD *)v2);
  return v2;
}


// ===== 函数: sub_1800311C0 (0x1800311C0) =====
__int64 __fastcall sub_1800311C0(__int64 *a1, __int64 *a2)
{
  unsigned int v4; // ebp
  __int64 v5; // rsi
  __int64 v6; // r15
  _BYTE *v7; // rcx
  __int64 *v8; // rax
  unsigned __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rcx
  _QWORD *v12; // rdi
  __int64 v13; // rcx
  unsigned int v14; // eax
  __int64 v15; // rax
  unsigned int v16; // eax
  __int16 v18; // [rsp+68h] [rbp+10h] BYREF
  __int64 v19; // [rsp+70h] [rbp+18h] BYREF

  v18 = 0;
  v4 = (*(__int64 (__fastcall **)(__int16 *))(gAIDocumentSuite + 240))(&v18);
  unknown_libname_2(&v19);
  v5 = *a2;
  v6 = a2[1];
  if ( *a2 != v6 )
  {
    do
    {
      v7 = (_BYTE *)qword_1800744E8;
      v8 = *(__int64 **)(qword_1800744E8 + 8);
      while ( !*((_BYTE *)v8 + 25) )
      {
        if ( *((_BYTE *)v8 + 26) >= *(_BYTE *)(v5 + 24) )
        {
          v7 = v8;
          v8 = (__int64 *)*v8;
        }
        else
        {
          v8 = (__int64 *)v8[2];
        }
      }
      if ( v7[25] || *(_BYTE *)(v5 + 24) < v7[26] )
      {
        std::_Xout_of_range("invalid map<K, T> key");
        JUMPOUT(0x1800313ADLL);
      }
      v9 = (unsigned __int8)v7[27];
      v10 = *a1;
      v11 = a1[1] - *a1;
      if ( v11 / 112 <= v9 )
        std::vector<void *>::_Xlen(v11);
      if ( !*(_DWORD *)(v10 + 112 * v9) )
      {
        *(_DWORD *)(v10 + 112 * v9) = 1;
        v12 = (_QWORD *)(112 * v9 + *a1);
        v13 = *(unsigned __int8 *)(v5 + 24);
        if ( (unsigned __int8)v13 < 2u )
        {
          sub_18001A990(v13, v12 + 4, v12 + 2);
        }
        else if ( (unsigned __int8)(v13 - 2) <= 3u )
        {
          sub_18001A660(v13, v12 + 4, v12 + 1);
          v15 = v12[1];
          if ( *(_DWORD *)(v15 + 108) )
          {
            v16 = sub_18001E370(*(_WORD *)(v15 + 24));
            sub_18003B680(6u, v16, v12 + 8, (__int64)&v19);
          }
          v4 = sub_18003C970(v12 + 10);
        }
        else if ( (_BYTE)v13 == 12 )
        {
          sub_18001AC00(v12 + 4, v12 + 3);
          if ( *(_BYTE *)(v12[3] + 3LL) )
          {
            v14 = sub_18001E370(1);
            sub_18003B680(2u, v14, v12 + 8, (__int64)&v19);
          }
          v4 = sub_18003CAD0(v12 + 10);
        }
      }
      v5 += 40LL;
    }
    while ( v5 != v6 );
  }
  sub_180036A90(&v19);
  return v4;
}


// ===== 函数: sub_18001AC00 (0x18001AC00) =====
__int64 __fastcall sub_18001AC00(__int64 a1, char *a2, void **a3)
{
  unsigned __int64 v5; // rax
  void *v6; // rdx
  ai *v7; // rcx
  ai *v8; // rdx
  __int64 result; // rax
  unsigned int v10; // ecx
  char v11; // [rsp+30h] [rbp+8h] BYREF

  *(_DWORD *)a1 = 4;
  *(_WORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 1;
  *(_DWORD *)(a1 + 24) = 2;
  *(_QWORD *)(a1 + 8) = 0LL;
  v5 = sub_180031D20((ai *)0x18, (__int64)a2, a3);
  if ( v5 )
  {
    *(_OWORD *)v5 = 0LL;
    *(_QWORD *)(v5 + 16) = 0LL;
    *(_QWORD *)(v5 + 8) = 0x4052000000000000LL;
    *(_WORD *)(v5 + 20) = -1;
    *(_DWORD *)v5 = 16868353;
    *(_BYTE *)(v5 + 4) = 2;
    *(_DWORD *)(v5 + 16) = -1;
  }
  else
  {
    v5 = 0LL;
  }
  if ( a2 == &v11 )
  {
    if ( !v5 )
      goto LABEL_10;
    v7 = (ai *)v5;
  }
  else
  {
    v7 = *(ai **)a2;
    *(_QWORD *)a2 = v5;
    if ( !v7 )
      goto LABEL_10;
  }
  sub_180031DC0(v7, v6);
LABEL_10:
  (*(void (__fastcall **)(_QWORD))(gImageDecoderEncoder + 112))(*(_QWORD *)a2);
  v8 = *(ai **)a2;
  *(_WORD *)(a1 + 16) = *(_BYTE *)(*(_QWORD *)a2 + 4LL) != 0 ? 4 : 0;
  *(_DWORD *)a1 = *((_BYTE *)v8 + 2) != 0 ? 4 : 0;
  result = *(_DWORD *)(a1 + 20) & 0xFFFFFFEF;
  v10 = *(_DWORD *)(a1 + 20) | 0x10;
  if ( *((_BYTE *)v8 + 4) != 2 )
    v10 = *(_DWORD *)(a1 + 20) & 0xFFFFFFEF;
  *(_DWORD *)(a1 + 20) = v10;
  if ( !*((_BYTE *)v8 + 2) && !*((_WORD *)v8 + 8) && !*((_WORD *)v8 + 10) && !*((_WORD *)v8 + 9) )
    *(_DWORD *)(a1 + 20) = v10 | 2;
  return result;
}


// ===== 函数: sub_18003B680 (0x18003B680) =====
__int64 __fastcall sub_18003B680(unsigned int a1, unsigned int a2, _QWORD *a3, __int64 a4)
{
  unsigned int v7; // edx
  unsigned int v8; // ecx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  int v13; // eax
  __int64 v15; // rax
  __int64 v16; // rax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  _QWORD *v20; // rax
  int v21; // eax
  int v22; // eax
  _QWORD *v23; // rax
  int v24; // eax
  __int64 v25; // rbx
  __int64 v26; // rdi
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  int v30; // eax
  __int64 v31; // rax
  __int64 v32; // rax
  int v33; // eax
  __int64 v34; // rax
  __int64 v35; // rax
  int v36; // eax
  __int64 v37; // rax
  int v38; // eax
  __int64 v39; // rax
  __int64 v40; // rax
  int v41; // eax
  __int64 v42; // rbx
  __int64 v43; // rdi
  unsigned int *v44; // rax
  __int64 v45; // rax
  __int64 v46; // rax
  int v47; // eax
  __int64 v48; // rax
  __int64 v49; // rax
  int v50; // eax
  __int64 v51; // [rsp+20h] [rbp-2E8h] BYREF
  unsigned int v52; // [rsp+28h] [rbp-2E0h] BYREF
  int v53; // [rsp+2Ch] [rbp-2DCh] BYREF
  int pExceptionObject; // [rsp+30h] [rbp-2D8h] BYREF
  int v55; // [rsp+34h] [rbp-2D4h] BYREF
  unsigned __int64 v56; // [rsp+38h] [rbp-2D0h] BYREF
  __int64 v57; // [rsp+40h] [rbp-2C8h]
  unsigned __int64 v58; // [rsp+48h] [rbp-2C0h] BYREF
  unsigned int *v59; // [rsp+50h] [rbp-2B8h]
  char v60; // [rsp+58h] [rbp-2B0h]
  __int64 v61; // [rsp+60h] [rbp-2A8h]
  _BYTE v62[40]; // [rsp+68h] [rbp-2A0h] BYREF
  _BYTE v63[40]; // [rsp+90h] [rbp-278h] BYREF
  _BYTE v64[40]; // [rsp+B8h] [rbp-250h] BYREF
  _BYTE v65[40]; // [rsp+E0h] [rbp-228h] BYREF
  _BYTE v66[40]; // [rsp+108h] [rbp-200h] BYREF
  _BYTE v67[40]; // [rsp+130h] [rbp-1D8h] BYREF
  _BYTE v68[40]; // [rsp+158h] [rbp-1B0h] BYREF
  _BYTE v69[40]; // [rsp+180h] [rbp-188h] BYREF
  _BYTE v70[40]; // [rsp+1A8h] [rbp-160h] BYREF
  _BYTE v71[40]; // [rsp+1D0h] [rbp-138h] BYREF
  _BYTE v72[40]; // [rsp+1F8h] [rbp-110h] BYREF
  _BYTE v73[40]; // [rsp+220h] [rbp-E8h] BYREF
  _BYTE v74[40]; // [rsp+248h] [rbp-C0h] BYREF
  _BYTE v75[48]; // [rsp+270h] [rbp-98h] BYREF
  _BYTE v76[96]; // [rsp+2A0h] [rbp-68h] BYREF
  unsigned int v77; // [rsp+310h] [rbp+8h] BYREF

  v61 = -2LL;
  v7 = a1 >> 1;
  v8 = a1 >> 2;
  if ( (((unsigned __int8)v8 | (unsigned __int8)v7) & 1) == 0 )
  {
    pExceptionObject = 1346458189;
    throw (int *)&pExceptionObject;
  }
  if ( (v7 & 1) != 0 && a2 == 1 || (v8 & 1) != 0 && a2 == 2 )
  {
    v53 = 0;
    v55 = 0;
    v52 = 0;
    v9 = sub_18003C3C0(&unk_180074971);
    v10 = sub_180007790(v9);
    (*(void (__fastcall **)(_QWORD, int *, int *, __int64))(v10 + 72))(a2, &v53, &v55, a4);
    LOBYTE(v77) = 0;
    v51 = 0LL;
    v58 = (unsigned __int64)&v51;
    v59 = &v77;
    v60 = 1;
    if ( v53 == 1 )
    {
      v11 = sub_18003C3C0(&unk_180074971);
      v12 = sub_180007790(v11);
      v13 = (*(__int64 (__fastcall **)(_QWORD, __int64 *))(v12 + 48))(a2, &v51);
      if ( v13 )
      {
        sub_180003F80(
          (__int64)v62,
          v13,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 422 ");
        throw (ai::Error *)v62;
      }
      LOBYTE(v77) = 1;
    }
    else
    {
      v18 = *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL);
      if ( a2 == 1 )
      {
        if ( dword_180074A40 > v18 )
        {
          Init_thread_header(&dword_180074A40);
          if ( dword_180074A40 == -1 )
          {
            xmmword_180074A20 = 0LL;
            qword_180074A30 = (__int64)"AI Document Suite";
            dword_180074A38 = 21;
            byte_180074A3C = 0;
            Init_thread_footer(&dword_180074A40);
          }
        }
        if ( !*((_QWORD *)&xmmword_180074A20 + 1) && qword_1800740D8 )
        {
          v19 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
                  qword_180074A30,
                  (unsigned int)dword_180074A38,
                  (char *)&xmmword_180074A20 + 8);
          if ( v19 )
          {
            sub_180003F80((__int64)v63, v19, 0LL);
            throw (ai::Error *)v63;
          }
          if ( !byte_180074A3C )
          {
            v20 = sub_180012E90();
            *(_QWORD *)&xmmword_180074A20 = *v20;
            *v20 = &xmmword_180074A20;
          }
        }
        v21 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD))(*((_QWORD *)&xmmword_180074A20 + 1) + 256LL))(
                &v51,
                0LL,
                0LL);
        if ( v21 )
        {
          sub_180003F80(
            (__int64)v64,
            v21,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\RasterizeUtils.cpp line: 422 ");
          throw (ai::Error *)v64;
        }
      }
      else
      {
        if ( dword_180074A40 > v18 )
        {
          Init_thread_header(&dword_180074A40);
          if ( dword_180074A40 == -1 )
          {
            xmmword_180074A20 = 0LL;
            qword_180074A30 = (__int64)"AI Document Suite";
            dword_180074A38 = 21;
            byte_180074A3C = 0;
            Init_thread_footer(&dword_180074A40);
          }
        }
        if ( !*((_QWORD *)&xmmword_180074A20 + 1) && qword_1800740D8 )
        {
          v22 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
                  qword_180074A30,
                  (unsigned int)dword_180074A38,
                  (char *)&xmmword_180074A20 + 8);
          if ( v22 )
          {
            sub_180003F80((__int64)v65, v22, 0LL);
            throw (ai::Error *)v65;
          }
          if ( !byte_180074A3C )
          {
            v23 = sub_180012E90();
            *(_QWORD *)&xmmword_180074A20 = *v23;
            *v23 = &xmmword_180074A20;
          }
        }
        v24 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, _QWORD))(*((_QWORD *)&xmmword_180074A20 + 1) + 256LL))(
                0LL,
                &v51,
                0LL);
        if ( v24 )
        {
          sub_180003F80(
            (__int64)v66,
            v24,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\RasterizeUtils.cpp line: 422 ");
          throw (ai::Error *)v66;
        }
      }
    }
    if ( v51 )
    {
      v15 = sub_18003C3C0(&unk_180074971);
      v16 = sub_180007790(v15);
      v17 = (*(__int64 (__fastcall **)(__int64, unsigned int *, _QWORD))(v16 + 80))(v51, &v52, 0LL);
      if ( v17 )
      {
        sub_180003F80(
          (__int64)v67,
          v17,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 422 ");
        throw (ai::Error *)v67;
      }
      if ( !v52 )
      {
        sub_180004080(v75, "Failed Precondition");
        throw (ai::Contract::Violation *)v75;
      }
      v25 = v52;
      v56 = v52;
      v26 = sub_180036BB0(v52);
      *a3 = v25;
      v27 = a3[1];
      a3[1] = v26;
      v57 = v27;
      sub_18000C030((__int64)&v56);
      v28 = sub_18003C3C0(&unk_180074971);
      v29 = sub_180007790(v28);
      v30 = (*(__int64 (__fastcall **)(__int64, unsigned int *, _QWORD))(v29 + 80))(v51, &v52, a3[1]);
      if ( v30 )
      {
        sub_180003F80(
          (__int64)v68,
          v30,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 422 ");
        throw (ai::Error *)v68;
      }
      v31 = sub_18003C3C0(&unk_180074971);
      v32 = sub_180007790(v31);
      v33 = (*(__int64 (__fastcall **)(__int64, __int64))(v32 + 88))(v51, a4);
      if ( v33 )
      {
        sub_180003F80(
          (__int64)v69,
          v33,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 422 ");
        throw (ai::Error *)v69;
      }
    }
    return sub_18003B5C0(&v58);
  }
  else
  {
    v51 = 0LL;
    v56 = (unsigned __int64)&v51;
    LOBYTE(v57) = 1;
    v34 = sub_18003C3C0(&unk_180074971);
    if ( a2 == 1 )
    {
      v35 = sub_180007790(v34);
      v36 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v35 + 48))(2LL, &v51);
      if ( v36 )
      {
        sub_180003F80(
          (__int64)v70,
          v36,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 475 ");
        throw (ai::Error *)v70;
      }
    }
    else
    {
      v37 = sub_180007790(v34);
      v38 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v37 + 48))(1LL, &v51);
      if ( v38 )
      {
        sub_180003F80(
          (__int64)v71,
          v38,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 475 ");
        throw (ai::Error *)v71;
      }
    }
    if ( v51 )
    {
      v77 = 0;
      v39 = sub_18003C3C0(&unk_180074971);
      v40 = sub_180007790(v39);
      v41 = (*(__int64 (__fastcall **)(__int64, unsigned int *, _QWORD))(v40 + 80))(v51, &v77, 0LL);
      if ( v41 )
      {
        sub_180003F80(
          (__int64)v72,
          v41,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 475 ");
        throw (ai::Error *)v72;
      }
      if ( !v77 )
      {
        sub_180004080(v76, "Failed Precondition");
        throw (ai::Contract::Violation *)v76;
      }
      v42 = v77;
      v58 = v77;
      v43 = sub_180036BB0(v77);
      *a3 = v42;
      v44 = (unsigned int *)a3[1];
      a3[1] = v43;
      v59 = v44;
      sub_18000C030((__int64)&v58);
      v45 = sub_18003C3C0(&unk_180074971);
      v46 = sub_180007790(v45);
      v47 = (*(__int64 (__fastcall **)(__int64, unsigned int *, _QWORD))(v46 + 80))(v51, &v77, a3[1]);
      if ( v47 )
      {
        sub_180003F80(
          (__int64)v73,
          v47,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 475 ");
        throw (ai::Error *)v73;
      }
      v48 = sub_18003C3C0(&unk_180074971);
      v49 = sub_180007790(v48);
      v50 = (*(__int64 (__fastcall **)(__int64, __int64))(v49 + 88))(v51, a4);
      if ( v50 )
      {
        sub_180003F80(
          (__int64)v74,
          v50,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\RasterizeUtils.cpp line: 475 ");
        throw (ai::Error *)v74;
      }
    }
    return sub_18003B540(&v56);
  }
}


// ===== 函数: sub_18003C3C0 (0x18003C3C0) =====
__int128 *sub_18003C3C0()
{
  _QWORD *v1; // rax

  if ( dword_1800741C8 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_1800741A8;
  Init_thread_header(&dword_1800741C8);
  if ( dword_1800741C8 != -1 )
    return &xmmword_1800741A8;
  xmmword_1800741A8 = 0LL;
  qword_1800741B8 = (__int64)"Override AI Color Conversion Suite";
  dword_1800741C0 = 9;
  byte_1800741C4 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_1800741A8 = *v1;
  *v1 = &xmmword_1800741A8;
  Init_thread_footer(&dword_1800741C8);
  return &xmmword_1800741A8;
}


// ===== 函数: sub_18003B5C0 (0x18003B5C0) =====
void __fastcall sub_18003B5C0(__int64 a1)
{
  __int128 *v2; // rax
  __int64 v3; // rax

  if ( *(_BYTE *)(a1 + 16) && **(_QWORD **)a1 && **(_BYTE **)(a1 + 8) )
  {
    try
    {
      v2 = sub_18003C3C0();
      v3 = sub_180007790((__int64)v2);
      (*(void (__fastcall **)(_QWORD))(v3 + 56))(**(_QWORD **)a1);
    }
    catch ( ... )
    {
    }
  }
}


// ===== 函数: sub_18003B540 (0x18003B540) =====
void __fastcall sub_18003B540(__int64 a1)
{
  __int128 *v2; // rax
  __int64 v3; // rax

  if ( *(_BYTE *)(a1 + 8) && **(_QWORD **)a1 )
  {
    try
    {
      v2 = sub_18003C3C0();
      v3 = sub_180007790((__int64)v2);
      (*(void (__fastcall **)(_QWORD))(v3 + 56))(**(_QWORD **)a1);
    }
    catch ( ... )
    {
    }
  }
}


// ===== 函数: sub_180004080 (0x180004080) =====
__int64 __fastcall sub_180004080(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_OWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)a1 = &ai::Contract::Violation::`vftable';
  result = a1;
  *(_DWORD *)(a1 + 24) = 1346458189;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = a2;
  return result;
}


// ===== 函数: sub_180036BB0 (0x180036BB0) =====
__int64 __fastcall sub_180036BB0(__int64 a1)
{
  int v2; // eax
  _QWORD *v3; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  __int64 v6; // [rsp+68h] [rbp+10h] BYREF

  v6 = 0LL;
  if ( dword_1800745F8 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                   + 4LL) )
  {
    Init_thread_header(&dword_1800745F8);
    if ( dword_1800745F8 == -1 )
    {
      xmmword_1800745D8 = 0LL;
      qword_1800745E8 = (__int64)"SP Blocks Suite";
      dword_1800745F0 = 2;
      byte_1800745F4 = 0;
      Init_thread_footer(&dword_1800745F8);
    }
  }
  if ( !*((_QWORD *)&xmmword_1800745D8 + 1) && qword_1800740D8 )
  {
    v2 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_1800745E8,
           (unsigned int)dword_1800745F0,
           (char *)&xmmword_1800745D8 + 8);
    if ( v2 )
    {
      sub_180003F80((__int64)pExceptionObject, v2, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !byte_1800745F4 )
    {
      v3 = sub_180012E90();
      *(_QWORD *)&xmmword_1800745D8 = *v3;
      *v3 = &xmmword_1800745D8;
    }
  }
  if ( (**((unsigned int (__fastcall ***)(__int64, const char *, __int64 *))&xmmword_1800745D8 + 1))(
         a1,
         "ai::SPAlloc::AllocateBlock",
         &v6) )
  {
    sub_180003F80((__int64)pExceptionObject, 558712141, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return v6;
}


// ===== 函数: sub_18001A660 (0x18001A660) =====
__int16 __fastcall sub_18001A660(unsigned __int8 a1, __int64 a2, void **a3)
{
  _UNKNOWN **v3; // rax
  int v6; // esi
  int v7; // ecx
  int v8; // ecx
  ai *v9; // rax
  __int64 v10; // rdx
  void **v11; // r8
  ai *v12; // rdi
  ai *v13; // r14
  void *v14; // rdx
  ai *v15; // rcx
  void (__fastcall *v16)(void *, _QWORD *); // rdi
  int v17; // esi
  int v18; // esi
  int v19; // esi
  char *v20; // rax
  _QWORD *v21; // rax
  __int64 v22; // rcx
  _DWORD *v23; // rdx
  _QWORD v25[2]; // [rsp+28h] [rbp-38h] BYREF
  char *v26; // [rsp+38h] [rbp-28h] BYREF
  __int64 v27; // [rsp+48h] [rbp-18h]
  unsigned __int64 v28; // [rsp+50h] [rbp-10h]
  _UNKNOWN *retaddr; // [rsp+88h] [rbp+28h] BYREF

  v3 = &retaddr;
  v25[1] = -2LL;
  *(_DWORD *)a2 = 4;
  *(_WORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 1;
  *(_DWORD *)(a2 + 24) = 2;
  *(_QWORD *)(a2 + 8) = 0LL;
  v6 = a1;
  v7 = a1 - 2;
  if ( v7 )
  {
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( (unsigned int)(v8 - 1) > 1 )
        return (__int16)v3;
    }
  }
  v9 = (ai *)sub_180031D20((ai *)0xA8, a2, a3);
  v12 = v9;
  v25[0] = v9;
  if ( v9 )
  {
    memset(v9, 0, 0xA8uLL);
    unknown_libname_2((_QWORD *)v12 + 15);
    unknown_libname_2((_QWORD *)v12 + 17);
    unknown_libname_2((_QWORD *)v12 + 19);
  }
  else
  {
    v12 = 0LL;
  }
  if ( a3 == v25 )
  {
    if ( !v12 )
      goto LABEL_13;
    sub_180036A90((_QWORD *)v12 + 19);
    sub_180036A90((_QWORD *)v12 + 17);
    sub_180036A90((_QWORD *)v12 + 15);
    v15 = v12;
  }
  else
  {
    v13 = (ai *)*a3;
    *a3 = v12;
    if ( !v13 )
      goto LABEL_13;
    sub_180036A90((_QWORD *)v13 + 19);
    sub_180036A90((_QWORD *)v13 + 17);
    sub_180036A90((_QWORD *)v13 + 15);
    v15 = v13;
  }
  sub_180031DC0(v15, v14);
LABEL_13:
  v16 = *(void (__fastcall **)(void *, _QWORD *))(gAIJPEGSuite + 72);
  v26 = 0LL;
  v27 = 0LL;
  v28 = 15LL;
  v17 = v6 - 2;
  if ( !v17 )
  {
    v20 = (char *)sub_180031D20((ai *)0x20, v10, v11);
    v27 = 19LL;
    v28 = 31LL;
    strcpy(v20, "JPG File Format 100");
    goto LABEL_21;
  }
  v18 = v17 - 1;
  if ( !v18 )
  {
    v20 = (char *)sub_180031D20((ai *)0x20, v10, v11);
    v27 = 18LL;
    v28 = 31LL;
    strcpy(v20, "JPG File Format 80");
    goto LABEL_21;
  }
  v19 = v18 - 1;
  if ( !v19 )
  {
    v20 = (char *)sub_180031D20((ai *)0x20, v10, v11);
    v27 = 18LL;
    v28 = 31LL;
    strcpy(v20, "JPG File Format 50");
    goto LABEL_21;
  }
  if ( v19 == 1 )
  {
    v20 = (char *)sub_180031D20((ai *)0x20, v10, v11);
    v27 = 18LL;
    v28 = 31LL;
    strcpy(v20, "JPG File Format 20");
LABEL_21:
    v26 = v20;
  }
  v21 = sub_180036E30(v25, &v26);
  v16(*a3, v21);
  sub_180036A90(v25);
  if ( v28 >= 0x10 )
  {
    v22 = (__int64)v26;
    if ( v28 + 1 >= 0x1000 )
    {
      v22 = *((_QWORD *)v26 - 1);
      if ( (unsigned __int64)&v26[-v22 - 8] > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10(v22);
  }
  v23 = *a3;
  LOWORD(v3) = 2;
  if ( *((_DWORD *)*a3 + 2) == 1 )
    LOWORD(v3) = 0;
  *(_WORD *)(a2 + 16) = (_WORD)v3;
  if ( v23[2] == 2 || v23[2] == 3 )
    *(_DWORD *)(a2 + 20) |= 0x10u;
  switch ( *((_WORD *)v23 + 12) )
  {
    case 1:
      *(_DWORD *)a2 = 0;
      break;
    case 2:
      *(_DWORD *)a2 = 1;
      break;
    case 3:
      *(_DWORD *)a2 = 2;
      break;
  }
  return (__int16)v3;
}


// ===== 函数: sub_180036E30 (0x180036E30) =====
_QWORD *__fastcall sub_180036E30(_QWORD *a1, _QWORD *a2)
{
  sub_1800364F0(a1, a2, 0x10u);
  return a1;
}


// ===== 函数: sub_1800364F0 (0x1800364F0) =====
_QWORD *__fastcall sub_1800364F0(_QWORD *a1, _QWORD *a2, unsigned int a3)
{
  __int128 *v6; // rax
  __int64 (__fastcall **v7)(_QWORD *, _QWORD *, __int64, _QWORD); // rax
  __int64 v8; // r8
  int v9; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  v6 = sub_180036EE0();
  v7 = (__int64 (__fastcall **)(_QWORD *, _QWORD *, __int64, _QWORD))sub_180007790((__int64)v6);
  v8 = a2[2];
  if ( a2[3] >= 0x10uLL )
    a2 = (_QWORD *)*a2;
  v9 = (*v7)(a1, a2, v8, a3);
  if ( v9 )
  {
    sub_180003F80((__int64)pExceptionObject, v9, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a1;
}


// ===== 函数: __security_check_cookie (0x18004C150) =====
void __cdecl _security_check_cookie(uintptr_t StackCookie)
{
  __int64 v1; // rcx

  if ( StackCookie != _security_cookie )
ReportFailure:
    _report_gsfailure(StackCookie);
  v1 = __ROL8__(StackCookie, 16);
  if ( (_WORD)v1 )
  {
    StackCookie = __ROR8__(v1, 16);
    goto ReportFailure;
  }
}


// ===== 函数: memset (0x18004D0FA) =====
// attributes: thunk
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  return __imp_memset(a1, Val, Size);
}


// ===== 函数: sub_18001E370 (0x18001E370) =====
__int64 __fastcall sub_18001E370(__int16 a1)
{
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  if ( !a1 )
    return 0LL;
  if ( a1 != 1 )
  {
    if ( a1 == 2 )
      return 2LL;
    if ( a1 != 17 )
    {
      if ( a1 != 18 )
      {
        sub_180003F80((__int64)pExceptionObject, 1346458189, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      return 2LL;
    }
  }
  return 1LL;
}


// ===== 函数: sub_18003CAD0 (0x18003CAD0) =====
__int64 __fastcall sub_18003CAD0(__int64 *a1)
{
  int v2; // eax
  __int64 v3; // rdx
  int v4; // eax
  unsigned int v5; // ebx
  size_t v6; // r8
  __int64 result; // rax
  unsigned int v8; // [rsp+20h] [rbp-88h] BYREF
  void **p_Src; // [rsp+28h] [rbp-80h] BYREF
  char v10; // [rsp+30h] [rbp-78h]
  __int64 v11; // [rsp+38h] [rbp-70h]
  const ai::Error *v12; // [rsp+40h] [rbp-68h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+48h] [rbp-60h] BYREF
  _BYTE v14[40]; // [rsp+70h] [rbp-38h] BYREF
  const std::exception *v15; // [rsp+98h] [rbp-10h] BYREF
  void *Src; // [rsp+B8h] [rbp+10h] BYREF

  v11 = -2LL;
  Src = 0LL;
  try
  {
    v2 = sub_18003BF40();
    if ( v2 )
    {
      sub_180003F80(
        (__int64)pExceptionObject,
        v2,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\RasterizeUtils.cpp line: 546 ");
      throw (ai::Error *)pExceptionObject;
    }
    p_Src = &Src;
    v10 = 1;
    LOBYTE(v3) = 1;
    v4 = sub_18003C470(&Src, v3, "WebP");
    v5 = v4;
    if ( v4 )
    {
      sub_180003F80(
        (__int64)v14,
        v4,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\RasterizeUtils.cpp line: 546 ");
      throw (ai::Error *)v14;
    }
    v6 = -1LL;
    do
      ++v6;
    while ( *((_BYTE *)Src + v6) );
    sub_180006EF0(a1, (char *)Src, v6);
    sub_18003B590(&p_Src);
    result = v5;
  }
  catch ( const ai::Error *v12 )
  {
    return *((unsigned int *)v12 + 6);
  }
  catch ( const std::exception *v15 )
  {
    return 1398031704LL;
  }
  catch ( int v8 )
  {
    return v8;
  }
  catch ( ... )
  {
    return 1431192920LL;
  }
  return result;
}


// ===== 函数: sub_18003BF40 (0x18003BF40) =====
__int64 __fastcall sub_18003BF40(unsigned __int64 *a1)
{
  __int64 result; // rax
  _DWORD *v3; // rsi
  int v4; // eax
  _QWORD *v5; // rax
  _QWORD *v6; // rax
  int v7; // eax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  void **v10; // r8
  __int64 v11; // rbx
  unsigned __int64 v12; // rax
  unsigned int v13; // [rsp+20h] [rbp-A8h] BYREF
  __int64 v14; // [rsp+28h] [rbp-A0h]
  const ai::Error *v15; // [rsp+30h] [rbp-98h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+38h] [rbp-90h] BYREF
  _BYTE v17[40]; // [rsp+60h] [rbp-68h] BYREF
  _BYTE v18[48]; // [rsp+88h] [rbp-40h] BYREF
  const std::exception *v19; // [rsp+B8h] [rbp-10h] BYREF
  __int64 v20; // [rsp+D0h] [rbp+8h] BYREF

  v14 = -2LL;
  if ( !a1 )
    return 1346458189LL;
  v3 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL);
  if ( dword_1800749A0 > *v3 )
  {
    Init_thread_header(&dword_1800749A0);
    if ( dword_1800749A0 == -1 )
    {
      xmmword_180074980 = 0LL;
      qword_180074990 = (__int64)"AI Asset Management Suite";
      dword_180074998 = 10;
      byte_18007499C = 0;
      Init_thread_footer(&dword_1800749A0);
    }
  }
  try
  {
    if ( !*((_QWORD *)&xmmword_180074980 + 1) && qword_1800740D8 )
    {
      if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
             qword_180074990,
             (unsigned int)dword_180074998,
             (char *)&xmmword_180074980 + 8) )
      {
        *((_QWORD *)&xmmword_180074980 + 1) = 0LL;
      }
      else if ( !byte_18007499C )
      {
        v5 = sub_180012E90();
        *(_QWORD *)&xmmword_180074980 = *v5;
        *v5 = &xmmword_180074980;
      }
    }
    if ( *((_QWORD *)&xmmword_180074980 + 1) )
    {
      if ( dword_1800749A0 > *v3 )
      {
        Init_thread_header(&dword_1800749A0);
        if ( dword_1800749A0 == -1 )
        {
          xmmword_180074980 = 0LL;
          qword_180074990 = (__int64)"AI Asset Management Suite";
          dword_180074998 = 10;
          byte_18007499C = 0;
          Init_thread_footer(&dword_1800749A0);
        }
      }
      if ( !*((_QWORD *)&xmmword_180074980 + 1) && qword_1800740D8 )
      {
        v4 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
               qword_180074990,
               (unsigned int)dword_180074998,
               (char *)&xmmword_180074980 + 8);
        if ( v4 )
        {
          sub_180003F80((__int64)pExceptionObject, v4, 0LL);
          throw (ai::Error *)pExceptionObject;
        }
        if ( !byte_18007499C )
        {
          v6 = sub_180012E90();
          *(_QWORD *)&xmmword_180074980 = *v6;
          *v6 = &xmmword_180074980;
        }
      }
      (*(void (__fastcall **)(const char *, _QWORD, _QWORD))(*((_QWORD *)&xmmword_180074980 + 1) + 8LL))(
        "application/x-unknown",
        0LL,
        0LL);
    }
    v20 = 0LL;
    if ( dword_180074A40 > *v3 )
    {
      Init_thread_header(&dword_180074A40);
      if ( dword_180074A40 == -1 )
      {
        xmmword_180074A20 = 0LL;
        qword_180074A30 = (__int64)"AI Document Suite";
        dword_180074A38 = 21;
        byte_180074A3C = 0;
        Init_thread_footer(&dword_180074A40);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074A20 + 1) && qword_1800740D8 )
    {
      v7 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
             qword_180074A30,
             (unsigned int)dword_180074A38,
             (char *)&xmmword_180074A20 + 8);
      if ( v7 )
      {
        sub_180003F80((__int64)v17, v7, 0LL);
        throw (ai::Error *)v17;
      }
      if ( !byte_180074A3C )
      {
        v8 = sub_180012E90();
        *(_QWORD *)&xmmword_180074A20 = *v8;
        *v8 = &xmmword_180074A20;
      }
    }
    if ( (*(unsigned int (__fastcall **)(__int64 *))(*((_QWORD *)&xmmword_180074A20 + 1) + 384LL))(&v20) || !v20 )
    {
      sub_180004080((__int64)v18, (__int64)"Failed Precondition");
      throw (ai::Contract::Violation *)v18;
    }
    v11 = -1LL;
    do
      ++v11;
    while ( *(_BYTE *)(v20 + v11) );
    v12 = sub_180031D20((ai *)(v11 + 1), v9, v10);
    *a1 = v12;
    sub_180008800(v12, v11 + 1, v20);
    result = 0LL;
  }
  catch ( const ai::Error *v15 )
  {
    return *((unsigned int *)v15 + 6);
  }
  catch ( const std::exception *v19 )
  {
    return 1398031704LL;
  }
  catch ( int v13 )
  {
    return v13;
  }
  catch ( ... )
  {
    return 1431192920LL;
  }
  return result;
}


// ===== 函数: sub_180008800 (0x180008800) =====
__int64 __fastcall sub_180008800(_BYTE *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r8
  char v4; // al
  _BYTE *v5; // r9

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a3 || !a2 )
  {
    *a1 = 0;
    return 0xFFFFFFFFLL;
  }
  v3 = a3 - (_QWORD)a1;
  while ( 1 )
  {
    v4 = a1[v3];
    v5 = a1;
    *a1++ = v4;
    if ( !v4 )
      break;
    if ( !--a2 )
    {
      *v5 = 0;
      return 4294967294LL;
    }
  }
  return 0LL;
}


// ===== 函数: sub_18003C470 (0x18003C470) =====
__int64 __fastcall sub_18003C470(__int64 a1, unsigned __int8 a2, __int64 a3)
{
  int v4; // ebx
  struct tm *v6; // rax
  __int64 v7; // rdx
  _OWORD *v8; // rcx
  _OWORD *v9; // rdx
  _OWORD *v10; // rdx
  unsigned int v11; // ebx
  __int64 v12; // rcx
  __int128 v14; // [rsp+28h] [rbp-89h] BYREF
  __int128 v15; // [rsp+38h] [rbp-79h]
  __int128 v16; // [rsp+48h] [rbp-69h] BYREF
  _OWORD *v17; // [rsp+58h] [rbp-59h]
  __time64_t Time[3]; // [rsp+60h] [rbp-51h] BYREF
  char Buffer[16]; // [rsp+78h] [rbp-39h] BYREF
  __int128 v20; // [rsp+88h] [rbp-29h]
  __int128 v21; // [rsp+98h] [rbp-19h]
  __int128 v22; // [rsp+A8h] [rbp-9h]
  __int128 v23; // [rsp+B8h] [rbp+7h]
  __int128 v24; // [rsp+C8h] [rbp+17h]
  __int128 v25; // [rsp+D8h] [rbp+27h]
  __int128 v26; // [rsp+E8h] [rbp+37h]

  Time[1] = -2LL;
  v4 = a2;
  *(_OWORD *)Buffer = 0LL;
  v20 = 0LL;
  v21 = 0LL;
  v22 = 0LL;
  v23 = 0LL;
  v24 = 0LL;
  v25 = 0LL;
  v26 = 0LL;
  time64(Time);
  v6 = gmtime64(Time);
  strftime(Buffer, 0x80uLL, "%Y-%m-%dT%H:%M:%SZ", v6);
  v16 = 0LL;
  v17 = 0LL;
  *(_QWORD *)&v14 = "http://ns.adobe.com/xap/1.0/";
  *((_QWORD *)&v14 + 1) = "CreatorTool";
  *(_QWORD *)&v15 = "Adobe Illustrator 27.9 (Windows)";
  DWORD2(v15) = v4;
  sub_18003B380(&v16, 0LL, &v14);
  *(_QWORD *)&v14 = "http://ns.adobe.com/xap/1.0/";
  *((_QWORD *)&v14 + 1) = "CreateDate";
  *(_QWORD *)&v15 = Buffer;
  DWORD2(v15) = 0;
  v7 = *((_QWORD *)&v16 + 1);
  v8 = v17;
  if ( *((_OWORD **)&v16 + 1) == v17 )
  {
    sub_18003B380(&v16, *((_QWORD *)&v16 + 1), &v14);
    v8 = v17;
    v9 = (_OWORD *)*((_QWORD *)&v16 + 1);
  }
  else
  {
    **((_OWORD **)&v16 + 1) = v14;
    *(_OWORD *)(v7 + 16) = v15;
    v9 = (_OWORD *)(v7 + 32);
    *((_QWORD *)&v16 + 1) = v9;
  }
  *(_QWORD *)&v14 = "http://ns.adobe.com/xap/1.0/";
  *((_QWORD *)&v14 + 1) = "ModifyDate";
  *(_QWORD *)&v15 = Buffer;
  DWORD2(v15) = v4;
  if ( v9 == v8 )
  {
    sub_18003B380(&v16, v9, &v14);
    v8 = v17;
    v10 = (_OWORD *)*((_QWORD *)&v16 + 1);
  }
  else
  {
    *v9 = v14;
    v9[1] = v15;
    v10 = v9 + 2;
    *((_QWORD *)&v16 + 1) = v10;
  }
  *(_QWORD *)&v14 = "http://ns.adobe.com/xap/1.0/";
  *((_QWORD *)&v14 + 1) = "Format";
  *(_QWORD *)&v15 = a3;
  DWORD2(v15) = 1;
  if ( v10 == v8 )
  {
    sub_18003B380(&v16, v10, &v14);
  }
  else
  {
    *v10 = v14;
    v10[1] = v15;
    *((_QWORD *)&v16 + 1) = v10 + 2;
  }
  v11 = sub_18003C6D0(a1, &v16);
  v12 = v16;
  if ( (_QWORD)v16 )
  {
    if ( ((unsigned __int64)((unsigned __int64)v17 - v16) & 0xFFFFFFFFFFFFFFE0uLL) >= 0x1000 )
    {
      v12 = *(_QWORD *)(v16 - 8);
      if ( (unsigned __int64)(v16 - v12 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10(v12);
  }
  return v11;
}


// ===== 函数: sub_18003B380 (0x18003B380) =====
_OWORD *__fastcall sub_18003B380(__int64 *a1, _BYTE *a2, _OWORD *a3)
{
  unsigned __int64 v5; // r12
  __int64 v6; // r14
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rax
  _QWORD *v13; // rbx
  _OWORD *v14; // r15
  _BYTE *v15; // r8
  _BYTE *v16; // rdx
  void *v17; // rcx
  size_t v18; // r8
  __int64 v19; // rcx
  unsigned __int64 v22; // [rsp+78h] [rbp+10h]
  _QWORD *v24; // [rsp+88h] [rbp+20h]

  v5 = (unsigned __int64)&a2[-*a1];
  v6 = (a1[1] - *a1) >> 5;
  if ( v6 == 0x7FFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen();
  v7 = v6 + 1;
  v8 = (a1[2] - *a1) >> 5;
  v9 = v8 >> 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_25;
  v10 = v7;
  if ( v9 + v8 >= v7 )
    v10 = v9 + v8;
  if ( v10 > 0x7FFFFFFFFFFFFFFLL )
    goto LABEL_25;
  v11 = 32 * v10;
  v22 = v10;
  if ( 32 * v10 >= 0x1000 )
  {
    if ( v11 + 39 >= v11 )
    {
      v12 = sub_180031D20((ai *)(v11 + 39), v9, (void **)0x7FFFFFFFFFFFFFFLL);
      if ( !v12 )
        goto LABEL_24;
      v13 = (_QWORD *)((v12 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v13 - 1) = v12;
      goto LABEL_13;
    }
LABEL_25:
    Concurrency::cancel_current_task();
  }
  if ( v11 )
  {
    v13 = (_QWORD *)sub_180031D20((ai *)(32 * v10), v9, (void **)0x7FFFFFFFFFFFFFFLL);
    v24 = v13;
    v22 = v10;
    goto LABEL_28;
  }
  v13 = 0LL;
  v22 = v10;
LABEL_13:
  v24 = v13;
LABEL_28:
  try
  {
    v14 = (_OWORD *)((char *)v13 + (v5 & 0xFFFFFFFFFFFFFFE0uLL));
    *v14 = *a3;
    v14[1] = a3[1];
    v15 = (_BYTE *)a1[1];
    v16 = (_BYTE *)*a1;
    v17 = v13;
    if ( a2 == v15 )
    {
      v18 = v15 - v16;
    }
    else
    {
      memmove(v13, v16, a2 - v16);
      v17 = v14 + 2;
      v18 = a1[1] - (_QWORD)a2;
      v16 = a2;
    }
    memmove(v17, v16, v18);
  }
  catch ( ... )
  {
    sub_18003CC20(a1, v24, v22);
    throw;
  }
  v19 = *a1;
  if ( *a1 )
  {
    if ( ((a1[2] - v19) & 0xFFFFFFFFFFFFFFE0uLL) < 0x1000 )
    {
LABEL_22:
      sub_18001AE10(v19);
      goto LABEL_23;
    }
    if ( (unsigned __int64)(v19 - *(_QWORD *)(v19 - 8) - 8) <= 0x1F )
    {
      v19 = *(_QWORD *)(v19 - 8);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  *a1 = (__int64)v13;
  a1[1] = (__int64)&v13[4 * v7];
  a1[2] = (__int64)&v13[v11 / 8];
  return v14;
}


// ===== 函数: sub_18003C6D0 (0x18003C6D0) =====
__int64 __fastcall sub_18003C6D0(ai **a1, _QWORD *a2)
{
  void **v4; // r8
  _DWORD *v5; // rsi
  _QWORD *v6; // rax
  ai *v7; // rax
  ai *v8; // rdi
  int v9; // eax
  _QWORD *v10; // rax
  void *v11; // rdx
  _BYTE pExceptionObject[56]; // [rsp+28h] [rbp-50h] BYREF

  if ( !a1 )
    return 1346458189LL;
  v4 = (void **)(unsigned int)TlsIndex;
  v5 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL);
  if ( dword_1800749A0 > *v5 )
  {
    Init_thread_header(&dword_1800749A0);
    if ( dword_1800749A0 == -1 )
    {
      xmmword_180074980 = 0LL;
      qword_180074990 = (__int64)"AI Asset Management Suite";
      dword_180074998 = 10;
      byte_18007499C = 0;
      Init_thread_footer(&dword_1800749A0);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074980 + 1) && qword_1800740D8 )
  {
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074990,
           (unsigned int)dword_180074998,
           (char *)&xmmword_180074980 + 8) )
    {
      *((_QWORD *)&xmmword_180074980 + 1) = 0LL;
    }
    else if ( !byte_18007499C )
    {
      v6 = sub_180012E90();
      *(_QWORD *)&xmmword_180074980 = *v6;
      *v6 = &xmmword_180074980;
    }
  }
  if ( !*((_QWORD *)&xmmword_180074980 + 1) )
    return 1128353364LL;
  if ( !*a1 )
  {
    v7 = (ai *)sub_180031D20((ai *)1, (__int64)a2, v4);
    *a1 = v7;
    *(_BYTE *)v7 = 0;
  }
  v8 = *a1;
  *a1 = 0LL;
  if ( dword_1800749A0 > *v5 )
  {
    Init_thread_header(&dword_1800749A0);
    if ( dword_1800749A0 == -1 )
    {
      xmmword_180074980 = 0LL;
      qword_180074990 = (__int64)"AI Asset Management Suite";
      dword_180074998 = 10;
      byte_18007499C = 0;
      Init_thread_footer(&dword_1800749A0);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074980 + 1) && qword_1800740D8 )
  {
    v9 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074990,
           (unsigned int)dword_180074998,
           (char *)&xmmword_180074980 + 8);
    if ( v9 )
    {
      sub_180003F80((__int64)pExceptionObject, v9, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !byte_18007499C )
    {
      v10 = sub_180012E90();
      *(_QWORD *)&xmmword_180074980 = *v10;
      *v10 = &xmmword_180074980;
    }
  }
  if ( (**((unsigned int (__fastcall ***)(ai *, _QWORD, __int64, ai **, __int64))&xmmword_180074980 + 1))(
         v8,
         *a2,
         (__int64)(a2[1] - *a2) >> 5,
         a1,
         -2LL) )
  {
    sub_180004080((__int64)pExceptionObject, (__int64)"Error in updating metadata!");
    throw (ai::Contract::Violation *)pExceptionObject;
  }
  if ( !*a1 || *a1 == v8 )
  {
    *a1 = v8;
    return 0LL;
  }
  else
  {
    sub_180031DC0(v8, v11);
    return 0LL;
  }
}


// ===== 函数: sub_180006EF0 (0x180006EF0) =====
__int64 *__fastcall sub_180006EF0(__int64 *a1, char *Src, size_t Size)
{
  unsigned __int64 v3; // rbp
  char *v5; // r15
  void *v7; // rdi
  size_t v8; // rdi
  ai *v9; // rcx
  unsigned __int64 v10; // rax
  _QWORD *v11; // r14
  __int64 v12; // rcx

  v3 = a1[3];
  v5 = Src;
  if ( Size > v3 )
  {
    v8 = 0x7FFFFFFFFFFFFFFFLL;
    if ( Size > 0x7FFFFFFFFFFFFFFFLL )
      std::vector<void *>::_Xlen();
    if ( (Size | 0xF) > 0x7FFFFFFFFFFFFFFFLL || (Src = (char *)(v3 >> 1), v3 > 0x7FFFFFFFFFFFFFFFLL - (v3 >> 1)) )
    {
      v9 = (ai *)0x8000000000000027LL;
    }
    else
    {
      v8 = Size | 0xF;
      if ( (Size | 0xF) < (unsigned __int64)&Src[v3] )
        v8 = (size_t)&Src[v3];
      if ( v8 + 1 < 0x1000 )
      {
        if ( v8 == -1LL )
          v11 = 0LL;
        else
          v11 = (_QWORD *)sub_180031D20((ai *)(v8 + 1), (__int64)Src, (void **)Size);
        goto LABEL_19;
      }
      v9 = (ai *)(v8 + 40);
      if ( v8 + 40 < v8 + 1 )
        Concurrency::cancel_current_task();
    }
    v10 = sub_180031D20(v9, (__int64)Src, (void **)Size);
    if ( !v10 )
      goto LABEL_26;
    v11 = (_QWORD *)((v10 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v11 - 1) = v10;
LABEL_19:
    a1[2] = Size;
    a1[3] = v8;
    memcpy(v11, v5, Size);
    *((_BYTE *)v11 + Size) = 0;
    if ( v3 < 0x10 )
    {
LABEL_24:
      *a1 = (__int64)v11;
      return a1;
    }
    v12 = *a1;
    if ( v3 + 1 < 0x1000 )
    {
LABEL_23:
      sub_18001AE10(v12);
      goto LABEL_24;
    }
    if ( (unsigned __int64)(v12 - *(_QWORD *)(v12 - 8) - 8) <= 0x1F )
    {
      v12 = *(_QWORD *)(v12 - 8);
      goto LABEL_23;
    }
LABEL_26:
    invalid_parameter_noinfo_noreturn();
  }
  v7 = a1;
  if ( v3 >= 0x10 )
    v7 = (void *)*a1;
  a1[2] = Size;
  memmove(v7, Src, Size);
  *((_BYTE *)v7 + Size) = 0;
  return a1;
}


// ===== 函数: memcpy (0x18004D0EE) =====
// attributes: thunk
void *__cdecl memcpy(void *a1, const void *Src, size_t Size)
{
  return __imp_memcpy(a1, Src, Size);
}


// ===== 函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ (0x180006ED0) =====
void __noreturn std::vector<void *>::_Xlen()
{
  std::_Xlength_error("string too long");
}


// ===== 函数: memmove (0x18004D0F4) =====
// attributes: thunk
void *__cdecl memmove(void *a1, const void *Src, size_t Size)
{
  return __imp_memmove(a1, Src, Size);
}


// ===== 函数: sub_18003B590 (0x18003B590) =====
int __fastcall sub_18003B590(__int64 a1, void *a2)
{
  ai **v2; // rax
  ai *v3; // rcx

  if ( *(_BYTE *)(a1 + 8) )
  {
    v2 = *(ai ***)a1;
    v3 = **(ai ***)a1;
    if ( v3 )
      LODWORD(v2) = sub_180031DC0(v3, a2);
  }
  return (int)v2;
}


// ===== 函数: sub_18003C970 (0x18003C970) =====
__int64 __fastcall sub_18003C970(__int64 *a1)
{
  int v2; // eax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rdx
  int v6; // eax
  size_t v7; // r8
  __int64 result; // rax
  unsigned int v9; // [rsp+20h] [rbp-B8h] BYREF
  void **p_Src; // [rsp+28h] [rbp-B0h] BYREF
  char v11; // [rsp+30h] [rbp-A8h]
  __int64 v12; // [rsp+38h] [rbp-A0h]
  const ai::Error *v13; // [rsp+40h] [rbp-98h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+48h] [rbp-90h] BYREF
  _BYTE v15[40]; // [rsp+70h] [rbp-68h] BYREF
  _BYTE v16[48]; // [rsp+98h] [rbp-40h] BYREF
  const std::exception *v17; // [rsp+C8h] [rbp-10h] BYREF
  void *Src; // [rsp+E8h] [rbp+10h] BYREF

  v12 = -2LL;
  Src = 0LL;
  try
  {
    v2 = sub_18003BF40();
    if ( v2 )
    {
      sub_180003F80(
        (__int64)pExceptionObject,
        v2,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\RasterizeUtils.cpp line: 522 ");
      throw (ai::Error *)pExceptionObject;
    }
    p_Src = &Src;
    v11 = 1;
    v3 = sub_18003C310(&unk_18007496C);
    v4 = sub_180007790(v3);
    LOBYTE(v5) = 1;
    v6 = (*(__int64 (__fastcall **)(void **, __int64))(v4 + 88))(&Src, v5);
    if ( v6 )
    {
      sub_180003F80(
        (__int64)v15,
        v6,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\RasterizeUtils.cpp line: 522 ");
      throw (ai::Error *)v15;
    }
    if ( !Src )
    {
      sub_180004080(v16, "Failed Precondition");
      throw (ai::Contract::Violation *)v16;
    }
    v7 = -1LL;
    do
      ++v7;
    while ( *((_BYTE *)Src + v7) );
    sub_180006EF0(a1, (char *)Src, v7);
    sub_18003B590(&p_Src);
    result = 0LL;
  }
  catch ( const ai::Error *v13 )
  {
    return *((unsigned int *)v13 + 6);
  }
  catch ( const std::exception *v17 )
  {
    return 1398031704LL;
  }
  catch ( int v9 )
  {
    return v9;
  }
  catch ( ... )
  {
    return 1431192920LL;
  }
  return result;
}


// ===== 函数: sub_18003C310 (0x18003C310) =====
__int128 *sub_18003C310()
{
  _QWORD *v1; // rax

  if ( dword_1800749C8 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_1800749A8;
  Init_thread_header(&dword_1800749C8);
  if ( dword_1800749C8 != -1 )
    return &xmmword_1800749A8;
  xmmword_1800749A8 = 0LL;
  qword_1800749B8 = (__int64)"AI JPEG Suite";
  dword_1800749C0 = 2;
  byte_1800749C4 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_1800749A8 = *v1;
  *v1 = &xmmword_1800749A8;
  Init_thread_footer(&dword_1800749C8);
  return &xmmword_1800749A8;
}


// ===== 函数: sub_18001A990 (0x18001A990) =====
void __fastcall sub_18001A990(unsigned __int8 a1, __int64 a2, void **a3)
{
  unsigned __int64 v5; // rbx
  void *v6; // rdx
  ai *v7; // rcx
  unsigned __int64 v8; // rdi
  ai *v9; // rbx
  void *v10; // rdx
  ai *v11; // rcx
  unsigned __int64 v12; // [rsp+58h] [rbp+10h] BYREF

  *(_DWORD *)a2 = 4;
  *(_WORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 1;
  *(_DWORD *)(a2 + 24) = 2;
  *(_QWORD *)(a2 + 8) = 0LL;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v5 = sub_180031D20((ai *)0x48, a1, a3);
      v12 = v5;
      if ( v5 )
      {
        *(_OWORD *)v5 = 0LL;
        *(_OWORD *)(v5 + 16) = 0LL;
        *(_QWORD *)(v5 + 64) = 0LL;
        *(_DWORD *)(v5 + 28) = 0;
        *(_OWORD *)(v5 + 32) = 0LL;
        *(_OWORD *)(v5 + 48) = 0LL;
        *(_BYTE *)(v5 + 64) = 1;
        *(_DWORD *)(v5 + 66) = 0;
        *(_DWORD *)(v5 + 68) = 0;
        *(_QWORD *)(v5 + 40) = 0LL;
        *(_QWORD *)(v5 + 32) = 0LL;
        *(_QWORD *)(v5 + 56) = 0LL;
        *(_QWORD *)(v5 + 48) = 0LL;
        *(_WORD *)(v5 + 66) = 0;
        *(_WORD *)(v5 + 70) = 0;
      }
      else
      {
        v5 = 0LL;
      }
      v12 = v5;
      sub_1800388B0(0LL, v5);
      *(_WORD *)(a2 + 16) = *(_DWORD *)(v5 + 28) != 0 ? 4 : 0;
      if ( !*(_BYTE *)(v5 + 64) && !*(_WORD *)(v5 + 66) && !*(_WORD *)(v5 + 70) && !*(_WORD *)(v5 + 68) )
        *(_DWORD *)(a2 + 20) |= 2u;
      if ( *(_DWORD *)(v5 + 28) == 2 )
        *(_DWORD *)(a2 + 20) |= 0x10u;
      v7 = (ai *)*a3;
      *a3 = (void *)v5;
      if ( v7 )
        sub_180031DC0(v7, v6);
    }
  }
  else
  {
    v8 = sub_180031D20((ai *)0x48, 0LL, a3);
    v12 = v8;
    if ( v8 )
    {
      *(_OWORD *)v8 = 0LL;
      *(_QWORD *)(v8 + 16) = 0LL;
      *(_QWORD *)(v8 + 24) = 0LL;
      *(_OWORD *)(v8 + 32) = 0LL;
      *(_OWORD *)(v8 + 48) = 0LL;
      *(_BYTE *)(v8 + 64) = 1;
      *(_DWORD *)(v8 + 66) = 0;
      *(_DWORD *)(v8 + 68) = 0;
      *(_QWORD *)(v8 + 40) = 0LL;
      *(_QWORD *)(v8 + 32) = 0LL;
      *(_QWORD *)(v8 + 56) = 0LL;
      *(_QWORD *)(v8 + 48) = 0LL;
      *(_WORD *)(v8 + 66) = 0;
      *(_WORD *)(v8 + 70) = 0;
    }
    else
    {
      v8 = 0LL;
    }
    v9 = (ai *)v8;
    v12 = v8;
    sub_180038A00(0LL, v8);
    *(_WORD *)(a2 + 16) = *(_DWORD *)(v8 + 28) != 0 ? 4 : 0;
    if ( !*(_BYTE *)(v8 + 64) && !*(_WORD *)(v8 + 66) && !*(_WORD *)(v8 + 70) && !*(_WORD *)(v8 + 68) )
      *(_DWORD *)(a2 + 20) |= 2u;
    if ( *(_DWORD *)(v8 + 28) == 2 )
      *(_DWORD *)(a2 + 20) |= 0x10u;
    if ( !*(_BYTE *)(v8 + 64) )
      *(_DWORD *)a2 = 0;
    if ( a3 != (void **)&v12 )
    {
      v9 = 0LL;
      v11 = (ai *)*a3;
      *a3 = (void *)v8;
      if ( v11 )
        sub_180031DC0(v11, v10);
    }
    if ( v9 )
      sub_180031DC0(v9, v10);
  }
}


// ===== 函数: sub_180038A00 (0x180038A00) =====
__int64 __fastcall sub_180038A00(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = sub_180038060("PNGFileFormat", a1, a2);
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = -1;
  return result;
}


// ===== 函数: sub_180038060 (0x180038060) =====
void __fastcall sub_180038060(__int64 a1, _OWORD *a2, __int64 a3)
{
  __int64 v5; // r15
  int v6; // eax
  _QWORD *v7; // rax
  __int128 *v8; // rax
  __int128 *v9; // rax
  __int64 v10; // rax
  double v11; // xmm0_8
  int v12; // eax
  _QWORD *v13; // rax
  int v14; // eax
  _QWORD *v15; // rax
  int v16; // eax
  _QWORD *v17; // rax
  int v18; // ecx
  int v19; // eax
  _QWORD *v20; // rax
  int v21; // eax
  _QWORD *v22; // rax
  int v23; // eax
  _QWORD *v24; // rax
  int v25; // [rsp+20h] [rbp-188h] BYREF
  int v26; // [rsp+24h] [rbp-184h] BYREF
  int v27; // [rsp+28h] [rbp-180h] BYREF
  int v28; // [rsp+2Ch] [rbp-17Ch] BYREF
  double v29; // [rsp+30h] [rbp-178h] BYREF
  double v30[2]; // [rsp+38h] [rbp-170h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+48h] [rbp-160h] BYREF
  _BYTE v32[40]; // [rsp+70h] [rbp-138h] BYREF
  _BYTE v33[40]; // [rsp+98h] [rbp-110h] BYREF
  _BYTE v34[40]; // [rsp+C0h] [rbp-E8h] BYREF
  _BYTE v35[40]; // [rsp+E8h] [rbp-C0h] BYREF
  _BYTE v36[40]; // [rsp+110h] [rbp-98h] BYREF
  _BYTE v37[40]; // [rsp+138h] [rbp-70h] BYREF
  const ai::Error *v38; // [rsp+160h] [rbp-48h] BYREF
  const std::exception *v39; // [rsp+168h] [rbp-40h] BYREF
  __int64 v40; // [rsp+170h] [rbp-38h] BYREF
  int v42; // [rsp+1C8h] [rbp+20h] BYREF

  v30[1] = NAN;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 72.0;
  v5 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  if ( dword_180074868 > *(_DWORD *)(v5 + 4) )
  {
    Init_thread_header(&dword_180074868);
    if ( dword_180074868 == -1 )
    {
      xmmword_180074848 = 0LL;
      qword_180074858 = (__int64)"AI Preference Suite";
      dword_180074860 = 7;
      byte_180074864 = 0;
      Init_thread_footer(&dword_180074868);
    }
  }
  try
  {
    if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
    {
      v6 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
             qword_180074858,
             (unsigned int)dword_180074860,
             (char *)&xmmword_180074848 + 8);
      if ( v6 )
      {
        sub_180003F80((__int64)pExceptionObject, v6, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      if ( !byte_180074864 )
      {
        v7 = sub_180012E90();
        *(_QWORD *)&xmmword_180074848 = *v7;
        *v7 = &xmmword_180074848;
      }
    }
    (*(void (__fastcall **)(__int64, const char *, double *))(*((_QWORD *)&xmmword_180074848 + 1) + 32LL))(
      a1,
      "ResolutionR",
      &v29);
    v8 = sub_180007F60();
    if ( sub_180037F00((__int64)v8) )
    {
      v30[0] = 1.0;
      v9 = sub_180007F60();
      v10 = sub_180007790((__int64)v9);
      (*(void (__fastcall **)(double *))(v10 + 624))(v30);
      v11 = v29 * v30[0];
      v29 = v29 * v30[0];
    }
    else
    {
      v11 = v29;
    }
    *(float *)(a3 + 12) = v11;
    *(_DWORD *)(a3 + 28) = 2;
    if ( dword_180074868 > *(_DWORD *)(v5 + 4) )
    {
      Init_thread_header(&dword_180074868);
      if ( dword_180074868 == -1 )
      {
        xmmword_180074848 = 0LL;
        qword_180074858 = (__int64)"AI Preference Suite";
        dword_180074860 = 7;
        byte_180074864 = 0;
        Init_thread_footer(&dword_180074868);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
    {
      v12 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
              qword_180074858,
              (unsigned int)dword_180074860,
              (char *)&xmmword_180074848 + 8);
      if ( v12 )
      {
        sub_180003F80((__int64)v32, v12, 0LL);
        throw (ai::Error *)v32;
      }
      if ( !byte_180074864 )
      {
        v13 = sub_180012E90();
        *(_QWORD *)&xmmword_180074848 = *v13;
        *v13 = &xmmword_180074848;
      }
    }
    (*(void (__fastcall **)(__int64, const char *, __int64))(*((_QWORD *)&xmmword_180074848 + 1) + 16LL))(
      a1,
      "AntiAlias",
      a3 + 28);
    v42 = 0;
    if ( dword_180074868 > *(_DWORD *)(v5 + 4) )
    {
      Init_thread_header(&dword_180074868);
      if ( dword_180074868 == -1 )
      {
        xmmword_180074848 = 0LL;
        qword_180074858 = (__int64)"AI Preference Suite";
        dword_180074860 = 7;
        byte_180074864 = 0;
        Init_thread_footer(&dword_180074868);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
    {
      v14 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
              qword_180074858,
              (unsigned int)dword_180074860,
              (char *)&xmmword_180074848 + 8);
      if ( v14 )
      {
        sub_180003F80((__int64)v33, v14, 0LL);
        throw (ai::Error *)v33;
      }
      if ( !byte_180074864 )
      {
        v15 = sub_180012E90();
        *(_QWORD *)&xmmword_180074848 = *v15;
        *v15 = &xmmword_180074848;
      }
    }
    (**((void (__fastcall ***)(__int64, const char *, int *))&xmmword_180074848 + 1))(a1, "Interlaced", &v42);
    *(_BYTE *)a3 = v42 != 0;
    v25 = 1;
    if ( dword_180074868 > *(_DWORD *)(v5 + 4) )
    {
      Init_thread_header(&dword_180074868);
      if ( dword_180074868 == -1 )
      {
        xmmword_180074848 = 0LL;
        qword_180074858 = (__int64)"AI Preference Suite";
        dword_180074860 = 7;
        byte_180074864 = 0;
        Init_thread_footer(&dword_180074868);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
    {
      v16 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
              qword_180074858,
              (unsigned int)dword_180074860,
              (char *)&xmmword_180074848 + 8);
      if ( v16 )
      {
        sub_180003F80((__int64)v34, v16, 0LL);
        throw (ai::Error *)v34;
      }
      if ( !byte_180074864 )
      {
        v17 = sub_180012E90();
        *(_QWORD *)&xmmword_180074848 = *v17;
        *v17 = &xmmword_180074848;
      }
    }
    (**((void (__fastcall ***)(__int64, const char *, int *))&xmmword_180074848 + 1))(a1, "BackgroundTransparent", &v25);
    v18 = v25;
    *(_BYTE *)(a3 + 64) = v25 != 0;
    if ( v18 )
    {
      *(_DWORD *)(a3 + 68) = 16711935;
      *(_WORD *)(a3 + 66) = 255;
    }
    else
    {
      if ( dword_180074868 > *(_DWORD *)(v5 + 4) )
      {
        Init_thread_header(&dword_180074868);
        if ( dword_180074868 == -1 )
        {
          xmmword_180074848 = 0LL;
          qword_180074858 = (__int64)"AI Preference Suite";
          dword_180074860 = 7;
          byte_180074864 = 0;
          Init_thread_footer(&dword_180074868);
        }
      }
      if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
      {
        v19 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
                qword_180074858,
                (unsigned int)dword_180074860,
                (char *)&xmmword_180074848 + 8);
        if ( v19 )
        {
          sub_180003F80((__int64)v35, v19, 0LL);
          throw (ai::Error *)v35;
        }
        if ( !byte_180074864 )
        {
          v20 = sub_180012E90();
          *(_QWORD *)&xmmword_180074848 = *v20;
          *v20 = &xmmword_180074848;
        }
      }
      (*(void (__fastcall **)(__int64, const char *, int *))(*((_QWORD *)&xmmword_180074848 + 1) + 16LL))(
        a1,
        "Background/red",
        &v26);
      if ( dword_180074868 > *(_DWORD *)(v5 + 4) )
      {
        Init_thread_header(&dword_180074868);
        if ( dword_180074868 == -1 )
        {
          xmmword_180074848 = 0LL;
          qword_180074858 = (__int64)"AI Preference Suite";
          dword_180074860 = 7;
          byte_180074864 = 0;
          Init_thread_footer(&dword_180074868);
        }
      }
      if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
      {
        v21 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
                qword_180074858,
                (unsigned int)dword_180074860,
                (char *)&xmmword_180074848 + 8);
        if ( v21 )
        {
          sub_180003F80((__int64)v36, v21, 0LL);
          throw (ai::Error *)v36;
        }
        if ( !byte_180074864 )
        {
          v22 = sub_180012E90();
          *(_QWORD *)&xmmword_180074848 = *v22;
          *v22 = &xmmword_180074848;
        }
      }
      (*(void (__fastcall **)(__int64, const char *, int *))(*((_QWORD *)&xmmword_180074848 + 1) + 16LL))(
        a1,
        "Background/green",
        &v27);
      if ( dword_180074868 > *(_DWORD *)(v5 + 4) )
      {
        Init_thread_header(&dword_180074868);
        if ( dword_180074868 == -1 )
        {
          xmmword_180074848 = 0LL;
          qword_180074858 = (__int64)"AI Preference Suite";
          dword_180074860 = 7;
          byte_180074864 = 0;
          Init_thread_footer(&dword_180074868);
        }
      }
      if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
      {
        v23 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
                qword_180074858,
                (unsigned int)dword_180074860,
                (char *)&xmmword_180074848 + 8);
        if ( v23 )
        {
          sub_180003F80((__int64)v37, v23, 0LL);
          throw (ai::Error *)v37;
        }
        if ( !byte_180074864 )
        {
          v24 = sub_180012E90();
          *(_QWORD *)&xmmword_180074848 = *v24;
          *v24 = &xmmword_180074848;
        }
      }
      (*(void (__fastcall **)(__int64, const char *, int *))(*((_QWORD *)&xmmword_180074848 + 1) + 16LL))(
        a1,
        "Background/blue",
        &v28);
      *(_WORD *)(a3 + 66) = v26;
      *(_WORD *)(a3 + 68) = v27;
      *(_WORD *)(a3 + 70) = v28;
    }
    if ( a2 )
    {
      *(_OWORD *)(a3 + 32) = *a2;
      *(_OWORD *)(a3 + 48) = a2[1];
      sub_180038A30(a3 + 12, a3 + 32);
    }
  }
  catch ( const ai::Error *v38 )
  {
    return;
  }
  catch ( const std::exception *v39 )
  {
    return;
  }
  catch ( int v40 )
  {
    return;
  }
  catch ( ... )
  {
  }
}


// ===== 函数: sub_1800388B0 (0x1800388B0) =====
__int64 __fastcall sub_1800388B0(__int64 a1, __int64 a2)
{
  int v3; // eax
  _QWORD *v4; // rax
  __int64 result; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  unsigned int v7; // [rsp+70h] [rbp+18h] BYREF

  sub_180038060("PNG8", a1, a2);
  v7 = 256;
  if ( dword_180074868 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                   + 4LL) )
  {
    Init_thread_header(&dword_180074868);
    if ( dword_180074868 == -1 )
    {
      xmmword_180074848 = 0LL;
      qword_180074858 = (__int64)"AI Preference Suite";
      dword_180074860 = 7;
      byte_180074864 = 0;
      Init_thread_footer(&dword_180074868);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
  {
    v3 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074858,
           (unsigned int)dword_180074860,
           (char *)&xmmword_180074848 + 8);
    if ( v3 )
    {
      sub_180003F80((__int64)pExceptionObject, v3, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !byte_180074864 )
    {
      v4 = sub_180012E90();
      *(_QWORD *)&xmmword_180074848 = *v4;
      *v4 = &xmmword_180074848;
    }
  }
  (*(void (__fastcall **)(const char *, const char *, unsigned int *))(*((_QWORD *)&xmmword_180074848 + 1) + 16LL))(
    "PNG8",
    "NumberOfColors",
    &v7);
  result = v7;
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = -1;
  return result;
}


// ===== 函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_2 (0x180022590) =====
void __noreturn std::vector<void *>::_Xlen()
{
  std::_Xout_of_range("invalid vector subscript");
  JUMPOUT(0x1800225A0LL);
}


// ===== 函数: sub_18000B980 (0x18000B980) =====
_QWORD *__fastcall sub_18000B980(
        _QWORD *a1,
        __int64 a2,
        void **a3,
        _QWORD *a4,
        unsigned __int64 *a5,
        __int64 a6,
        __int64 a7,
        int *a8)
{
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r14
  int v13; // edi
  __int64 v14; // rdx
  void **v15; // r8
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rcx
  int v18; // ebx
  int v19; // eax
  unsigned __int64 v21; // [rsp+40h] [rbp-C0h] BYREF
  unsigned __int64 v22; // [rsp+48h] [rbp-B8h]
  _QWORD v23[9]; // [rsp+50h] [rbp-B0h] BYREF
  _BYTE v24[24]; // [rsp+98h] [rbp-68h] BYREF
  _BYTE v25[56]; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v26; // [rsp+E8h] [rbp-18h]
  char v27[56]; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v28; // [rsp+128h] [rbp+28h]
  char v29[48]; // [rsp+130h] [rbp+30h] BYREF

  v23[2] = -2LL;
  v11 = sub_180031D20((ai *)0x120, a2, a3);
  v12 = v11;
  v23[3] = v11;
  if ( v11 )
  {
    *(_OWORD *)v11 = 0LL;
    *(_DWORD *)(v11 + 8) = 1;
    *(_DWORD *)(v11 + 12) = 1;
    *(_QWORD *)v11 = &std::_Ref_count_obj2<FastExportTask>::`vftable';
    v13 = *a8;
    v23[4] = v25;
    v26 = 0LL;
    sub_18000DF40((__int64)v25, a6);
    v28 = 0LL;
    sub_18000DF40((__int64)v27, a6 + 64);
    v23[5] = &v21;
    v21 = 0LL;
    v22 = 0LL;
    v16 = sub_180031D20((ai *)0x28, v14, v15);
    *(_QWORD *)v16 = v16;
    *(_QWORD *)(v16 + 8) = v16;
    *(_QWORD *)(v16 + 16) = v16;
    *(_WORD *)(v16 + 24) = 257;
    v21 = *a5;
    *a5 = v16;
    v17 = v22;
    v22 = a5[1];
    a5[1] = v17;
    v23[6] = v23;
    v23[0] = *a4;
    *a4 = 0LL;
    v23[7] = v24;
    v18 = sub_180030590(v24, a3);
    v19 = sub_180030DB0(v29, a2);
    sub_180030820(v12 + 16, v19, v18, (unsigned int)v23, (__int64)&v21, (__int64)v25, a7, v13);
  }
  else
  {
    v12 = 0LL;
  }
  *a1 = v12 + 16;
  a1[1] = v12;
  return a1;
}


// ===== 函数: sub_180030820 (0x180030820) =====
__int64 __fastcall sub_180030820(
        __int64 a1,
        __int64 *a2,
        void **a3,
        _QWORD *a4,
        __int64 *a5,
        __int64 a6,
        __int64 a7,
        int a8)
{
  __int64 v11; // rdx
  __int64 v12; // rcx
  _QWORD *v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rax
  __int64 v17; // rdx
  char *v18; // rcx
  void *v19; // rax
  unsigned __int64 v20; // rax
  __int64 v21; // rcx
  __int64 v22; // rbp
  int v23; // eax
  _QWORD *v24; // rbx
  __int64 v25; // rcx
  __int64 v26; // rbx
  __int64 i; // rsi
  __int64 v28; // rcx
  _QWORD *v29; // rbx
  _QWORD *j; // rsi
  __int64 v31; // r8
  char *v32; // rsi
  char *v33; // rbp
  _QWORD *v34; // rbx
  __int64 v35; // rcx
  __int64 v36; // rcx
  __int64 v37; // rcx
  _QWORD *v38; // rdi
  _QWORD *v39; // r8
  __int64 v40; // rdx
  __int64 v41; // rcx
  __int64 v42; // rcx
  int v44; // [rsp+30h] [rbp-B8h] BYREF
  int v45; // [rsp+38h] [rbp-B0h] BYREF
  __int64 v46; // [rsp+40h] [rbp-A8h] BYREF
  __int64 v47; // [rsp+48h] [rbp-A0h] BYREF
  _QWORD v48[3]; // [rsp+50h] [rbp-98h] BYREF
  _BYTE pExceptionObject[128]; // [rsp+68h] [rbp-80h] BYREF

  v48[1] = -2LL;
  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 8) = *a4;
  *a4 = 0LL;
  v11 = a2[2];
  a2[2] = 0LL;
  v12 = a2[1];
  a2[1] = 0LL;
  v13 = (_QWORD *)*a2;
  *a2 = 0LL;
  *(_QWORD *)(a1 + 16) = v13;
  *(_QWORD *)(a1 + 24) = v12;
  *(_QWORD *)(a1 + 32) = v11;
  v14 = a2[5];
  a2[5] = 0LL;
  v15 = a2[4];
  a2[4] = 0LL;
  v16 = a2[3];
  a2[3] = 0LL;
  *(_QWORD *)(a1 + 40) = v16;
  *(_QWORD *)(a1 + 48) = v15;
  *(_QWORD *)(a1 + 56) = v14;
  v17 = (__int64)a3[2];
  a3[2] = 0LL;
  v18 = (char *)a3[1];
  a3[1] = 0LL;
  v19 = *a3;
  *a3 = 0LL;
  *(_QWORD *)(a1 + 64) = v19;
  *(_QWORD *)(a1 + 72) = v18;
  *(_QWORD *)(a1 + 80) = v17;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  v20 = sub_180031D20((ai *)0x28, v17, a3);
  *(_QWORD *)v20 = v20;
  *(_QWORD *)(v20 + 8) = v20;
  *(_QWORD *)(v20 + 16) = v20;
  *(_WORD *)(v20 + 24) = 257;
  *(_QWORD *)(a1 + 88) = v20;
  *(_QWORD *)(a1 + 88) = *a5;
  *a5 = v20;
  v21 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)(a1 + 96) = a5[1];
  a5[1] = v21;
  *(_DWORD *)(a1 + 104) = (*(_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL) - *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8LL))
                        / 88LL
                        * ((*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16))
                         / 40LL);
  *(_DWORD *)(a1 + 108) = 0;
  *(_QWORD *)(a1 + 120) = 0x3FF0000000000000LL;
  *(_QWORD *)(a1 + 184) = 0LL;
  sub_18000DF40(a1 + 128, a6);
  *(_QWORD *)(a1 + 248) = 0LL;
  v22 = a6 + 64;
  sub_18000DF40(a1 + 192, a6 + 64);
  *(_QWORD *)(a1 + 256) = a7;
  *(_DWORD *)(a1 + 264) = a8;
  v46 = 0LL;
  v23 = (*(__int64 (__fastcall **)(__int64 *))(gAIDocumentSuite + 160))(&v46);
  if ( v23 )
    goto LABEL_47;
  if ( !v46 )
  {
    sub_180004080(pExceptionObject, "No document");
    throw (ai::Contract::Violation *)pExceptionObject;
  }
  *(_QWORD *)(a1 + 112) = v46;
  (*(void (__fastcall **)(__int64))(gAIDocumentSuite + 624))(a1 + 120);
  if ( *(_QWORD *)(a1 + 184) )
  {
    v24 = unknown_libname_2(v48);
    v48[2] = v24;
    v44 = *(_DWORD *)(a1 + 104);
    v45 = *(_DWORD *)(a1 + 108);
    v47 = *(_QWORD *)(a1 + 112);
    v25 = *(_QWORD *)(a1 + 184);
    if ( v25 )
    {
      (*(void (__fastcall **)(__int64, __int64 *, int *, int *, _QWORD *))(*(_QWORD *)v25 + 16LL))(
        v25,
        &v47,
        &v45,
        &v44,
        v24);
      sub_180036A90(v24);
      goto LABEL_6;
    }
    std::_Xbad_function_call();
LABEL_47:
    sub_180003F80(
      (__int64)pExceptionObject,
      v23,
      (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\PlugInDev\\SmartExport\\"
               "Source\\FastExportParams.cpp line: 316 ");
    throw (ai::Error *)pExceptionObject;
  }
LABEL_6:
  v26 = a2[3];
  if ( v26 )
  {
    for ( i = a2[4]; v26 != i; v26 += 8LL )
      sub_18000C810(v26);
    v28 = a2[3];
    if ( (unsigned __int64)(8 * ((a2[5] - v28) >> 3)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v28 - *(_QWORD *)(v28 - 8) - 8) > 0x1F )
        goto LABEL_44;
      v28 = *(_QWORD *)(v28 - 8);
    }
    sub_18001AE10(v28);
    a2[3] = 0LL;
    a2[4] = 0LL;
    a2[5] = 0LL;
  }
  v29 = (_QWORD *)*a2;
  if ( !*a2 )
    goto LABEL_20;
  for ( j = (_QWORD *)a2[1]; v29 != j; v29 += 5 )
  {
    sub_180030E80(v29 + 1);
    sub_180036A90(v29);
  }
  v31 = *a2;
  if ( (unsigned __int64)(40 * ((a2[2] - *a2) / 40)) >= 0x1000 )
  {
    if ( (unsigned __int64)(v31 - *(_QWORD *)(v31 - 8) - 8) <= 0x1F )
    {
      v31 = *(_QWORD *)(v31 - 8);
      goto LABEL_19;
    }
LABEL_44:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  sub_18001AE10(v31);
  v29 = 0LL;
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
LABEL_20:
  v32 = (char *)*a3;
  if ( *a3 )
  {
    v33 = (char *)a3[1];
    if ( v32 != v33 )
    {
      v34 = v32 + 104;
      do
      {
        if ( *v34 >= 0x10uLL )
        {
          v35 = *(v34 - 3);
          if ( (unsigned __int64)(*v34 + 1LL) >= 0x1000 )
          {
            if ( (unsigned __int64)(v35 - *(_QWORD *)(v35 - 8) - 8) > 0x1F )
              goto LABEL_45;
            v35 = *(_QWORD *)(v35 - 8);
          }
          sub_18001AE10(v35);
        }
        *(v34 - 1) = 0LL;
        *v34 = 15LL;
        *((_BYTE *)v34 - 24) = 0;
        sub_18000C030((__int64)(v34 - 5));
        v36 = *(v34 - 10);
        if ( v36 )
          sub_180031DC0(v36);
        v37 = *(v34 - 11);
        if ( v37 )
          sub_180031DC0(v37);
        v38 = (_QWORD *)*(v34 - 12);
        if ( v38 )
        {
          sub_180036A90(v38 + 19);
          sub_180036A90(v38 + 17);
          sub_180036A90(v38 + 15);
          sub_180031DC0(v38);
        }
        v32 += 112;
        v34 += 14;
      }
      while ( v32 != v33 );
    }
    v39 = *a3;
    if ( (unsigned __int64)(112 * (((_BYTE *)a3[2] - (_BYTE *)*a3) / 112)) >= 0x1000 )
    {
      if ( (unsigned __int64)v39 - *(v39 - 1) - 8 > 0x1F )
LABEL_45:
        invalid_parameter_noinfo_noreturn();
      v39 = (_QWORD *)*(v39 - 1);
    }
    sub_18001AE10((__int64)v39);
    v29 = 0LL;
    *a3 = 0LL;
    a3[1] = 0LL;
    a3[2] = 0LL;
    v22 = a6 + 64;
  }
  sub_180032550(a4);
  sub_18000B7F0(a5, a5, *(_QWORD *)(*a5 + 8));
  sub_18001AE10(*a5);
  v41 = *(_QWORD *)(v22 + 56);
  if ( v41 )
  {
    LOBYTE(v40) = v41 != v22;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v41 + 32LL))(v41, v40);
    *(_QWORD *)(v22 + 56) = v29;
  }
  v42 = *(_QWORD *)(a6 + 56);
  if ( v42 )
  {
    LOBYTE(v40) = v42 != a6;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v42 + 32LL))(v42, v40);
    *(_QWORD *)(a6 + 56) = v29;
  }
  return a1;
}


// ===== 函数: sub_180030E80 (0x180030E80) =====
__int64 __fastcall sub_180030E80(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 i; // rsi
  __int64 v4; // r8
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != i; v1 += 88LL )
    {
      sub_180036A90((_QWORD *)(v1 + 16));
      sub_180036A90((_QWORD *)(v1 + 8));
    }
    v4 = *a1;
    if ( (unsigned __int64)(88 * ((a1[2] - *a1) / 88)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_18001AE10(v4);
    result = 0LL;
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }
  return result;
}


// ===== 函数: ?_Xbad_function_call@std@@YAXXZ (0x18004BD0C) =====
// attributes: thunk
void std::_Xbad_function_call(void)
{
  __imp_?_Xbad_function_call@std@@YAXXZ();
}


// ===== 函数: sub_18000C810 (0x18000C810) =====
void __fastcall sub_18000C810(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rax

  if ( *a1 )
  {
    try
    {
      v2 = sub_180006BC0(&unk_18007406D);
      v3 = sub_180007790(v2);
      (*(void (__fastcall **)(_QWORD))(v3 + 16))(*a1);
    }
    catch ( ai::Error )
    {
      return;
    }
    catch ( std::exception )
    {
      return;
    }
    catch ( int )
    {
      return;
    }
    catch ( ... )
    {
    }
  }
}


// ===== 函数: sub_180006BC0 (0x180006BC0) =====
__int128 *sub_180006BC0()
{
  _QWORD *v1; // rax

  if ( dword_180073E58 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180073E38;
  Init_thread_header(&dword_180073E58);
  if ( dword_180073E58 != -1 )
    return &xmmword_180073E38;
  xmmword_180073E38 = 0LL;
  qword_180073E48 = (__int64)"AI Multithreaded Rasterization Suite";
  dword_180073E50 = 1;
  byte_180073E54 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180073E38 = *v1;
  *v1 = &xmmword_180073E38;
  Init_thread_footer(&dword_180073E58);
  return &xmmword_180073E38;
}


// ===== 函数: sub_180030590 (0x180030590) =====
_QWORD *__fastcall sub_180030590(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v3; // r9
  __int64 v4; // r8
  _QWORD *result; // rax

  v2 = *a2;
  v3 = a2[2];
  v4 = a2[1];
  a2[2] = 0LL;
  a2[1] = 0LL;
  *a2 = 0LL;
  *a1 = v2;
  result = a1;
  a1[1] = v4;
  a1[2] = v3;
  return result;
}


// ===== 函数: sub_180030DB0 (0x180030DB0) =====
_QWORD *__fastcall sub_180030DB0(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v3; // r9
  __int64 v5; // r8
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rdx
  _QWORD *result; // rax

  v2 = *a2;
  v3 = a2[2];
  v5 = a2[1];
  a2[2] = 0LL;
  a2[1] = 0LL;
  *a2 = 0LL;
  *a1 = v2;
  a1[1] = v5;
  a1[2] = v3;
  v7 = a2[3];
  v8 = a2[4];
  v9 = a2[5];
  a2[4] = 0LL;
  a2[3] = 0LL;
  a2[5] = 0LL;
  a1[3] = v7;
  result = a1;
  a1[4] = v8;
  a1[5] = v9;
  return result;
}


// ===== 函数: sub_1800160E0 (0x1800160E0) =====
int __fastcall sub_1800160E0(__int64 a1, __int64 a2)
{
  struct _Mtx_internal_imp_t *v3; // rbx
  int v4; // eax
  _BYTE v6[32]; // [rsp+28h] [rbp-20h] BYREF
  __int64 v7; // [rsp+58h] [rbp+10h] BYREF

  v7 = a2;
  v3 = (struct _Mtx_internal_imp_t *)(a1 + 64);
  v4 = Mtx_lock((_Mtx_t)(a1 + 64));
  if ( v4 )
  {
    std::_Throw_C_error(v4);
    JUMPOUT(0x18001613CLL);
  }
  sub_1800157C0(a1, v6, &v7);
  return Mtx_unlock(v3);
}


// ===== 函数: sub_1800157C0 (0x1800157C0) =====
__int64 __fastcall sub_1800157C0(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // r13
  __int64 v7; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rbx
  _QWORD *v10; // r12
  _QWORD *v11; // r15
  _QWORD *v12; // rcx
  _QWORD *v14; // rsi
  float v15; // xmm3_4
  __int64 v16; // rcx
  float v17; // xmm0_4
  unsigned __int64 v18; // rdi
  float v19; // xmm2_4
  __int64 v20; // rcx
  float v21; // xmm0_4
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  _QWORD *v26; // rax
  _QWORD *v27; // rdx
  __int64 v28; // rcx
  _QWORD *v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // rax
  _QWORD *v32; // r8
  _QWORD *v33; // [rsp+30h] [rbp-38h]

  v6 = 0x100000001B3LL
     * (a3[7] ^ (0x100000001B3LL
               * (a3[6] ^ (0x100000001B3LL
                         * (a3[5] ^ (0x100000001B3LL
                                   * (a3[4] ^ (0x100000001B3LL
                                             * (a3[3] ^ (0x100000001B3LL
                                                       * (a3[2] ^ (0x100000001B3LL
                                                                 * (a3[1] ^ (0x100000001B3LL
                                                                           * (*a3 ^ 0xCBF29CE484222325uLL)))))))))))))));
  v7 = 2 * (v6 & *(_QWORD *)(a1 + 48));
  v8 = *(_QWORD *)(a1 + 24);
  v9 = *(_QWORD **)(v8 + 8 * v7 + 8);
  v10 = *(_QWORD **)(a1 + 8);
  if ( v9 == v10 )
  {
    v9 = *(_QWORD **)(a1 + 8);
    v11 = v9;
    goto LABEL_9;
  }
  v12 = *(_QWORD **)(v8 + 8 * v7);
  if ( *(_QWORD *)a3 != v9[2] )
  {
    while ( v9 != v12 )
    {
      v9 = (_QWORD *)v9[1];
      if ( *(_QWORD *)a3 == v9[2] )
        goto LABEL_6;
    }
    v10 = v9;
    v11 = v9;
LABEL_9:
    if ( *(_QWORD *)(a1 + 16) == 0xAAAAAAAAAAAAAAALL )
      std::_Xlength_error("unordered_map/set too long");
    v14 = (_QWORD *)sub_180031D20((ai *)0x18, a1 + 8, (void **)a3);
    v14[2] = *(_QWORD *)a3;
    v15 = *(float *)a1;
    v16 = *(_QWORD *)(a1 + 16) + 1LL;
    if ( v16 < 0 )
      v17 = (float)(v16 & 1 | (unsigned int)((unsigned __int64)v16 >> 1))
          + (float)(v16 & 1 | (unsigned int)((unsigned __int64)v16 >> 1));
    else
      v17 = (float)(int)v16;
    v18 = *(_QWORD *)(a1 + 56);
    if ( (v18 & 0x8000000000000000uLL) != 0LL )
    {
      v20 = *(_QWORD *)(a1 + 56) & 1LL | (v18 >> 1);
      v19 = (float)(int)v20 + (float)(int)v20;
    }
    else
    {
      v19 = (float)(int)v18;
    }
    if ( (float)(v17 / v19) <= v15 )
    {
LABEL_33:
      v29 = (_QWORD *)v9[1];
      ++*(_QWORD *)(a1 + 16);
      *v14 = v10;
      v14[1] = v29;
      *v29 = v14;
      v9[1] = v14;
      v30 = *(_QWORD *)(a1 + 24);
      v31 = 2 * (v6 & *(_QWORD *)(a1 + 48));
      v32 = *(_QWORD **)(v30 + 16 * (v6 & *(_QWORD *)(a1 + 48)));
      if ( v32 == *(_QWORD **)(a1 + 8) )
      {
        *(_QWORD *)(v30 + 16 * (v6 & *(_QWORD *)(a1 + 48))) = v14;
LABEL_39:
        *(_QWORD *)(v30 + 8 * v31 + 8) = v14;
        goto LABEL_40;
      }
      if ( v32 == v11 )
      {
        *(_QWORD *)(v30 + 16 * (v6 & *(_QWORD *)(a1 + 48))) = v14;
      }
      else if ( *(_QWORD **)(v30 + 16 * (v6 & *(_QWORD *)(a1 + 48)) + 8) == v29 )
      {
        goto LABEL_39;
      }
LABEL_40:
      *(_QWORD *)a2 = v14;
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
    v21 = ceilf(v17 / v15);
    v22 = 0LL;
    if ( v21 >= 9.223372e18 )
    {
      v21 = v21 - 9.223372e18;
      if ( v21 < 9.223372e18 )
        v22 = 0x8000000000000000uLL;
    }
    v23 = v22 + (unsigned int)(int)v21;
    v24 = 8LL;
    if ( v23 > 8 )
      v24 = v23;
    if ( v18 < v24 )
    {
      if ( v18 >= 0x200 || (v18 *= 8LL, v18 < v24) )
        v18 = v24;
    }
    sub_180015B90(a1, v18);
    v25 = *(_QWORD *)(a1 + 24);
    v26 = *(_QWORD **)(v25 + 16 * (v6 & *(_QWORD *)(a1 + 48)) + 8);
    v9 = *(_QWORD **)(a1 + 8);
    if ( v26 != v9 )
    {
      v27 = *(_QWORD **)(v25 + 16 * (v6 & *(_QWORD *)(a1 + 48)));
      v28 = v14[2];
      if ( v28 != v26[2] )
      {
        while ( 1 )
        {
          v9 = v26;
          if ( v26 == v27 )
            break;
          v26 = (_QWORD *)v26[1];
          if ( v28 == v26[2] )
            goto LABEL_30;
        }
        v33 = v26;
        goto LABEL_32;
      }
LABEL_30:
      v9 = (_QWORD *)*v26;
    }
    v33 = v9;
LABEL_32:
    v11 = v9;
    v10 = v33;
    goto LABEL_33;
  }
LABEL_6:
  *(_QWORD *)a2 = v9;
  *(_BYTE *)(a2 + 8) = 0;
  return a2;
}


// ===== 函数: ceilf (0x18004D12A) =====
// attributes: thunk
float __cdecl ceilf(float X)
{
  return __imp_ceilf(X);
}


// ===== 函数: sub_180015B90 (0x180015B90) =====
_QWORD *__fastcall sub_180015B90(_QWORD *a1, unsigned __int64 a2, void **a3)
{
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rax
  unsigned __int64 *v6; // rdx
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rcx
  __int64 v9; // r15
  unsigned __int64 *v10; // rcx
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // rax
  unsigned __int64 *v14; // rdi
  __int64 v15; // rcx
  unsigned __int64 *v16; // rax
  _QWORD *result; // rax
  _QWORD *v18; // rcx
  _QWORD *v19; // r11
  _QWORD *v20; // r9
  _QWORD *v21; // rdx
  __int64 v22; // r8
  _QWORD *v23; // r10
  _QWORD *v24; // r9
  _QWORD *v25; // r8
  _QWORD *v26; // rdx
  _QWORD *v27; // r10
  _QWORD *v28; // r9
  _QWORD *v29; // r8
  _QWORD *v30; // r10
  _QWORD *v31; // r9
  _QWORD *v32; // r8
  _QWORD *v33; // rdx
  unsigned __int64 v34; // [rsp+48h] [rbp+10h] BYREF

  _BitScanReverse64(&v4, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v4 )
    std::_Xlength_error("invalid hash bucket count");
  v5 = a2 - 1;
  v6 = (unsigned __int64 *)a1[4];
  v7 = a1[1];
  _BitScanReverse64(&v8, v5 | 1);
  v9 = 1LL << ((unsigned __int8)v8 + 1);
  v10 = (unsigned __int64 *)a1[3];
  v34 = v7;
  v11 = v6 - v10;
  if ( v11 >= 2 * v9 )
  {
    sub_180015AD0(v10, v6, &v34);
    goto LABEL_21;
  }
  if ( (unsigned __int64)(2 * v9) > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_36;
  v12 = 16 * v9;
  if ( (unsigned __int64)(16 * v9) < 0x1000 )
  {
    if ( v12 )
      v14 = (unsigned __int64 *)sub_180031D20((ai *)v12, (__int64)v6, a3);
    else
      v14 = 0LL;
    goto LABEL_11;
  }
  if ( v12 + 39 < v12 )
LABEL_36:
    Concurrency::cancel_current_task();
  v13 = sub_180031D20((ai *)(v12 + 39), (__int64)v6, a3);
  if ( !v13 )
    goto LABEL_19;
  v14 = (unsigned __int64 *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_11:
  if ( !v11 )
    goto LABEL_16;
  v15 = a1[3];
  if ( 8 * v11 >= 0x1000 )
  {
    if ( (unsigned __int64)(v15 - *(_QWORD *)(v15 - 8) - 8) <= 0x1F )
    {
      v15 = *(_QWORD *)(v15 - 8);
      goto LABEL_15;
    }
LABEL_19:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_15:
  sub_18001AE10(v15);
LABEL_16:
  v16 = &v14[v12 / 8];
  a1[3] = v14;
  a1[4] = &v14[v12 / 8];
  for ( a1[5] = &v14[v12 / 8]; v14 != v16; ++v14 )
    *v14 = v7;
LABEL_21:
  a1[7] = v9;
  result = (_QWORD *)(v9 - 1);
  a1[6] = v9 - 1;
  v18 = *(_QWORD **)a1[1];
  if ( v18 != (_QWORD *)v7 )
  {
    result = *(_QWORD **)a1[1];
    do
    {
      v18 = (_QWORD *)*v18;
      v19 = (_QWORD *)(a1[3]
                     + 16
                     * (a1[6] & (0x100000001B3LL
                               * (*((unsigned __int8 *)result + 23) ^ (0x100000001B3LL
                                                                     * (*((unsigned __int8 *)result + 22) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 21) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 20) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 19) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 18) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 17) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 16) ^ 0xCBF29CE484222325uLL))))))))))))))))));
      v20 = (_QWORD *)*v19;
      if ( *v19 == v7 )
      {
        *v19 = result;
        v19[1] = result;
      }
      else
      {
        v21 = (_QWORD *)v19[1];
        v22 = result[2];
        if ( v22 == v21[2] )
        {
          v23 = (_QWORD *)*v21;
          if ( (_QWORD *)*v21 != result )
          {
            v24 = (_QWORD *)result[1];
            *v24 = v18;
            v25 = (_QWORD *)v18[1];
            *v25 = v23;
            v26 = (_QWORD *)v23[1];
            *v26 = result;
            v23[1] = v25;
            v18[1] = v24;
            result[1] = v26;
          }
          v19[1] = result;
        }
        else if ( v20 == v21 )
        {
LABEL_32:
          v27 = (_QWORD *)result[1];
          *v27 = v18;
          v28 = (_QWORD *)v18[1];
          *v28 = v21;
          v29 = (_QWORD *)v21[1];
          *v29 = result;
          v21[1] = v28;
          v18[1] = v27;
          result[1] = v29;
          *v19 = result;
        }
        else
        {
          while ( 1 )
          {
            v21 = (_QWORD *)v21[1];
            if ( v22 == v21[2] )
              break;
            if ( v20 == v21 )
              goto LABEL_32;
          }
          v30 = (_QWORD *)*v21;
          v31 = (_QWORD *)result[1];
          *v31 = v18;
          v32 = (_QWORD *)v18[1];
          *v32 = v30;
          v33 = (_QWORD *)v30[1];
          *v33 = result;
          v30[1] = v32;
          v18[1] = v31;
          result[1] = v33;
        }
      }
      result = v18;
    }
    while ( v18 != (_QWORD *)v7 );
  }
  return result;
}


// ===== 函数: sub_180015AD0 (0x180015AD0) =====
unsigned __int64 __fastcall sub_180015AD0(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 *v5; // r9
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdx

  result = 0LL;
  v5 = a1;
  v6 = (unsigned __int64)((char *)a2 - (char *)a1 + 7) >> 3;
  if ( a1 > a2 )
    v6 = 0LL;
  if ( v6 >= 2 )
  {
    result = *a3;
    v7 = (unsigned __int64)&a1[v6 - 1];
    if ( v5 > a3 || v7 < (unsigned __int64)a3 )
    {
      v8 = 8 * (v6 & 0xFFFFFFFFFFFFFFFEuLL);
      memset64(v5, result, v8 >> 3);
      v5 = (unsigned __int64 *)((char *)v5 + v8);
    }
  }
  for ( ; v5 != a2; ++v5 )
  {
    result = *a3;
    *v5 = *a3;
  }
  return result;
}


// ===== 函数: sub_18000DA40 (0x18000DA40) =====
__int64 __fastcall sub_18000DA40(tbb::internal::concurrent_queue_base_v8 *a1, _QWORD *a2)
{
  volatile signed __int32 *v3; // rbx

  tbb::internal::concurrent_queue_base_v8::internal_push_move(a1, a2);
  v3 = (volatile signed __int32 *)a2[1];
  if ( v3 )
  {
    if ( _InterlockedExchangeAdd(v3 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v3)(v3);
      if ( _InterlockedExchangeAdd(v3 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8LL))(v3);
    }
  }
  return 0LL;
}


// ===== 函数: ?internal_push_move@concurrent_queue_base_v8@internal@tbb@@IEAAXPEBX@Z (0x18004BC04) =====
// attributes: thunk
void __fastcall tbb::internal::concurrent_queue_base_v8::internal_push_move(
        tbb::internal::concurrent_queue_base_v8 *this,
        const void *a2)
{
  __imp_?internal_push_move@concurrent_queue_base_v8@internal@tbb@@IEAAXPEBX@Z(this, a2);
}


// ===== 函数: sub_180004150 (0x180004150) =====
__int64 __fastcall sub_180004150(__int64 *a1)
{
  __int64 result; // rax
  __int128 *v3; // rax
  __int128 *v4; // rbx
  int v5; // eax
  _QWORD *v6; // rax
  __int64 (__fastcall *v7)(_QWORD *, __int64 *); // rbx
  _QWORD *v8; // rax
  int v9; // eax
  __int128 *v10; // rax
  __int128 *v11; // rbx
  int v12; // eax
  _QWORD *v13; // rax
  __int64 (__fastcall *v14)(__int64, __int64 *); // rbx
  __int64 v15; // rax
  int v16; // eax
  _BYTE pExceptionObject[48]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v18; // [rsp+78h] [rbp+10h] BYREF

  result = a1[3];
  if ( !result )
  {
    if ( *((_BYTE *)a1 + 16) )
    {
      v3 = sub_180004330();
      v4 = v3;
      if ( !*((_QWORD *)v3 + 1) && qword_1800740D8 )
      {
        v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
               *((_QWORD *)v3 + 2),
               *((unsigned int *)v3 + 6),
               (__int64)v3 + 8);
        if ( v5 )
        {
          sub_180003F80((__int64)pExceptionObject, v5, 0LL);
          throw (ai::Error *)pExceptionObject;
        }
        if ( !*((_BYTE *)v4 + 28) )
        {
          v6 = sub_180012E90();
          *(_QWORD *)v4 = *v6;
          *v6 = v4;
        }
      }
      v7 = (__int64 (__fastcall *)(_QWORD *, __int64 *))**((_QWORD **)v4 + 1);
      v8 = sub_1800367E0(&v18, *a1);
      v9 = v7(v8, a1 + 3);
      if ( v9 )
      {
        sub_180003F80(
          (__int64)pExceptionObject,
          v9,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "public\\api\\IAIGlobalUnicodeString.cpp line: 36 ");
        throw (ai::Error *)pExceptionObject;
      }
    }
    else
    {
      v10 = sub_180004330();
      v11 = v10;
      if ( !*((_QWORD *)v10 + 1) && qword_1800740D8 )
      {
        v12 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
                *((_QWORD *)v10 + 2),
                *((unsigned int *)v10 + 6),
                (__int64)v10 + 8);
        if ( v12 )
        {
          sub_180003F80((__int64)pExceptionObject, v12, 0LL);
          throw (ai::Error *)pExceptionObject;
        }
        if ( !*((_BYTE *)v11 + 28) )
        {
          v13 = sub_180012E90();
          *(_QWORD *)v11 = *v13;
          *v13 = v11;
        }
      }
      v14 = (__int64 (__fastcall *)(__int64, __int64 *))**((_QWORD **)v11 + 1);
      v15 = sub_180036750(&v18, *a1, a1[1], *((unsigned int *)a1 + 8));
      v16 = v14(v15, a1 + 3);
      if ( v16 )
      {
        sub_180003F80(
          (__int64)pExceptionObject,
          v16,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "public\\api\\IAIGlobalUnicodeString.cpp line: 36 ");
        throw (ai::Error *)pExceptionObject;
      }
    }
    result = a1[3];
    if ( !result )
    {
      sub_180004080(pExceptionObject, "Failed Postcondition");
      throw (ai::Contract::Violation *)pExceptionObject;
    }
  }
  return result;
}


// ===== 函数: sub_180004330 (0x180004330) =====
__int128 *sub_180004330()
{
  __int64 v1; // rcx
  _QWORD *v2; // rax

  if ( dword_180073E08 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180073DE8;
  Init_thread_header(&dword_180073E08);
  if ( dword_180073E08 != -1 )
    return &xmmword_180073DE8;
  xmmword_180073DE8 = 0LL;
  qword_180073DF8 = (__int64)"AI Global UnicodeString Suite";
  dword_180073E00 = 1;
  byte_180073E04 = 1;
  v2 = (_QWORD *)sub_180012E90(v1);
  *(_QWORD *)&xmmword_180073DE8 = *v2;
  *v2 = &xmmword_180073DE8;
  Init_thread_footer(&dword_180073E08);
  return &xmmword_180073DE8;
}


// ===== 函数: sub_180036750 (0x180036750) =====
_QWORD *__fastcall sub_180036750(_QWORD *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int128 *v8; // rax
  __int64 (__fastcall **v9)(_QWORD *, __int64, __int64, _QWORD); // rax
  int v10; // eax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  if ( a2 )
  {
    v8 = sub_180036EE0();
    v9 = (__int64 (__fastcall **)(_QWORD *, __int64, __int64, _QWORD))sub_180007790((__int64)v8);
    v10 = (*v9)(a1, a2, a3, a4);
    if ( v10 )
    {
      sub_180003F80((__int64)pExceptionObject, v10, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
  }
  return a1;
}


// ===== 函数: sub_18002E370 (0x18002E370) =====
__int64 __fastcall sub_18002E370(_QWORD *a1, __int64 *a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  __int64 v5; // rbx
  __int64 v7; // r14
  __int64 v8; // r12
  _DWORD *v9; // r15
  __int64 v10; // rax
  __int64 v11; // rax
  unsigned int v12; // esi
  volatile signed __int32 *v13; // rbx
  __int64 result; // rax
  __int64 v15; // rdx
  unsigned int v16; // esi
  volatile signed __int32 *v17; // rbx
  __int64 v18; // rax
  unsigned int v19; // esi
  volatile signed __int32 *v20; // rbx
  volatile signed __int32 *v21; // rbx
  volatile signed __int32 *v22; // rbx
  unsigned int v23; // [rsp+20h] [rbp-A8h] BYREF
  _BYTE v24[8]; // [rsp+28h] [rbp-A0h] BYREF
  __int64 v25; // [rsp+30h] [rbp-98h]
  const ai::Error *v26; // [rsp+40h] [rbp-88h] BYREF
  __int128 v27; // [rsp+50h] [rbp-78h] BYREF
  _BYTE v28[16]; // [rsp+60h] [rbp-68h] BYREF
  __int128 v29; // [rsp+70h] [rbp-58h] BYREF
  const std::exception *v30; // [rsp+80h] [rbp-48h] BYREF
  __int64 v31; // [rsp+D8h] [rbp+10h] BYREF
  __int64 v32; // [rsp+E0h] [rbp+18h]
  __int64 v33; // [rsp+E8h] [rbp+20h]

  v33 = a4;
  v32 = a3;
  v25 = -2LL;
  v5 = a4;
  v7 = *a2;
  v8 = a2[1];
  v9 = a5;
  try
  {
    while ( 1 )
    {
      if ( v7 == v8 )
        return 0LL;
      v10 = sub_18001D820(*a1);
      sub_180021470(v10, &v27);
      if ( !(_QWORD)v27 )
        break;
      v31 = 0LL;
      v11 = qword_1800744D8;
      if ( !qword_1800744D8 )
      {
        v11 = (*(__int64 (__fastcall **)(const char *))(gAIDictionarySuite + 64))("BG ScratchKey For Asset");
        qword_1800744D8 = v11;
      }
      sub_18001A360(v28, v11);
      v12 = sub_18001AB80(v28, &v31);
      if ( v12 )
      {
        sub_18001A3A0(v28);
        v13 = (volatile signed __int32 *)*((_QWORD *)&v27 + 1);
        if ( *((_QWORD *)&v27 + 1) )
        {
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v27 + 1) + 8LL), 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v13)(v13);
            if ( _InterlockedExchangeAdd(v13 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v13 + 8LL))(v13);
          }
        }
        return v12;
      }
      v15 = v31;
      v29 = 0LL;
      if ( *((_QWORD *)&v27 + 1) )
        _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v27 + 1) + 8LL));
      v29 = v27;
      v16 = sub_180006320(&v29, v15);
      if ( v16 )
      {
        sub_18001A3A0(v28);
        v17 = (volatile signed __int32 *)*((_QWORD *)&v27 + 1);
        if ( *((_QWORD *)&v27 + 1) )
        {
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v27 + 1) + 8LL), 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v17)(v17);
            if ( _InterlockedExchangeAdd(v17 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v17 + 8LL))(v17);
          }
        }
        return v16;
      }
      v18 = sub_180032310(v27, v24);
      v19 = sub_180031510(v5, v31, v18, v32);
      if ( v19 )
        goto LABEL_23;
      if ( (*(unsigned int (**)(void))gAIUserSuite)() )
      {
        v19 = 1398034256;
LABEL_23:
        sub_18001A3A0(v28);
        v20 = (volatile signed __int32 *)*((_QWORD *)&v27 + 1);
        if ( *((_QWORD *)&v27 + 1) )
        {
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v27 + 1) + 8LL), 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v20)(v20);
            if ( _InterlockedExchangeAdd(v20 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v20 + 8LL))(v20);
          }
        }
        return v19;
      }
      (*(void (__fastcall **)(_QWORD, _QWORD))(gAIUserSuite + 8))((unsigned int)++*v9, (unsigned int)v9[1]);
      sub_18001A3A0(v28);
      v22 = (volatile signed __int32 *)*((_QWORD *)&v27 + 1);
      if ( *((_QWORD *)&v27 + 1) )
      {
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v27 + 1) + 8LL), 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v22)(v22);
          if ( _InterlockedExchangeAdd(v22 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v22 + 8LL))(v22);
        }
      }
      v7 += 8LL;
      v5 = v33;
    }
    v21 = (volatile signed __int32 *)*((_QWORD *)&v27 + 1);
    if ( *((_QWORD *)&v27 + 1) )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v27 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v21)(v21);
        if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v21 + 8LL))(v21);
      }
    }
    result = 1128353364LL;
  }
  catch ( const ai::Error *v26 )
  {
    return *((unsigned int *)v26 + 6);
  }
  catch ( const std::exception *v30 )
  {
    return 1398031704LL;
  }
  catch ( int v23 )
  {
    return v23;
  }
  catch ( ... )
  {
    return 1431192920LL;
  }
  return result;
}


// ===== 函数: sub_18001D820 (0x18001D820) =====
__int64 __fastcall sub_18001D820(__int64 a1)
{
  _BYTE v3[24]; // [rsp+20h] [rbp-18h] BYREF
  __int64 v4; // [rsp+40h] [rbp+8h] BYREF

  v4 = sub_1800065C0();
  return *(_QWORD *)sub_18001C060(a1, v3, &v4) + 24LL;
}


// ===== 函数: sub_1800065C0 (0x1800065C0) =====
__int64 __fastcall sub_1800065C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v5; // [rsp+40h] [rbp+8h] BYREF
  char v6; // [rsp+48h] [rbp+10h] BYREF

  LOBYTE(a3) = 1;
  sub_18001A2C0(&v6, *(_QWORD *)(qword_180074190 + 8), a3);
  v5 = 0LL;
  (*(void (__fastcall **)(__int64 *))(gAIDocumentSuite + 160))(&v5);
  v3 = v5;
  sub_18001A320(&v6);
  return v3;
}


// ===== 函数: sub_18001A2C0 (0x18001A2C0) =====
_QWORD *__fastcall sub_18001A2C0(_QWORD *a1, __int64 a2, char a3)
{
  __int64 v4; // rax

  *a1 = 0LL;
  v4 = qword_180074348;
  if ( qword_180074348 )
  {
    if ( a3 != 1 )
    {
LABEL_5:
      (*(void (__fastcall **)(__int64, _QWORD *))(v4 + 8))(a2, a1);
      return a1;
    }
    if ( !(*(unsigned int (**)(void))(qword_180074348 + 96))() )
    {
      v4 = qword_180074348;
      goto LABEL_5;
    }
  }
  return a1;
}


// ===== 函数: sub_18001A320 (0x18001A320) =====
__int64 __fastcall sub_18001A320(__int64 *a1)
{
  __int64 result; // rax
  __int64 v3; // rcx

  result = qword_180074348;
  if ( qword_180074348 )
  {
    v3 = *a1;
    if ( v3 )
    {
      result = (*(__int64 (__fastcall **)(__int64))(qword_180074348 + 16))(v3);
      *a1 = 0LL;
    }
  }
  return result;
}


// ===== 函数: sub_18001C060 (0x18001C060) =====
__int64 __fastcall sub_18001C060(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // r13
  __int64 v7; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rbx
  _QWORD *v10; // r12
  _QWORD *v11; // r15
  _QWORD *v12; // rcx
  _QWORD *v14; // rdi
  float v15; // xmm3_4
  __int64 v16; // rcx
  float v17; // xmm0_4
  unsigned __int64 v18; // rsi
  float v19; // xmm2_4
  __int64 v20; // rcx
  float v21; // xmm0_4
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  _QWORD *v26; // rax
  _QWORD *v27; // rdx
  __int64 v28; // rcx
  _QWORD *v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // rax
  _QWORD *v32; // r8
  _QWORD *v33; // [rsp+30h] [rbp-38h]

  v6 = 0x100000001B3LL
     * (a3[7] ^ (0x100000001B3LL
               * (a3[6] ^ (0x100000001B3LL
                         * (a3[5] ^ (0x100000001B3LL
                                   * (a3[4] ^ (0x100000001B3LL
                                             * (a3[3] ^ (0x100000001B3LL
                                                       * (a3[2] ^ (0x100000001B3LL
                                                                 * (a3[1] ^ (0x100000001B3LL
                                                                           * (*a3 ^ 0xCBF29CE484222325uLL)))))))))))))));
  v7 = 2 * (v6 & *(_QWORD *)(a1 + 48));
  v8 = *(_QWORD *)(a1 + 24);
  v9 = *(_QWORD **)(v8 + 8 * v7 + 8);
  v10 = *(_QWORD **)(a1 + 8);
  if ( v9 == v10 )
  {
    v9 = *(_QWORD **)(a1 + 8);
    v11 = v9;
    goto LABEL_9;
  }
  v12 = *(_QWORD **)(v8 + 8 * v7);
  if ( *(_QWORD *)a3 != v9[2] )
  {
    while ( v9 != v12 )
    {
      v9 = (_QWORD *)v9[1];
      if ( *(_QWORD *)a3 == v9[2] )
        goto LABEL_6;
    }
    v10 = v9;
    v11 = v9;
LABEL_9:
    if ( *(_QWORD *)(a1 + 16) == 0x333333333333333LL )
      std::_Xlength_error("unordered_map/set too long");
    v14 = (_QWORD *)sub_180031D20((ai *)0x50, a1 + 8, (void **)a3);
    v14[2] = *(_QWORD *)a3;
    sub_18001FD60(v14 + 3);
    v15 = *(float *)a1;
    v16 = *(_QWORD *)(a1 + 16) + 1LL;
    if ( v16 < 0 )
      v17 = (float)(v16 & 1 | (unsigned int)((unsigned __int64)v16 >> 1))
          + (float)(v16 & 1 | (unsigned int)((unsigned __int64)v16 >> 1));
    else
      v17 = (float)(int)v16;
    v18 = *(_QWORD *)(a1 + 56);
    if ( (v18 & 0x8000000000000000uLL) != 0LL )
    {
      v20 = *(_QWORD *)(a1 + 56) & 1LL | (v18 >> 1);
      v19 = (float)(int)v20 + (float)(int)v20;
    }
    else
    {
      v19 = (float)(int)v18;
    }
    if ( (float)(v17 / v19) <= v15 )
    {
LABEL_33:
      v29 = (_QWORD *)v9[1];
      ++*(_QWORD *)(a1 + 16);
      *v14 = v10;
      v14[1] = v29;
      *v29 = v14;
      v9[1] = v14;
      v30 = *(_QWORD *)(a1 + 24);
      v31 = 2 * (v6 & *(_QWORD *)(a1 + 48));
      v32 = *(_QWORD **)(v30 + 16 * (v6 & *(_QWORD *)(a1 + 48)));
      if ( v32 == *(_QWORD **)(a1 + 8) )
      {
        *(_QWORD *)(v30 + 16 * (v6 & *(_QWORD *)(a1 + 48))) = v14;
LABEL_39:
        *(_QWORD *)(v30 + 8 * v31 + 8) = v14;
        goto LABEL_40;
      }
      if ( v32 == v11 )
      {
        *(_QWORD *)(v30 + 16 * (v6 & *(_QWORD *)(a1 + 48))) = v14;
      }
      else if ( *(_QWORD **)(v30 + 16 * (v6 & *(_QWORD *)(a1 + 48)) + 8) == v29 )
      {
        goto LABEL_39;
      }
LABEL_40:
      *(_QWORD *)a2 = v14;
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
    v21 = ceilf(v17 / v15);
    v22 = 0LL;
    if ( v21 >= 9.223372e18 )
    {
      v21 = v21 - 9.223372e18;
      if ( v21 < 9.223372e18 )
        v22 = 0x8000000000000000uLL;
    }
    v23 = v22 + (unsigned int)(int)v21;
    v24 = 8LL;
    if ( v23 > 8 )
      v24 = v23;
    if ( v18 < v24 )
    {
      if ( v18 >= 0x200 || (v18 *= 8LL, v18 < v24) )
        v18 = v24;
    }
    sub_18001DD90(a1, v18);
    v25 = *(_QWORD *)(a1 + 24);
    v26 = *(_QWORD **)(v25 + 16 * (v6 & *(_QWORD *)(a1 + 48)) + 8);
    v9 = *(_QWORD **)(a1 + 8);
    if ( v26 != v9 )
    {
      v27 = *(_QWORD **)(v25 + 16 * (v6 & *(_QWORD *)(a1 + 48)));
      v28 = v14[2];
      if ( v28 != v26[2] )
      {
        while ( 1 )
        {
          v9 = v26;
          if ( v26 == v27 )
            break;
          v26 = (_QWORD *)v26[1];
          if ( v28 == v26[2] )
            goto LABEL_30;
        }
        v33 = v26;
        goto LABEL_32;
      }
LABEL_30:
      v9 = (_QWORD *)*v26;
    }
    v33 = v9;
LABEL_32:
    v11 = v9;
    v10 = v33;
    goto LABEL_33;
  }
LABEL_6:
  *(_QWORD *)a2 = v9;
  *(_BYTE *)(a2 + 8) = 0;
  return a2;
}


// ===== 函数: sub_18001FD60 (0x18001FD60) =====
__int64 __fastcall sub_18001FD60(__int64 a1)
{
  *(_QWORD *)a1 = 0x3FF0000000000000LL;
  *(_QWORD *)(a1 + 8) = 0x3FF0000000000000LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_BYTE *)(a1 + 48) = 0;
  sub_180021C00(a1);
  return a1;
}


// ===== 函数: sub_18001DD90 (0x18001DD90) =====
_QWORD *__fastcall sub_18001DD90(_QWORD *a1, unsigned __int64 a2, void **a3)
{
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rax
  __int64 v6; // rdx
  _QWORD *v7; // rbx
  unsigned __int64 v8; // rcx
  __int64 v9; // r15
  __int64 v10; // rcx
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // rax
  _QWORD *v14; // rdi
  __int64 v15; // rcx
  _QWORD *v16; // rax
  _QWORD *result; // rax
  _QWORD *i; // rcx
  _QWORD *v19; // r11
  _QWORD *v20; // r9
  _QWORD *v21; // rdx
  __int64 v22; // r8
  _QWORD *v23; // r10
  _QWORD *v24; // r9
  _QWORD *v25; // r8
  _QWORD *v26; // rdx
  _QWORD *v27; // r10
  _QWORD *v28; // r9
  _QWORD *v29; // r8
  _QWORD *v30; // r10
  _QWORD *v31; // r9
  _QWORD *v32; // r8
  _QWORD *v33; // rdx
  _QWORD *v34; // [rsp+48h] [rbp+10h] BYREF

  _BitScanReverse64(&v4, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v4 )
    std::_Xlength_error("invalid hash bucket count");
  v5 = a2 - 1;
  v6 = a1[4];
  v7 = (_QWORD *)a1[1];
  _BitScanReverse64(&v8, v5 | 1);
  v9 = 1LL << ((unsigned __int8)v8 + 1);
  v10 = a1[3];
  v34 = v7;
  v11 = (v6 - v10) >> 3;
  if ( v11 >= 2 * v9 )
  {
    sub_180015AD0(v10, v6, &v34);
    goto LABEL_21;
  }
  if ( (unsigned __int64)(2 * v9) > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_35;
  v12 = 16 * v9;
  if ( (unsigned __int64)(16 * v9) < 0x1000 )
  {
    if ( v12 )
      v14 = (_QWORD *)sub_180031D20((ai *)v12, v6, a3);
    else
      v14 = 0LL;
    goto LABEL_11;
  }
  if ( v12 + 39 < v12 )
LABEL_35:
    Concurrency::cancel_current_task();
  v13 = sub_180031D20((ai *)(v12 + 39), v6, a3);
  if ( !v13 )
    goto LABEL_19;
  v14 = (_QWORD *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_11:
  if ( !v11 )
    goto LABEL_16;
  v15 = a1[3];
  if ( 8 * v11 >= 0x1000 )
  {
    if ( (unsigned __int64)(v15 - *(_QWORD *)(v15 - 8) - 8) <= 0x1F )
    {
      v15 = *(_QWORD *)(v15 - 8);
      goto LABEL_15;
    }
LABEL_19:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_15:
  sub_18001AE10(v15);
LABEL_16:
  v16 = &v14[v12 / 8];
  a1[3] = v14;
  a1[4] = &v14[v12 / 8];
  for ( a1[5] = &v14[v12 / 8]; v14 != v16; ++v14 )
    *v14 = v7;
LABEL_21:
  a1[7] = v9;
  a1[6] = v9 - 1;
  result = *(_QWORD **)a1[1];
  for ( i = result; i != v7; result = i )
  {
    i = (_QWORD *)*i;
    v19 = (_QWORD *)(a1[3]
                   + 16
                   * ((0x100000001B3LL
                     * (*((unsigned __int8 *)result + 23) ^ (0x100000001B3LL
                                                           * (*((unsigned __int8 *)result + 22) ^ (0x100000001B3LL
                                                                                                 * (*((unsigned __int8 *)result + 21) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 20) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 19) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 18) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 17) ^ (0x100000001B3LL * (*((unsigned __int8 *)result + 16) ^ 0xCBF29CE484222325uLL)))))))))))))))) & a1[6]));
    v20 = (_QWORD *)*v19;
    if ( (_QWORD *)*v19 == v7 )
    {
      *v19 = result;
      v19[1] = result;
    }
    else
    {
      v21 = (_QWORD *)v19[1];
      v22 = result[2];
      if ( v22 == v21[2] )
      {
        v23 = (_QWORD *)*v21;
        if ( (_QWORD *)*v21 != result )
        {
          v24 = (_QWORD *)result[1];
          *v24 = i;
          v25 = (_QWORD *)i[1];
          *v25 = v23;
          v26 = (_QWORD *)v23[1];
          *v26 = result;
          v23[1] = v25;
          i[1] = v24;
          result[1] = v26;
        }
        v19[1] = result;
      }
      else if ( v20 == v21 )
      {
LABEL_31:
        v27 = (_QWORD *)result[1];
        *v27 = i;
        v28 = (_QWORD *)i[1];
        *v28 = v21;
        v29 = (_QWORD *)v21[1];
        *v29 = result;
        v21[1] = v28;
        i[1] = v27;
        result[1] = v29;
        *v19 = result;
      }
      else
      {
        while ( 1 )
        {
          v21 = (_QWORD *)v21[1];
          if ( v22 == v21[2] )
            break;
          if ( v20 == v21 )
            goto LABEL_31;
        }
        v30 = (_QWORD *)*v21;
        v31 = (_QWORD *)result[1];
        *v31 = i;
        v32 = (_QWORD *)i[1];
        *v32 = v30;
        v33 = (_QWORD *)v30[1];
        *v33 = result;
        v30[1] = v32;
        i[1] = v31;
        result[1] = v33;
      }
    }
  }
  return result;
}


// ===== 函数: sub_18001AB80 (0x18001AB80) =====
__int64 __fastcall sub_18001AB80(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  __int64 (__fastcall *v5)(__int64, __int64, __int64); // rdi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rbx
  __int64 (__fastcall *v9)(__int64, __int64, __int64); // rdi
  __int64 v10; // rax

  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(gAIDictionarySuite + 136);
  v6 = sub_180008570(a1);
  result = v5(v6, v3, 1LL);
  if ( !(_DWORD)result )
  {
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(gAIDictionarySuite + 128);
    v10 = sub_180008570(a1);
    return v9(v10, v8, a2);
  }
  return result;
}


// ===== 函数: sub_180008570 (0x180008570) =====
__int64 __fastcall sub_180008570(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 16LL);
}


// ===== 函数: sub_18001A360 (0x18001A360) =====
__int64 __fastcall sub_18001A360(__int64 a1, __int64 a2)
{
  sub_180007340(a1, 2);
  *(_QWORD *)(a1 + 8) = a2;
  return a1;
}


// ===== 函数: sub_180007340 (0x180007340) =====
__int64 __fastcall sub_180007340(__int64 a1, int a2)
{
  int v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  sub_180007060(a1, &v4);
  return a1;
}


// ===== 函数: sub_180007060 (0x180007060) =====
unsigned __int64 *__fastcall sub_180007060(unsigned __int64 *a1, int *a2, void **a3)
{
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rbx
  int v7; // edx
  int v8; // edx
  __int64 v9; // rax
  __int64 (__fastcall *v10)(unsigned __int64); // rbp
  __int64 v11; // rax
  int v12; // eax
  __int64 v13; // rax
  __int64 (__fastcall *v14)(unsigned __int64); // rbp
  __int64 v15; // rax
  int v16; // eax
  __int64 v17; // rax
  __int64 (__fastcall *v18)(unsigned __int64); // rbp
  __int64 v19; // rax
  int v20; // eax
  _BYTE v22[40]; // [rsp+30h] [rbp-98h] BYREF
  _BYTE v23[40]; // [rsp+58h] [rbp-70h] BYREF
  _BYTE pExceptionObject[48]; // [rsp+80h] [rbp-48h] BYREF

  v5 = sub_180031D20((ai *)0x18, (__int64)a2, a3);
  v6 = v5;
  if ( v5 )
  {
    v7 = *a2;
    *(_DWORD *)v5 = 0;
    *(_QWORD *)(v5 + 8) = "AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illus"
                          "trator\\public\\api\\IAIDictionary.cpp line: 966 ";
    *(_QWORD *)(v5 + 16) = 0LL;
    if ( v7 )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        if ( v8 == 1 )
        {
          v9 = sub_180007F60(&unk_180073E95);
          v10 = *(__int64 (__fastcall **)(unsigned __int64))(sub_180007790(v9) + 320);
          if ( *(_QWORD *)(v6 + 16) )
          {
            v11 = sub_18001E230();
            (*(void (__fastcall **)(_QWORD))(v11 + 8))(*(_QWORD *)(v6 + 16));
          }
          *(_QWORD *)(v6 + 16) = 0LL;
          v12 = v10(v6 + 16);
          *(_DWORD *)v6 = v12;
          if ( v12 )
          {
            sub_180003F80((__int64)v22, v12, *(_QWORD *)(v6 + 8));
            throw (ai::Error *)v22;
          }
        }
      }
      else
      {
        v13 = sub_180007F60(&unk_180073E95);
        v14 = *(__int64 (__fastcall **)(unsigned __int64))(sub_180007790(v13) + 232);
        if ( *(_QWORD *)(v6 + 16) )
        {
          v15 = sub_18001E230();
          (*(void (__fastcall **)(_QWORD))(v15 + 8))(*(_QWORD *)(v6 + 16));
        }
        *(_QWORD *)(v6 + 16) = 0LL;
        v16 = v14(v6 + 16);
        *(_DWORD *)v6 = v16;
        if ( v16 )
        {
          sub_180003F80((__int64)v23, v16, *(_QWORD *)(v6 + 8));
          throw (ai::Error *)v23;
        }
      }
    }
    else
    {
      v17 = sub_180007E00(&unk_180073E97);
      v18 = *(__int64 (__fastcall **)(unsigned __int64))sub_180007790(v17);
      if ( *(_QWORD *)(v6 + 16) )
      {
        v19 = sub_18001E230();
        (*(void (__fastcall **)(_QWORD))(v19 + 8))(*(_QWORD *)(v6 + 16));
      }
      *(_QWORD *)(v6 + 16) = 0LL;
      v20 = v18(v6 + 16);
      *(_DWORD *)v6 = v20;
      if ( v20 )
      {
        sub_180003F80((__int64)pExceptionObject, v20, *(_QWORD *)(v6 + 8));
        throw (ai::Error *)pExceptionObject;
      }
    }
  }
  else
  {
    v6 = 0LL;
  }
  *a1 = v6;
  return a1;
}


// ===== 函数: sub_18001A3A0 (0x18001A3A0) =====
void __fastcall sub_18001A3A0(ai **a1)
{
  void (__fastcall *v1)(__int64); // rdi
  __int64 v2; // rax
  _QWORD *v3; // rdx
  _QWORD v4[5]; // [rsp+0h] [rbp-48h] BYREF
  const ai::Error *v5; // [rsp+28h] [rbp-20h] BYREF
  const std::exception *v6; // [rsp+30h] [rbp-18h] BYREF
  __int64 v7; // [rsp+38h] [rbp-10h] BYREF

  v4[4] = -2LL;
  v1 = *(void (__fastcall **)(__int64))(gAIDictionarySuite + 88);
  v2 = sub_180008570((__int64)a1);
  try
  {
    v1(v2);
  }
  catch ( const ai::Error *v5 )
  {
    v3 = v4;
  }
  catch ( const std::exception *v6 )
  {
    v3 = v4;
  }
  catch ( int v7 )
  {
    v3 = v4;
  }
  catch ( ... )
  {
    v3 = v4;
  }
  sub_180007420(a1, v3);
}


// ===== 函数: sub_180006320 (0x180006320) =====
__int64 __fastcall sub_180006320(__int64 *a1, __int64 a2)
{
  unsigned int v3; // esi
  volatile signed __int32 *v4; // rdi
  __int64 v6; // [rsp+28h] [rbp-20h] BYREF
  __int64 v7; // [rsp+30h] [rbp-18h]

  v6 = *a1;
  v7 = 0LL;
  v3 = (*(__int64 (__fastcall **)(__int64 (__fastcall *)(), __int64 *, _QWORD, __int64, __int64, __int64))(gAIDocumentListPrivateSuite + 112))(
         sub_1800061B0,
         &v6,
         0LL,
         a2,
         -2LL,
         v6);
  v4 = (volatile signed __int32 *)a1[1];
  if ( v7 )
  {
    if ( v4 )
    {
      if ( _InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v4)(v4);
        if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
      }
    }
    return v3;
  }
  else
  {
    if ( v4 && _InterlockedExchangeAdd(v4 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v4)(v4);
      if ( _InterlockedExchangeAdd(v4 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v4 + 8LL))(v4);
    }
    return 40406LL;
  }
}


// ===== 函数: sub_180021470 (0x180021470) =====
_QWORD *__fastcall sub_180021470(__int64 a1, _QWORD *a2, double a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rsi
  __int64 v7; // rax

  v3 = *(_QWORD **)(a1 + 24);
  v4 = *(_QWORD **)(a1 + 32);
  if ( v3 == v4 )
  {
LABEL_4:
    *a2 = 0LL;
    a2[1] = 0LL;
  }
  else
  {
    while ( sub_1800322F0(*v3) != a3 )
    {
      v3 += 2;
      if ( v3 == v4 )
        goto LABEL_4;
    }
    v7 = v3[1];
    *a2 = 0LL;
    a2[1] = 0LL;
    if ( v7 )
      _InterlockedIncrement((volatile signed __int32 *)(v7 + 8));
    *a2 = *v3;
    a2[1] = v3[1];
  }
  return a2;
}


// ===== 函数: sub_1800322F0 (0x1800322F0) =====
double __fastcall sub_1800322F0(__int64 a1)
{
  return *(double *)(a1 + 72);
}


// ===== 函数: sub_180032310 (0x180032310) =====
__int64 *__fastcall sub_180032310(__int64 a1, __int64 *a2)
{
  __int64 v3; // rdi
  __int64 v5; // [rsp+40h] [rbp+8h] BYREF
  __int64 *v6; // [rsp+48h] [rbp+10h]

  v6 = a2;
  v3 = a1 + 64;
  sub_180036480(&v5, a1 + 64);
  sub_180036480(a2, v3);
  if ( sub_180014540((__int64)&v5, a2, 0LL) )
    sub_180036B40((__int64)a2, v3);
  sub_180036A90(&v5);
  return a2;
}


// ===== 函数: sub_180014540 (0x180014540) =====
char __fastcall sub_180014540(__int64 a1, __int64 *a2, __int64 *a3)
{
  char v6; // r14
  unsigned int v7; // esi
  unsigned __int64 v8; // rax
  size_t v9; // rbx
  __int64 *v10; // rax
  __int64 v11; // rcx
  __int16 *v12; // rbx
  __int64 v13; // rax
  __int64 *v14; // rax
  __int64 v15; // rcx
  void **p_Src; // rcx
  __int64 *v17; // rax
  __int64 v18; // rcx
  __int64 *v19; // rax
  __int64 v20; // rcx
  __int64 *v21; // rax
  __int64 v22; // rcx
  const char *v23; // rdx
  __int64 *v24; // rax
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 *v27; // rax
  __int64 v28; // rcx
  __int64 v29; // rcx
  void *v30; // [rsp+20h] [rbp-E0h] BYREF
  void *Src; // [rsp+28h] [rbp-D8h] BYREF
  _QWORD v32[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v33; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v34; // [rsp+48h] [rbp-B8h] BYREF
  int v35; // [rsp+50h] [rbp-B0h]
  int v36; // [rsp+54h] [rbp-ACh]
  __m128i si128; // [rsp+58h] [rbp-A8h]
  __int16 v38; // [rsp+70h] [rbp-90h] BYREF
  __int16 v39; // [rsp+72h] [rbp-8Eh]
  __int16 v40; // [rsp+74h] [rbp-8Ch]
  __int16 v41; // [rsp+76h] [rbp-8Ah]
  __int16 v42; // [rsp+78h] [rbp-88h]
  __int16 v43; // [rsp+7Ah] [rbp-86h]
  __int16 v44; // [rsp+7Ch] [rbp-84h]
  __int16 v45; // [rsp+7Eh] [rbp-82h]
  __int16 v46; // [rsp+80h] [rbp-80h]
  __int16 v47; // [rsp+26Ch] [rbp+16Ch]

  v32[1] = -2LL;
  if ( !a1 )
    return 0;
  v6 = 1;
  v33 = 0x101010101000101LL;
  v34 = 0x1010101000101LL;
  v35 = 16843009;
  v36 = 16843009;
  si128.m128i_i64[0] = 0x10001000101LL;
  v7 = 0;
  Src = 0LL;
  v8 = sub_1800377C0(a1, &Src) + 1;
  if ( v8 > 0xFF )
    v8 = 255LL;
  v9 = 2 * (v8 - 1);
  memcpy(&v38, Src, v9);
  *(__int16 *)((char *)&v38 + v9) = 0;
  if ( v38 == 46 )
  {
    v6 = 0;
    v38 = 45;
    if ( a3 )
    {
      v10 = sub_1800367E0(&Src, (__int64)"$$$/IsValidFileName/Win/ErrorString1=Filename can not start with '.'");
      v11 = *a3;
      *a3 = *v10;
      *v10 = v11;
      sub_180036A90(&Src);
    }
  }
  v12 = &v38;
  do
  {
    v13 = (unsigned __int16)*v12;
    if ( !(_WORD)v13 )
      break;
    if ( (unsigned int)v13 >= 0x20 )
    {
      if ( (unsigned int)v13 >= 0x40 )
      {
        if ( (((_WORD)v13 - 92) & 0xFFDF) != 0 )
          goto LABEL_21;
        v6 = 0;
        *v12 = 45;
        if ( !a3 )
          goto LABEL_21;
        v19 = sub_1800367E0(&v30, (__int64)"$$$/IsValidFileName/Win/ErrorString4=Filename can not contain '\\' or '|'");
        v20 = *a3;
        *a3 = *v19;
        *v19 = v20;
        p_Src = &v30;
      }
      else
      {
        if ( *((_BYTE *)&v30 + v13) )
          goto LABEL_21;
        v6 = 0;
        *v12 = 45;
        if ( !a3 )
          goto LABEL_21;
        v17 = sub_1800367E0(
                v32,
                (__int64)"$$$/IsValidFileName/Win/ErrorString3=Filename can not contain any of these symbols: */:<>?");
        v18 = *a3;
        *a3 = *v17;
        *v17 = v18;
        p_Src = (void **)v32;
      }
      goto LABEL_20;
    }
    v6 = 0;
    *v12 = 45;
    if ( a3 )
    {
      v14 = sub_1800367E0(
              &Src,
              (__int64)"$$$/IsValidFileName/Win/ErrorString2=Filename can not contain symbol with ASCII code lesser than 32");
      v15 = *a3;
      *a3 = *v14;
      *v14 = v15;
      p_Src = &Src;
LABEL_20:
      sub_180036A90(p_Src);
    }
LABEL_21:
    ++v7;
    ++v12;
  }
  while ( v7 < 0xFF );
  if ( v7 >= 0xFF )
  {
    v6 = 0;
    v47 = 0;
    if ( a3 )
    {
      v21 = sub_1800367E0(
              &v30,
              (__int64)"$$$/IsValidFileName/Win/ErrorString5=Filename can not be longer than 255 characters");
      v22 = *a3;
      *a3 = *v21;
      *v21 = v22;
      sub_180036A90(&v30);
    }
  }
  if ( v7 != 3 )
  {
    if ( v7 == 4 )
    {
      if ( ((v38 - 67) & 0xFFDF) != 0 || ((v39 - 79) & 0xFFDF) != 0 || ((v40 - 77) & 0xFFDF) != 0 )
      {
        if ( ((v38 - 76) & 0xFFDF) != 0 )
          goto LABEL_53;
        if ( ((v39 - 80) & 0xFFDF) != 0 )
          goto LABEL_53;
        if ( ((v40 - 84) & 0xFFDF) != 0 )
          goto LABEL_53;
        v6 = 0;
        v43 = 45;
        v44 = 0;
        if ( !a3 )
          goto LABEL_53;
        v23 = "$$$/IsValidFileName/Win/ErrorString11=Filename can not be equal to any of the reserved device names from LPT1 to LPT9";
      }
      else
      {
        v6 = 0;
        v43 = 45;
        v44 = 0;
        if ( !a3 )
          goto LABEL_53;
        v23 = "$$$/IsValidFileName/Win/ErrorString10=Filename can not be equal to any of the reserved device names from COM1 to COM9";
      }
    }
    else
    {
      if ( v7 != 6 )
        goto LABEL_53;
      if ( ((v38 - 67) & 0xFFDF) != 0 )
        goto LABEL_53;
      if ( ((v39 - 76) & 0xFFDF) != 0 )
        goto LABEL_53;
      if ( ((v40 - 79) & 0xFFDF) != 0 )
        goto LABEL_53;
      if ( ((v41 - 67) & 0xFFDF) != 0 )
        goto LABEL_53;
      if ( ((v42 - 75) & 0xFFDF) != 0 )
        goto LABEL_53;
      if ( v43 != 36 )
        goto LABEL_53;
      v6 = 0;
      v45 = 45;
      v46 = 0;
      if ( !a3 )
        goto LABEL_53;
      v23 = "$$$/IsValidFileName/Win/ErrorString12=Filename can not be equal to reserved device name CLOCK$";
    }
LABEL_52:
    v24 = sub_1800367E0(&v30, (__int64)v23);
    v25 = *a3;
    *a3 = *v24;
    *v24 = v25;
    sub_180036A90(&v30);
    goto LABEL_53;
  }
  if ( ((v38 - 65) & 0xFFDF) != 0 || ((v39 - 85) & 0xFFDF) != 0 || ((v40 - 88) & 0xFFDF) != 0 )
  {
    if ( ((v38 - 67) & 0xFFDF) != 0 || ((v39 - 79) & 0xFFDF) != 0 || ((v40 - 78) & 0xFFDF) != 0 )
    {
      if ( ((v38 - 78) & 0xFFDF) != 0 || ((v39 - 85) & 0xFFDF) != 0 || ((v40 - 76) & 0xFFDF) != 0 )
      {
        if ( ((v38 - 80) & 0xFFDF) != 0 )
          goto LABEL_53;
        if ( ((v39 - 82) & 0xFFDF) != 0 )
          goto LABEL_53;
        if ( ((v40 - 78) & 0xFFDF) != 0 )
          goto LABEL_53;
        v6 = 0;
        v42 = 45;
        v43 = 0;
        if ( !a3 )
          goto LABEL_53;
        v23 = "$$$/IsValidFileName/Win/ErrorString9=Filename can not be equal to reserved device name PRN";
      }
      else
      {
        v6 = 0;
        v42 = 45;
        v43 = 0;
        if ( !a3 )
          goto LABEL_53;
        v23 = "$$$/IsValidFileName/Win/ErrorString8=Filename can not be equal to reserved device name NUL";
      }
    }
    else
    {
      v6 = 0;
      v42 = 45;
      v43 = 0;
      if ( !a3 )
        goto LABEL_53;
      v23 = "$$$/IsValidFileName/Win/ErrorString7=Filename can not be equal to reserved device name CON";
    }
    goto LABEL_52;
  }
  v6 = 0;
  v42 = 45;
  v43 = 0;
  if ( a3 )
  {
    v23 = "$$$/IsValidFileName/Win/ErrorString6=Filename can not be equal to reserved device name AUX";
    goto LABEL_52;
  }
LABEL_53:
  if ( a2 )
  {
    v33 = (__int64)&ai::WCHARStr::`vftable';
    v34 = 0LL;
    si128 = _mm_load_si128((const __m128i *)&xmmword_180056820);
    v26 = -1LL;
    do
      ++v26;
    while ( *(&v38 + v26) );
    sub_1800152C0(&v34, &v38);
    v27 = (__int64 *)sub_180036580(&v30, &v33);
    v28 = *a2;
    *a2 = *v27;
    *v27 = v28;
    sub_180036A90(&v30);
    v33 = (__int64)&ai::WCHARStr::`vftable';
    if ( si128.m128i_i64[1] >= 8uLL )
    {
      v29 = v34;
      if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
      {
        v29 = *(_QWORD *)(v34 - 8);
        if ( (unsigned __int64)(v34 - v29 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18001AE10(v29);
    }
  }
  return v6;
}


// ===== 函数: sub_1800377C0 (0x1800377C0) =====
__int64 __fastcall sub_1800377C0(__int64 a1, __int64 a2)
{
  __int128 *v4; // rax
  __int64 v5; // rax

  v4 = sub_180036EE0();
  v5 = sub_180007790((__int64)v4);
  return (*(__int64 (__fastcall **)(__int64, __int64))(v5 + 288))(a1, a2);
}


// ===== 函数: sub_1800152C0 (0x1800152C0) =====
__int64 *__fastcall sub_1800152C0(__int64 *a1, void *Src, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  char *v7; // rbp
  __int64 v8; // rbx
  __int64 v9; // rbx
  unsigned __int64 v10; // rdx
  _WORD *v11; // rax
  _WORD *v12; // rbp
  __int64 v13; // rcx

  v3 = a1[3];
  if ( a3 > v3 )
  {
    v9 = 0x7FFFFFFFFFFFFFFELL;
    if ( a3 > 0x7FFFFFFFFFFFFFFELL )
      std::vector<void *>::_Xlen();
    if ( (a3 | 7) <= 0x7FFFFFFFFFFFFFFELL )
    {
      v10 = v3 >> 1;
      if ( v3 <= 0x7FFFFFFFFFFFFFFELL - (v3 >> 1) )
      {
        v9 = a3 | 7;
        if ( (a3 | 7) < v10 + v3 )
          v9 = v10 + v3;
      }
    }
    v11 = (_WORD *)sub_180015250(a1, v9 + 1);
    a1[3] = v9;
    a1[2] = a3;
    v12 = v11;
    memcpy(v11, Src, 2 * a3);
    v12[a3] = 0;
    if ( v3 >= 8 )
    {
      v13 = *a1;
      if ( 2 * v3 + 2 >= 0x1000 )
      {
        if ( (unsigned __int64)(v13 - *(_QWORD *)(v13 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v13 = *(_QWORD *)(v13 - 8);
      }
      sub_18001AE10(v13);
    }
    *a1 = (__int64)v12;
  }
  else
  {
    v7 = (char *)a1;
    if ( v3 >= 8 )
      v7 = (char *)*a1;
    v8 = 2 * a3;
    a1[2] = a3;
    memmove(v7, Src, 2 * a3);
    *(_WORD *)&v7[v8] = 0;
  }
  return a1;
}


// ===== 函数: sub_180036580 (0x180036580) =====
__int64 *__fastcall sub_180036580(__int64 *a1, __int64 a2)
{
  _QWORD *v3; // rbx
  __int64 v4; // rax
  __int128 *v5; // rax
  __int64 v6; // rax
  int v7; // eax
  __int64 v8; // rcx
  __int128 *v9; // rax
  __int128 *v10; // rbx
  _QWORD *v11; // rax
  __int128 *v12; // rax
  __int64 v13; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  __int64 v16; // [rsp+60h] [rbp+8h] BYREF

  *a1 = 0LL;
  v3 = (_QWORD *)(a2 + 8);
  if ( *(_QWORD *)(a2 + 32) >= 8uLL )
    v3 = (_QWORD *)*v3;
  v4 = 0LL;
  v16 = 0LL;
  if ( v3 )
  {
    v5 = sub_180036EE0();
    v6 = sub_180007790((__int64)v5);
    v7 = (*(__int64 (__fastcall **)(__int64 *, _QWORD *, __int64))(v6 + 8))(&v16, v3, -1LL);
    if ( v7 )
    {
      sub_180003F80((__int64)pExceptionObject, v7, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    v4 = v16;
  }
  v8 = *a1;
  *a1 = v4;
  v16 = v8;
  if ( v8 )
  {
    v9 = sub_180036EE0();
    v10 = v9;
    if ( !*((_QWORD *)v9 + 1) && qword_1800740D8 )
    {
      if ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
             *((_QWORD *)v9 + 2),
             *((unsigned int *)v9 + 6),
             (__int64)v9 + 8) )
      {
        *((_QWORD *)v10 + 1) = 0LL;
      }
      else if ( !*((_BYTE *)v10 + 28) )
      {
        v11 = sub_180012E90();
        *(_QWORD *)v10 = *v11;
        *v11 = v10;
      }
    }
    if ( *((_QWORD *)v10 + 1) )
    {
      v12 = sub_180036EE0();
      v13 = sub_180007790((__int64)v12);
      (*(void (__fastcall **)(__int64 *))(v13 + 24))(&v16);
    }
  }
  return a1;
}


// ===== 函数: __report_rangecheckfailure (0x18004C348) =====
void __noreturn _report_rangecheckfailure()
{
  _report_securityfailure(8LL);
}


// ===== 函数: sub_180031510 (0x180031510) =====
__int64 __fastcall sub_180031510(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 *a4)
{
  __int64 v6; // r14
  __int64 v7; // r12
  __int64 v8; // rdi
  __int64 v9; // r13
  __int64 i; // rbx
  int v11; // esi
  __int64 v12; // xmm1_8
  __int64 v13; // rax
  __int64 v14; // rax
  __int128 *v15; // rax
  __int64 v16; // rax
  int v17; // eax
  __int64 v18; // r13
  __int64 *v19; // rdx
  _QWORD *v20; // rdx
  __int64 v21; // rcx
  __int128 v22; // rdi
  __int64 v23; // rax
  _QWORD *v24; // r12
  _QWORD *v25; // rbx
  __int64 v26; // rax
  __int64 v28; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v29; // [rsp+38h] [rbp-C8h] BYREF
  _QWORD *v30; // [rsp+40h] [rbp-C0h]
  __int128 v31; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v32; // [rsp+58h] [rbp-A8h]
  int v33; // [rsp+60h] [rbp-A0h] BYREF
  unsigned int v34; // [rsp+64h] [rbp-9Ch]
  __int64 v35; // [rsp+68h] [rbp-98h]
  _QWORD *v36; // [rsp+70h] [rbp-90h]
  _DWORD *v37; // [rsp+78h] [rbp-88h]
  int v38; // [rsp+80h] [rbp-80h]
  _BYTE pExceptionObject[40]; // [rsp+88h] [rbp-78h] BYREF
  __int64 v40; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v41; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v42; // [rsp+C0h] [rbp-40h] BYREF
  char v43; // [rsp+C8h] [rbp-38h]
  _DWORD v44[3]; // [rsp+CCh] [rbp-34h] BYREF
  __int64 v45; // [rsp+D8h] [rbp-28h]
  char v46; // [rsp+E0h] [rbp-20h]
  _OWORD v47[2]; // [rsp+E8h] [rbp-18h] BYREF
  _OWORD v48[2]; // [rsp+110h] [rbp+10h] BYREF

  v35 = -2LL;
  v30 = a3;
  v29 = a2;
  v36 = a3;
  v48[0] = xmmword_180059708;
  v48[1] = xmmword_180059718;
  v6 = 0LL;
  v34 = sub_180039A20(a2, (int)v48, 1, 0LL, 0LL, 80);
  if ( v34 )
  {
    v24 = v30;
  }
  else
  {
    v31 = 0LL;
    v7 = 0LL;
    v32 = 0LL;
    v8 = *a4;
    v9 = a4[1];
    for ( i = 0LL; v8 != v9; v8 += 40LL )
    {
      sub_180030600(&v40, v8, v48);
      v37 = v44;
      v11 = v44[0];
      v38 = v44[0];
      sub_180006E90((__int64)&v40);
      sub_180006AB0((__int64)&v40);
      sub_1800053C0((__int64)&v40, (double *)v47, (__int64)&v40);
      v12 = v40;
      v40 = v45;
      v45 = v12;
      if ( v46 )
        (*(void (__fastcall **)(_OWORD *))(gAIRasterizeSuite + 56))(v47);
      v44[0] = v11;
      v13 = sub_180006B10(&unk_1800744E2);
      v14 = sub_180007790(v13);
      (*(void (__fastcall **)(_OWORD *, _OWORD *))(v14 + 72))(v47, v47);
      if ( i == v7 )
      {
        sub_18002F5E0(&v31, i, &v40);
        v7 = v32;
        i = *((_QWORD *)&v31 + 1);
      }
      else
      {
        v28 = i;
        *(_QWORD *)i = v40;
        sub_180036480((_QWORD *)(i + 8), (__int64)&v41);
        sub_180036480((_QWORD *)(i + 16), (__int64)&v42);
        *(_BYTE *)(i + 24) = v43;
        *(_DWORD *)(i + 28) = v44[0];
        *(_DWORD *)(i + 32) = v44[1];
        *(_DWORD *)(i + 36) = v44[2];
        *(_QWORD *)(i + 40) = v45;
        *(_BYTE *)(i + 48) = v46;
        *(_OWORD *)(i + 56) = v47[0];
        *(_OWORD *)(i + 72) = v47[1];
        i += 88LL;
        *((_QWORD *)&v31 + 1) = i;
      }
      sub_180036A90(&v42);
      sub_180036A90(&v41);
    }
    v33 = 2;
    v28 = 0LL;
    v15 = sub_180006BC0();
    v16 = sub_180007790((__int64)v15);
    v17 = (*(__int64 (__fastcall **)(__int64, int *, __int64 *))(v16 + 8))(v29, &v33, &v28);
    if ( v17 )
    {
      sub_180003F80(
        (__int64)pExceptionObject,
        v17,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\IAIMTRasterizer.hpp line: 42 ");
      throw (ai::Error *)pExceptionObject;
    }
    v18 = v28;
    v19 = (__int64 *)a1[4];
    if ( v19 == (__int64 *)a1[5] )
    {
      sub_18002F8A0(a1 + 3, v19, &v28);
    }
    else
    {
      *v19 = 0LL;
      *v19 = v28;
      v28 = 0LL;
      a1[4] += 8LL;
    }
    sub_18000C810(&v28);
    v29 = v18;
    v20 = (_QWORD *)a1[1];
    if ( v20 == (_QWORD *)a1[2] )
    {
      v24 = v30;
      sub_18002FB00((_DWORD)a1, (_DWORD)v20, (_DWORD)v30, (unsigned int)&v31, (__int64)&v29);
      v6 = v32;
      v22 = v31;
    }
    else
    {
      v21 = v31;
      v22 = 0uLL;
      v23 = *v30;
      *v30 = 0LL;
      *v20 = v23;
      v29 = 0LL;
      v20[1] = v21;
      v20[2] = i;
      v20[3] = v7;
      v20[4] = v18;
      sub_180036A90(&v29);
      a1[1] += 40LL;
      v24 = v30;
    }
    if ( (_QWORD)v22 )
    {
      if ( (_QWORD)v22 != *((_QWORD *)&v22 + 1) )
      {
        v25 = (_QWORD *)(v22 + 8);
        do
        {
          sub_180036A90(v25 + 1);
          sub_180036A90(v25);
          v25 += 11;
        }
        while ( v25 - 1 != *((_QWORD **)&v22 + 1) );
      }
      v26 = v22;
      if ( (unsigned __int64)(88 * ((v6 - (__int64)v22) / 88)) >= 0x1000 )
      {
        *(_QWORD *)&v22 = *(_QWORD *)(v22 - 8);
        if ( (unsigned __int64)(v26 - v22 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18001AE10(v22);
    }
  }
  sub_180036A90(v24);
  return v34;
}


// ===== 函数: sub_180039A20 (0x180039A20) =====
__int64 __fastcall sub_180039A20(
        __int64 a1,
        int a2,
        int a3,
        __int64 (__fastcall *a4)(__int64, __int64, _QWORD),
        __int64 a5,
        int a6)
{
  __int64 v10; // rax
  __int64 v11; // rax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // edx
  __int64 v16; // rax
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  __int64 v20; // rax
  int v21; // eax
  __int64 v22; // rax
  __int64 (__fastcall **v23)(__int64, int *); // rax
  int v24; // eax
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  int v28; // eax
  __int64 v29; // rax
  __int64 v30; // rax
  int v31; // eax
  __int64 v32; // rax
  __int64 v33; // rax
  int v34; // eax
  __int64 v35; // rax
  __int64 v36; // rax
  int v37; // eax
  __int64 v38; // rax
  __int64 v39; // rax
  int v40; // eax
  __int64 v41; // rax
  __int64 v42; // rax
  int v43; // eax
  int v44; // eax
  __int64 v45; // rax
  __int64 v46; // rax
  int v47; // eax
  __int64 v48; // rax
  __int64 (__fastcall **v49)(__int64, __int64 *); // rax
  int v50; // eax
  unsigned __int16 v52; // [rsp+30h] [rbp-2C8h] BYREF
  __int64 v53; // [rsp+38h] [rbp-2C0h] BYREF
  int v54; // [rsp+40h] [rbp-2B8h] BYREF
  __int64 v55; // [rsp+48h] [rbp-2B0h] BYREF
  int v56; // [rsp+50h] [rbp-2A8h] BYREF
  __int64 v57; // [rsp+58h] [rbp-2A0h] BYREF
  __int64 v58; // [rsp+60h] [rbp-298h] BYREF
  unsigned int v59; // [rsp+68h] [rbp-290h] BYREF
  __int64 v60; // [rsp+70h] [rbp-288h]
  const ai::Error *v61; // [rsp+78h] [rbp-280h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+80h] [rbp-278h] BYREF
  _BYTE v63[40]; // [rsp+A8h] [rbp-250h] BYREF
  _BYTE v64[40]; // [rsp+D0h] [rbp-228h] BYREF
  _BYTE v65[40]; // [rsp+F8h] [rbp-200h] BYREF
  _BYTE v66[40]; // [rsp+120h] [rbp-1D8h] BYREF
  _BYTE v67[40]; // [rsp+148h] [rbp-1B0h] BYREF
  _BYTE v68[40]; // [rsp+170h] [rbp-188h] BYREF
  _BYTE v69[40]; // [rsp+198h] [rbp-160h] BYREF
  _BYTE v70[40]; // [rsp+1C0h] [rbp-138h] BYREF
  _BYTE v71[40]; // [rsp+1E8h] [rbp-110h] BYREF
  _BYTE v72[40]; // [rsp+210h] [rbp-E8h] BYREF
  _BYTE v73[40]; // [rsp+238h] [rbp-C0h] BYREF
  _BYTE v74[40]; // [rsp+260h] [rbp-98h] BYREF
  _BYTE v75[40]; // [rsp+288h] [rbp-70h] BYREF
  _BYTE v76[40]; // [rsp+2B0h] [rbp-48h] BYREF
  const std::exception *v77; // [rsp+2D8h] [rbp-20h] BYREF

  v60 = -2LL;
  v52 = 0;
  v58 = 0LL;
  try
  {
    while ( 1 )
    {
      if ( !a1 )
        return 0LL;
      v10 = sub_180007D50(&unk_1800748C6);
      v11 = sub_180007790(v10);
      v12 = (*(__int64 (__fastcall **)(__int64, unsigned __int16 *))(v11 + 48))(a1, &v52);
      if ( v12 )
      {
        sub_180003F80(
          (__int64)pExceptionObject,
          v12,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 194 ");
        throw (ai::Error *)pExceptionObject;
      }
      if ( a4 )
      {
        v13 = a4(a1, a5, v52);
        if ( v13 )
        {
          sub_180003F80(
            (__int64)v63,
            v13,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v63;
        }
      }
      else
      {
        v14 = sub_18003A6A0(a1, a2, v52, a3, a6);
        if ( v14 )
        {
          sub_180003F80(
            (__int64)v64,
            v14,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v64;
        }
      }
      if ( (a3 & 1) != 0 && v52 <= 0xDu )
      {
        v15 = 9226;
        if ( _bittest(&v15, (__int16)v52) )
          break;
      }
LABEL_36:
      v48 = sub_18002D630(&unk_1800748C2);
      v49 = (__int64 (__fastcall **)(__int64, __int64 *))sub_180007790(v48);
      v50 = (*v49)(a1, &v58);
      if ( v50 )
      {
        sub_180003F80(
          (__int64)v76,
          v50,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 194 ");
        throw (ai::Error *)v76;
      }
      if ( v58 == a1 )
        return 0LL;
      a1 = v58;
    }
    v53 = 0LL;
    switch ( v52 )
    {
      case 0xAu:
        v16 = sub_18002D9A0(&unk_1800748BC);
        v17 = sub_180007790(v16);
        v18 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v17 + 136))(a1, &v53);
        if ( v18 )
        {
          sub_180003F80(
            (__int64)v65,
            v18,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v65;
        }
        break;
      case 1u:
        v19 = sub_180007D50(&unk_1800748C6);
        v20 = sub_180007790(v19);
        v21 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v20 + 80))(a1, &v53);
        if ( v21 )
        {
          sub_180003F80(
            (__int64)v66,
            v21,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v66;
        }
        v54 = 0;
        v22 = sub_18002D6E0(&unk_1800748C0);
        v23 = (__int64 (__fastcall **)(__int64, int *))sub_180007790(v22);
        v24 = (*v23)(a1, &v54);
        if ( v24 )
        {
          sub_180003F80(
            (__int64)v67,
            v24,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v67;
        }
        if ( v54 )
        {
          v54 = sub_18003DEA0(a1);
          if ( v54 )
          {
            v25 = 0LL;
            v53 = 0LL;
            goto LABEL_30;
          }
        }
        break;
      case 0xDu:
        v55 = 0LL;
        v26 = sub_1800398C0(&unk_1800748BD);
        v27 = sub_180007790(v26);
        v28 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v27 + 184))(a1, &v55);
        if ( v28 )
        {
          sub_180003F80(
            (__int64)v68,
            v28,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v68;
        }
        v56 = 2;
        v29 = sub_180039760(&unk_1800748C3);
        v30 = sub_180007790(v29);
        v31 = (*(__int64 (__fastcall **)(__int64, int *))(v30 + 16))(v55, &v56);
        if ( v31 )
        {
          sub_180003F80(
            (__int64)v69,
            v31,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v69;
        }
        if ( v56 == 2 )
        {
          v32 = sub_180039970(&unk_1800748C1);
          v33 = sub_180007790(v32);
          v34 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v33 + 112))(a1, &v53);
          if ( v34 )
          {
            sub_180003F80(
              (__int64)v70,
              v34,
              (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustra"
                       "tor\\private\\api\\AIS4WUtils.cpp line: 194 ");
            throw (ai::Error *)v70;
          }
        }
        else
        {
          v35 = sub_180007D50(&unk_1800748C6);
          v36 = sub_180007790(v35);
          v37 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v36 + 80))(a1, &v53);
          if ( v37 )
          {
            sub_180003F80(
              (__int64)v71,
              v37,
              (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustra"
                       "tor\\private\\api\\AIS4WUtils.cpp line: 194 ");
            throw (ai::Error *)v71;
          }
        }
        break;
      default:
        v38 = sub_180007D50(&unk_1800748C6);
        v39 = sub_180007790(v38);
        v40 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v39 + 80))(a1, &v53);
        if ( v40 )
        {
          sub_180003F80(
            (__int64)v72,
            v40,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v72;
        }
        break;
    }
    v25 = v53;
LABEL_30:
    while ( v25 )
    {
      v57 = 0LL;
      LODWORD(v55) = 0;
      v41 = sub_180007D50(&unk_1800748C6);
      v42 = sub_180007790(v41);
      v43 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(v42 + 56))(v53, 4LL, &v55);
      if ( v43 )
      {
        sub_180003F80(
          (__int64)v73,
          v43,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 194 ");
        throw (ai::Error *)v73;
      }
      if ( (_DWORD)v55 != 4 )
      {
        v44 = sub_180039A20(v53, a2, a3, (_DWORD)a4, a5, a6);
        if ( v44 )
        {
          sub_180003F80(
            (__int64)v74,
            v44,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 194 ");
          throw (ai::Error *)v74;
        }
      }
      v45 = sub_180007D50(&unk_1800748C6);
      v46 = sub_180007790(v45);
      v47 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v46 + 88))(v53, &v57);
      if ( v47 )
      {
        sub_180003F80(
          (__int64)v75,
          v47,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 194 ");
        throw (ai::Error *)v75;
      }
      v25 = v57;
      v53 = v57;
    }
    goto LABEL_36;
  }
  catch ( const ai::Error *v61 )
  {
    return *((unsigned int *)v61 + 6);
  }
  catch ( const std::exception *v77 )
  {
    return 1398031704LL;
  }
  catch ( int v59 )
  {
    return v59;
  }
  catch ( ... )
  {
    return 1431192920LL;
  }
  return 0LL;
}


// ===== 函数: sub_18002D6E0 (0x18002D6E0) =====
__int128 *sub_18002D6E0()
{
  _QWORD *v1; // rax

  if ( dword_180074450 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180074430;
  Init_thread_header(&dword_180074450);
  if ( dword_180074450 != -1 )
    return &xmmword_180074430;
  xmmword_180074430 = 0LL;
  qword_180074440 = (__int64)"AI Group Suite";
  dword_180074448 = 5;
  byte_18007444C = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180074430 = *v1;
  *v1 = &xmmword_180074430;
  Init_thread_footer(&dword_180074450);
  return &xmmword_180074430;
}


// ===== 函数: sub_18003A6A0 (0x18003A6A0) =====
__int64 __fastcall sub_18003A6A0(__int64 a1, __int128 *a2, __int16 a3, char a4, unsigned int a5)
{
  unsigned int v6; // ebx
  __int128 *v10; // rax
  __int64 v11; // rax
  int v12; // eax
  __int128 *v13; // rax
  __int64 v14; // rax
  int v15; // eax
  __int64 v16; // rax
  __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rax
  __int64 v20; // rax
  int v21; // eax
  BOOL v22; // edx
  int v23; // ecx
  __int128 *v24; // rax
  __int64 (__fastcall **v25)(__int64, int *); // rax
  int v26; // eax
  int v27; // r8d
  __int128 *v28; // rax
  __int64 v29; // rax
  int v30; // eax
  int v31; // eax
  __int128 *v32; // rax
  __int64 v33; // rax
  int v34; // eax
  __int64 v35; // rax
  __int64 v36; // rax
  int v37; // eax
  __int128 *v38; // rax
  __int64 v39; // rax
  int v40; // eax
  __int64 v41; // rax
  __int64 v42; // rax
  __int64 v43; // rax
  __int64 v44; // rax
  __int64 v45; // [rsp+20h] [rbp-208h] BYREF
  int v46; // [rsp+28h] [rbp-200h] BYREF
  _QWORD v47[4]; // [rsp+30h] [rbp-1F8h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+50h] [rbp-1D8h] BYREF
  _BYTE v49[40]; // [rsp+78h] [rbp-1B0h] BYREF
  _BYTE v50[40]; // [rsp+A0h] [rbp-188h] BYREF
  _BYTE v51[40]; // [rsp+C8h] [rbp-160h] BYREF
  _BYTE v52[40]; // [rsp+F0h] [rbp-138h] BYREF
  _BYTE v53[40]; // [rsp+118h] [rbp-110h] BYREF
  _BYTE v54[40]; // [rsp+140h] [rbp-E8h] BYREF
  _BYTE v55[40]; // [rsp+168h] [rbp-C0h] BYREF
  _BYTE v56[40]; // [rsp+190h] [rbp-98h] BYREF
  _BYTE v57[40]; // [rsp+1B8h] [rbp-70h] BYREF
  __int128 v58; // [rsp+1E0h] [rbp-48h] BYREF
  __int128 v59; // [rsp+1F0h] [rbp-38h]

  v47[2] = -2LL;
  v6 = a3;
  if ( !a2 )
    return 1346458189LL;
  v58 = xmmword_18005AA20;
  v59 = xmmword_18005AA30;
  if ( a3 == 2 )
  {
    v10 = sub_18002D840();
    v11 = sub_180007790((__int64)v10);
    v12 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v11 + 64))(a1, &v45);
    if ( v12 )
    {
      sub_180003F80(
        (__int64)pExceptionObject,
        v12,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\AIS4WUtils.cpp line: 296 ");
      throw (ai::Error *)pExceptionObject;
    }
    if ( (_DWORD)v45 )
      return 0LL;
  }
  v13 = sub_180007D50();
  v14 = sub_180007790((__int64)v13);
  v15 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(v14 + 56))(a1, 4LL, &v45);
  if ( v15 )
  {
    sub_180003F80(
      (__int64)v49,
      v15,
      (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\pri"
               "vate\\api\\AIS4WUtils.cpp line: 296 ");
    throw (ai::Error *)v49;
  }
  if ( (_DWORD)v45 == 4 )
    return 0LL;
  if ( v6 == 13 )
  {
    v47[0] = 0LL;
    v16 = sub_1800398C0(&unk_1800748BD);
    v17 = sub_180007790(v16);
    v18 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(v17 + 184))(a1, v47);
    if ( v18 )
    {
      sub_180003F80(
        (__int64)v50,
        v18,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\AIS4WUtils.cpp line: 296 ");
      throw (ai::Error *)v50;
    }
    LODWORD(v45) = 2;
    v19 = sub_180039760(&unk_1800748C3);
    v20 = sub_180007790(v19);
    v21 = (*(__int64 (__fastcall **)(_QWORD, __int64 *))(v20 + 16))(v47[0], &v45);
    if ( v21 )
    {
      sub_180003F80(
        (__int64)v51,
        v21,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\AIS4WUtils.cpp line: 296 ");
      throw (ai::Error *)v51;
    }
    v22 = v45 == 2;
    v23 = 0;
    v46 = 0;
  }
  else
  {
    v23 = 0;
    v46 = 0;
    v22 = 0;
    if ( v6 == 1 )
    {
      v24 = sub_18002D6E0();
      v25 = (__int64 (__fastcall **)(__int64, int *))sub_180007790((__int64)v24);
      v26 = (*v25)(a1, &v46);
      if ( v26 )
      {
        sub_180003F80(
          (__int64)v52,
          v26,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 296 ");
        throw (ai::Error *)v52;
      }
      v22 = 0;
      v23 = v46;
      if ( v46 )
      {
        v23 = sub_18003DEA0(a1);
        v46 = v23;
        v22 = 0;
      }
    }
  }
  if ( (a4 & 2) != 0 || ((unsigned __int16)v6 > 0xAu || (v27 = 1034, !_bittest(&v27, v6))) && !v22 )
  {
    if ( !v23 )
    {
      if ( v6 != 13 || v22 )
      {
        v38 = sub_180007D50();
        v39 = sub_180007790((__int64)v38);
        v40 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, __int128 *))(v39 + 136))(a1, 0LL, a5, &v58);
        if ( v40 )
        {
          sub_180003F80(
            (__int64)v57,
            v40,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 296 ");
          throw (ai::Error *)v57;
        }
      }
      else
      {
        v35 = sub_180039970(&unk_1800748C1);
        v36 = sub_180007790(v35);
        v37 = (*(__int64 (__fastcall **)(__int64, __int128 *))(v36 + 240))(a1, &v58);
        if ( v37 )
        {
          sub_180003F80(
            (__int64)v56,
            v37,
            (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrato"
                     "r\\private\\api\\AIS4WUtils.cpp line: 296 ");
          throw (ai::Error *)v56;
        }
      }
      goto LABEL_35;
    }
LABEL_25:
    v45 = 0LL;
    v28 = sub_180007D50();
    v29 = sub_180007790((__int64)v28);
    v30 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v29 + 80))(a1, &v45);
    if ( v30 )
    {
      sub_180003F80(
        (__int64)v53,
        v30,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\AIS4WUtils.cpp line: 296 ");
      throw (ai::Error *)v53;
    }
    while ( v45 )
    {
      v31 = sub_18003A070(v45, &v58, a5);
      if ( v31 )
      {
        sub_180003F80(
          (__int64)v54,
          v31,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 296 ");
        throw (ai::Error *)v54;
      }
      v32 = sub_180007D50();
      v33 = sub_180007790((__int64)v32);
      v34 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v33 + 88))(v45, &v45);
      if ( v34 )
      {
        sub_180003F80(
          (__int64)v55,
          v34,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 296 ");
        throw (ai::Error *)v55;
      }
    }
LABEL_35:
    v41 = sub_180037970(&unk_1800748C4);
    v42 = sub_180007790(v41);
    if ( (*(unsigned int (__fastcall **)(__int128 *))(v42 + 200))(a2) )
    {
      *a2 = v58;
      a2[1] = v59;
    }
    else
    {
      v43 = sub_180037970(&unk_1800748C4);
      v44 = sub_180007790(v43);
      (*(void (__fastcall **)(__int128 *, __int128 *, __int128 *))(v44 + 224))(&v58, a2, a2);
    }
    return 0LL;
  }
  if ( v23 )
    goto LABEL_25;
  return 0LL;
}


// ===== 函数: sub_18002D9A0 (0x18002D9A0) =====
__int128 *sub_18002D9A0()
{
  _QWORD *v1; // rax

  if ( dword_180074400 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_1800743E0;
  Init_thread_header(&dword_180074400);
  if ( dword_180074400 != -1 )
    return &xmmword_1800743E0;
  xmmword_1800743E0 = 0LL;
  qword_1800743F0 = (__int64)"AI Plugin Group Suite";
  dword_1800743F8 = 6;
  byte_1800743FC = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_1800743E0 = *v1;
  *v1 = &xmmword_1800743E0;
  Init_thread_footer(&dword_180074400);
  return &xmmword_1800743E0;
}


// ===== 函数: sub_18003DEA0 (0x18003DEA0) =====
__int64 __fastcall sub_18003DEA0(__int64 a1)
{
  unsigned int v2; // ebx
  __int128 *v3; // rax
  __int64 v4; // rax
  int v5; // eax
  __int128 *v6; // rax
  void (__fastcall **v7)(__int64, int *); // rax
  __int128 *v8; // rax
  __int64 v9; // rax
  int v10; // eax
  __int128 *v11; // rax
  __int64 v12; // rax
  __int128 *v13; // rax
  __int64 v14; // rax
  __int16 v16; // [rsp+38h] [rbp+10h] BYREF
  int v17; // [rsp+40h] [rbp+18h] BYREF
  __int64 v18; // [rsp+48h] [rbp+20h] BYREF

  v2 = 0;
  v3 = sub_180007D50();
  v4 = sub_180007790((__int64)v3);
  v5 = (*(__int64 (__fastcall **)(__int64, __int16 *))(v4 + 48))(a1, &v16);
  if ( v16 == 1 && !v5 )
  {
    v17 = 0;
    v6 = sub_18002D6E0();
    v7 = (void (__fastcall **)(__int64, int *))sub_180007790((__int64)v6);
    (*v7)(a1, &v17);
    if ( v17 )
    {
      v18 = 0LL;
      v8 = sub_180007D50();
      v9 = sub_180007790((__int64)v8);
      v10 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v9 + 80))(a1, &v18);
      do
      {
        if ( !v18 )
          break;
        if ( v10 )
          break;
        v11 = sub_180007D50();
        v12 = sub_180007790((__int64)v11);
        v2 = (*(__int64 (__fastcall **)(__int64))(v12 + 328))(v18);
        v13 = sub_180007D50();
        v14 = sub_180007790((__int64)v13);
        v10 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v14 + 88))(v18, &v18);
      }
      while ( !v2 );
    }
  }
  return v2;
}


// ===== 函数: sub_1800398C0 (0x1800398C0) =====
__int128 *sub_1800398C0()
{
  _QWORD *v1; // rax

  if ( dword_1800748E8 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_1800748C8;
  Init_thread_header(&dword_1800748E8);
  if ( dword_1800748E8 != -1 )
    return &xmmword_1800748C8;
  xmmword_1800748C8 = 0LL;
  qword_1800748D8 = (__int64)"AI Symbol Suite";
  dword_1800748E0 = 8;
  byte_1800748E4 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_1800748C8 = *v1;
  *v1 = &xmmword_1800748C8;
  Init_thread_footer(&dword_1800748E8);
  return &xmmword_1800748C8;
}


// ===== 函数: sub_180039760 (0x180039760) =====
__int128 *sub_180039760()
{
  _QWORD *v1; // rax

  if ( dword_180074910 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_1800748F0;
  Init_thread_header(&dword_180074910);
  if ( dword_180074910 != -1 )
    return &xmmword_1800748F0;
  xmmword_1800748F0 = 0LL;
  qword_180074900 = (__int64)"AI Dynamic Symbol Suite";
  dword_180074908 = 1;
  byte_18007490C = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_1800748F0 = *v1;
  *v1 = &xmmword_1800748F0;
  Init_thread_footer(&dword_180074910);
  return &xmmword_1800748F0;
}


// ===== 函数: sub_180007D50 (0x180007D50) =====
__int128 *sub_180007D50()
{
  _QWORD *v1; // rax

  if ( dword_180073F60 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180073F40;
  Init_thread_header(&dword_180073F60);
  if ( dword_180073F60 != -1 )
    return &xmmword_180073F40;
  xmmword_180073F40 = 0LL;
  qword_180073F50 = (__int64)"AI Art Suite";
  dword_180073F58 = 21;
  byte_180073F5C = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180073F40 = *v1;
  *v1 = &xmmword_180073F40;
  Init_thread_footer(&dword_180073F60);
  return &xmmword_180073F40;
}


// ===== 函数: sub_180039970 (0x180039970) =====
__int128 *sub_180039970()
{
  _QWORD *v1; // rax

  if ( dword_180074938 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180074918;
  Init_thread_header(&dword_180074938);
  if ( dword_180074938 != -1 )
    return &xmmword_180074918;
  xmmword_180074918 = 0LL;
  qword_180074928 = (__int64)"AI Symbol Utils Suite";
  dword_180074930 = 1;
  byte_180074934 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180074918 = *v1;
  *v1 = &xmmword_180074918;
  Init_thread_footer(&dword_180074938);
  return &xmmword_180074918;
}


// ===== 函数: sub_18002D630 (0x18002D630) =====
__int128 *sub_18002D630()
{
  _QWORD *v1; // rax

  if ( dword_1800744C8 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_1800744A8;
  Init_thread_header(&dword_1800744C8);
  if ( dword_1800744C8 != -1 )
    return &xmmword_1800744A8;
  xmmword_1800744A8 = 0LL;
  qword_1800744B8 = (__int64)"AI Art Style Suite";
  dword_1800744C0 = 8;
  byte_1800744C4 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_1800744A8 = *v1;
  *v1 = &xmmword_1800744A8;
  Init_thread_footer(&dword_1800744C8);
  return &xmmword_1800744A8;
}


// ===== 函数: sub_180030600 (0x180030600) =====
__int64 __fastcall sub_180030600(__int64 a1, __int64 a2, _OWORD *a3)
{
  bool v6; // al
  ai *v8; // rcx
  struct ai::IFeatureManager *FeatureManager; // rdi
  __int64 (__fastcall *v10)(struct ai::IFeatureManager *, char **); // rbx
  __int64 v11; // rdx
  void **v12; // r8
  char *v13; // rcx
  __int64 v14; // rcx
  char *v15; // [rsp+30h] [rbp-48h] BYREF
  __int64 v16; // [rsp+40h] [rbp-38h]
  unsigned __int64 v17; // [rsp+48h] [rbp-30h]

  *(_QWORD *)a1 = *(_QWORD *)a2;
  sub_180036480((_QWORD *)(a1 + 8), a2 + 8);
  sub_180036480((_QWORD *)(a1 + 16), a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)a2;
  *(_OWORD *)(a1 + 56) = *a3;
  *(_OWORD *)(a1 + 72) = a3[1];
  *(_BYTE *)(a1 + 48) = 0;
  if ( dword_1800744FC > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                   + 4LL) )
  {
    Init_thread_header(&dword_1800744FC);
    if ( dword_1800744FC == -1 )
    {
      FeatureManager = ai::GetFeatureManager(v8);
      v10 = *(__int64 (__fastcall **)(struct ai::IFeatureManager *, char **))(*(_QWORD *)FeatureManager + 8LL);
      v13 = (char *)sub_180031D20((ai *)0x30, v11, v12);
      v16 = 38LL;
      v17 = 47LL;
      strcpy(v13, "DisableAlignToPixelGridForRasterExport");
      v15 = v13;
      byte_1800744F8 = v10(FeatureManager, &v15);
      if ( v17 >= 0x10 )
      {
        v14 = (__int64)v15;
        if ( v17 + 1 >= 0x1000 )
        {
          v14 = *((_QWORD *)v15 - 1);
          if ( (unsigned __int64)&v15[-v14 - 8] > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v14);
      }
      v16 = 0LL;
      v17 = 15LL;
      LOBYTE(v15) = 0;
      Init_thread_footer(&dword_1800744FC);
    }
  }
  if ( !byte_1800744F8 )
  {
    v6 = (unsigned int)(*(_DWORD *)(a1 + 28) - 1) > 1 && !sub_180006A00(a2);
    *(_BYTE *)(a1 + 48) = v6;
  }
  return a1;
}


// ===== 函数: sub_180006A00 (0x180006A00) =====
bool __fastcall sub_180006A00(__int64 a1)
{
  double v1; // xmm0_8
  double Y; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 28) )
    return 0;
  v1 = *(double *)a1;
  Y = 0.0;
  modf(v1, &Y);
  return (*(unsigned int (**)(void))(gAIRealMathSuite + 504))() == 0;
}


// ===== 函数: sub_1800053C0 (0x1800053C0) =====
char __fastcall sub_1800053C0(__int64 a1, double *a2, __int64 a3)
{
  int v4; // eax
  double v7; // xmm1_8
  double v8; // xmm1_8
  double v9; // xmm0_8

  LOBYTE(v4) = *(_BYTE *)(a1 + 24) - 6;
  if ( (unsigned __int8)v4 > 5u )
  {
    *(_QWORD *)a3 = *(_QWORD *)a1;
    sub_180036B40(a3 + 8, a1 + 8);
    sub_180036B40(a3 + 16, a1 + 16);
    *(_BYTE *)(a3 + 24) = *(_BYTE *)(a1 + 24);
    *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a3 + 36) = *(_DWORD *)(a1 + 36);
    v4 = *(_DWORD *)(a1 + 28);
    if ( v4 == 1 )
    {
      v7 = *a2 - a2[2];
    }
    else
    {
      if ( v4 != 2 )
        return v4;
      v7 = a2[1] - a2[3];
    }
    v8 = fabs(v7);
    if ( v8 > 0.0 )
    {
      v9 = *(double *)a3 / v8;
      *(_DWORD *)(a3 + 28) = 0;
      *(double *)a3 = v9;
    }
  }
  return v4;
}


// ===== 函数: sub_18002F5E0 (0x18002F5E0) =====
unsigned __int64 __fastcall sub_18002F5E0(__int64 a1, void **a2, __int64 a3)
{
  void **v6; // r8
  __int64 v7; // r14
  __int64 v8; // rdx
  unsigned __int64 v9; // r9
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rbx
  unsigned __int64 v13; // r12
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // r14
  unsigned __int64 v17; // rbx
  void **v18; // rdx
  void **v19; // rcx
  void **v20; // rbx
  void **i; // r15
  __int64 v22; // r8
  unsigned __int64 v24; // [rsp+20h] [rbp-68h]
  __int64 v25; // [rsp+20h] [rbp-68h]
  __int64 v26; // [rsp+28h] [rbp-60h]
  unsigned __int64 v27; // [rsp+30h] [rbp-58h]
  unsigned __int64 v29; // [rsp+98h] [rbp+10h]
  unsigned __int64 v30; // [rsp+A8h] [rbp+20h]

  v6 = *(void ***)a1;
  v7 = ((__int64)a2 - *(_QWORD *)a1) / 88;
  v8 = (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) / 88LL;
  if ( v8 == 0x2E8BA2E8BA2E8BALL )
    std::vector<void *>::_Xlen();
  v9 = v8 + 1;
  v26 = v8 + 1;
  v10 = (*(_QWORD *)(a1 + 16) - (_QWORD)v6) / 88LL;
  v11 = v10 >> 1;
  if ( v10 > 0x2E8BA2E8BA2E8BALL - (v10 >> 1) )
    goto LABEL_27;
  v12 = v9;
  if ( v11 + v10 >= v9 )
    v12 = v11 + v10;
  if ( v12 > 0x2E8BA2E8BA2E8BALL )
    goto LABEL_27;
  v13 = 88 * v12;
  v30 = v12;
  if ( 88 * v12 >= 0x1000 )
  {
    if ( v13 + 39 >= v13 )
    {
      v14 = sub_180031D20((ai *)(v13 + 39), v10, v6);
      if ( !v14 )
        goto LABEL_26;
      v15 = (v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v15 - 8) = v14;
      goto LABEL_13;
    }
LABEL_27:
    Concurrency::cancel_current_task();
  }
  if ( v13 )
  {
    v15 = sub_180031D20((ai *)(88 * v12), v10, v6);
    v24 = v15;
    v30 = v12;
    goto LABEL_30;
  }
  v15 = 0LL;
  v30 = v12;
LABEL_13:
  v24 = v15;
LABEL_30:
  try
  {
    v16 = v15 + 88 * v7;
    v17 = v16 + 88;
    v27 = v16 + 88;
    *(_QWORD *)v16 = *(_QWORD *)a3;
    sub_180036480((_QWORD *)(v16 + 8), a3 + 8);
    sub_180036480((_QWORD *)(v16 + 16), a3 + 16);
    *(_BYTE *)(v16 + 24) = *(_BYTE *)(a3 + 24);
    *(_DWORD *)(v16 + 28) = *(_DWORD *)(a3 + 28);
    *(_DWORD *)(v16 + 32) = *(_DWORD *)(a3 + 32);
    *(_DWORD *)(v16 + 36) = *(_DWORD *)(a3 + 36);
    *(_QWORD *)(v16 + 40) = *(_QWORD *)(a3 + 40);
    *(_BYTE *)(v16 + 48) = *(_BYTE *)(a3 + 48);
    *(_OWORD *)(v16 + 56) = *(_OWORD *)(a3 + 56);
    *(_OWORD *)(v16 + 72) = *(_OWORD *)(a3 + 72);
    v29 = v16;
    v18 = *(void ***)(a1 + 8);
    v19 = *(void ***)a1;
    if ( a2 == v18 )
    {
      v17 = v15;
    }
    else
    {
      sub_180030320(v19, a2, v15, a1, v24);
      v29 = v15;
      v19 = a2;
      v18 = *(void ***)(a1 + 8);
    }
    sub_180030320(v19, v18, v17, a1, v24);
  }
  catch ( ... )
  {
    sub_18002F420(v29, v27, a1);
    sub_180031C70(a1, v25, v30);
    throw;
  }
  v20 = *(void ***)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(void ***)(a1 + 8); v20 != i; v20 += 11 )
    {
      sub_180036A90(v20 + 2);
      sub_180036A90(v20 + 1);
    }
    v22 = *(_QWORD *)a1;
    if ( (unsigned __int64)(88 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) / 88LL)) < 0x1000 )
      goto LABEL_24;
    if ( (unsigned __int64)(v22 - *(_QWORD *)(v22 - 8) - 8) <= 0x1F )
    {
      v22 = *(_QWORD *)(v22 - 8);
LABEL_24:
      sub_18001AE10(v22);
      goto LABEL_25;
    }
LABEL_26:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_25:
  *(_QWORD *)a1 = v15;
  *(_QWORD *)(a1 + 8) = v15 + 88 * v26;
  *(_QWORD *)(a1 + 16) = v13 + v15;
  return v16;
}


// ===== 函数: sub_180030320 (0x180030320) =====
_QWORD *__fastcall sub_180030320(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v4; // r8
  char *v5; // r9
  __int64 v6; // rax
  __int64 v7; // rax

  if ( a1 != a2 )
  {
    v4 = a1 + 16;
    v5 = (char *)a3 - a1;
    do
    {
      v6 = *(_QWORD *)(v4 - 16);
      v4 += 88LL;
      *a3 = v6;
      a3 += 11;
      *(_QWORD *)&v5[v4 - 96] = *(_QWORD *)(v4 - 96);
      v7 = *(_QWORD *)(v4 - 88);
      *(_QWORD *)(v4 - 96) = 0LL;
      *(_QWORD *)&v5[v4 - 88] = v7;
      *(_QWORD *)(v4 - 88) = 0LL;
      v5[v4 - 80] = *(_BYTE *)(v4 - 80);
      *(_DWORD *)&v5[v4 - 76] = *(_DWORD *)(v4 - 76);
      *(_DWORD *)&v5[v4 - 72] = *(_DWORD *)(v4 - 72);
      *(_DWORD *)&v5[v4 - 68] = *(_DWORD *)(v4 - 68);
      *(_QWORD *)&v5[v4 - 64] = *(_QWORD *)(v4 - 64);
      v5[v4 - 56] = *(_BYTE *)(v4 - 56);
      *(_OWORD *)&v5[v4 - 48] = *(_OWORD *)(v4 - 48);
      *(_OWORD *)&v5[v4 - 32] = *(_OWORD *)(v4 - 32);
    }
    while ( v4 - 16 != a2 );
  }
  return a3;
}


// ===== 函数: sub_18002F8A0 (0x18002F8A0) =====
_QWORD *__fastcall sub_18002F8A0(__int64 *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4; // rbx
  __int64 v6; // r15
  __int64 v7; // rax
  void **v8; // r8
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // r12
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rdi
  __int64 v15; // r10
  _QWORD *v16; // r15
  _QWORD *v17; // r9
  _QWORD *v18; // rcx
  _QWORD *v19; // r8
  _QWORD *v20; // rcx
  unsigned __int64 v21; // r8
  _QWORD *v22; // rbx
  _QWORD *i; // r14
  __int64 v24; // rcx
  _QWORD *v26; // [rsp+20h] [rbp-58h]
  __int64 v27; // [rsp+28h] [rbp-50h]
  __int64 v29; // [rsp+88h] [rbp+10h]
  __int64 v30; // [rsp+98h] [rbp+20h]

  v4 = a2;
  v6 = ((__int64)a2 - *a1) >> 3;
  v7 = (a1[1] - *a1) >> 3;
  if ( v7 == 0x1FFFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen();
  v8 = (void **)(v7 + 1);
  v27 = v7 + 1;
  v9 = (a1[2] - *a1) >> 3;
  v10 = v9 >> 1;
  if ( v9 > 0x1FFFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_34;
  v11 = v7 + 1;
  if ( v10 + v9 >= (unsigned __int64)v8 )
    v11 = v10 + v9;
  if ( v11 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_34;
  v12 = 8 * v11;
  v29 = v11;
  if ( 8 * v11 < 0x1000 )
  {
    if ( v12 )
    {
      v14 = sub_180031D20((ai *)(8 * v11), v10, v8);
      v30 = v14;
    }
    else
    {
      v14 = 0LL;
      v30 = 0LL;
    }
    v29 = v11;
    goto LABEL_14;
  }
  if ( v12 + 39 < v12 )
LABEL_34:
    Concurrency::cancel_current_task();
  v13 = sub_180031D20((ai *)(v12 + 39), v10, v8);
  if ( !v13 )
    goto LABEL_33;
  v14 = (v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
  v30 = v14;
LABEL_14:
  v15 = 8 * v6;
  v16 = (_QWORD *)(8 * v6 + v14);
  try
  {
    *v16 = 0LL;
    *v16 = *a3;
    *a3 = 0LL;
    v26 = v16;
    v17 = (_QWORD *)a1[1];
    v18 = (_QWORD *)*a1;
    v19 = (_QWORD *)v14;
    if ( v4 == v17 )
    {
      for ( ; v18 != v17; ++v18 )
      {
        *v19 = 0LL;
        *v19 = *v18;
        *v18 = 0LL;
        ++v19;
      }
    }
    else
    {
      for ( ; v18 != v4; ++v18 )
      {
        *v19 = 0LL;
        *v19 = *v18;
        *v18 = 0LL;
        ++v19;
      }
      v26 = (_QWORD *)v14;
      v20 = (_QWORD *)a1[1];
      if ( v4 != v20 )
      {
        v21 = v15 - (_QWORD)v4 + v14;
        do
        {
          *(_QWORD *)((char *)v4 + v21 + 8) = 0LL;
          *(_QWORD *)((char *)v4 + v21 + 8) = *v4;
          *v4++ = 0LL;
        }
        while ( v4 != v20 );
      }
    }
  }
  catch ( ... )
  {
    sub_18002F5A0(v26, v16 + 1, a1);
    sub_18000E4E0((__int64)a1, v30, v29);
    throw;
  }
  v22 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v22 != i; ++v22 )
      sub_18000C810(v22);
    v24 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
      goto LABEL_31;
    if ( (unsigned __int64)(v24 - *(_QWORD *)(v24 - 8) - 8) <= 0x1F )
    {
      v24 = *(_QWORD *)(v24 - 8);
LABEL_31:
      sub_18001AE10(v24);
      goto LABEL_32;
    }
LABEL_33:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_32:
  *a1 = v14;
  a1[1] = v14 + 8 * v27;
  a1[2] = v12 + v14;
  return v16;
}


// ===== 函数: sub_18002FB00 (0x18002FB00) =====
_QWORD *__fastcall sub_18002FB00(__int64 *a1, _QWORD *a2, __int64 *a3, __int64 *a4, __int64 *a5)
{
  __int64 v6; // r14
  __int64 v7; // rdx
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // r15
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rdi
  _QWORD *v15; // r12
  _QWORD *v16; // rbx
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rdx
  _QWORD *v23; // rcx
  _QWORD *v24; // rbx
  _QWORD *i; // r14
  __int64 v26; // r8
  unsigned __int64 v28; // [rsp+20h] [rbp-68h]
  __int64 v29; // [rsp+20h] [rbp-68h]
  unsigned __int64 v30; // [rsp+28h] [rbp-60h]
  __int64 v31; // [rsp+28h] [rbp-60h]
  _QWORD *v32; // [rsp+30h] [rbp-58h] BYREF
  _QWORD *v33; // [rsp+38h] [rbp-50h]
  __int64 v34; // [rsp+40h] [rbp-48h]

  v34 = -2LL;
  v6 = ((__int64)a2 - *a1) / 40;
  v7 = (a1[1] - *a1) / 40;
  if ( v7 == 0x666666666666666LL )
    std::vector<void *>::_Xlen();
  v8 = v7 + 1;
  v9 = (a1[2] - *a1) / 40;
  v10 = v9 >> 1;
  if ( v9 > 0x666666666666666LL - (v9 >> 1) )
    goto LABEL_27;
  v11 = v8;
  if ( v10 + v9 >= v8 )
    v11 = v10 + v9;
  if ( v11 > 0x666666666666666LL )
    goto LABEL_27;
  v12 = 40 * v11;
  v28 = v11;
  if ( 40 * v11 < 0x1000 )
  {
    if ( v12 )
    {
      v14 = sub_180031D20((ai *)(40 * v11), v9, (void **)0x666666666666666LL);
      v30 = v14;
    }
    else
    {
      v14 = 0LL;
      v30 = 0LL;
    }
    v28 = v11;
    goto LABEL_30;
  }
  if ( v12 + 39 < v12 )
LABEL_27:
    Concurrency::cancel_current_task();
  v13 = sub_180031D20((ai *)(v12 + 39), v9, (void **)0x666666666666666LL);
  if ( !v13 )
    goto LABEL_26;
  v14 = (v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v14 - 8) = v13;
  v30 = v14;
LABEL_30:
  try
  {
    v15 = (_QWORD *)(v14 + 40 * v6);
    v16 = v15 + 5;
    v33 = v15 + 5;
    v17 = *a5;
    v18 = a4[2];
    a4[2] = 0LL;
    v19 = a4[1];
    a4[1] = 0LL;
    v20 = *a4;
    *a4 = 0LL;
    v21 = *a3;
    *a3 = 0LL;
    *v15 = v21;
    v32 = 0LL;
    v15[1] = v20;
    v15[2] = v19;
    v15[3] = v18;
    v15[4] = v17;
    sub_180036A90(&v32);
    v32 = v15;
    v22 = a1[1];
    v23 = (_QWORD *)*a1;
    if ( a2 == (_QWORD *)v22 )
    {
      v16 = (_QWORD *)v14;
    }
    else
    {
      sub_1800303D0(v23, a2, v14, a1, v28, v30);
      v32 = (_QWORD *)v14;
      v23 = a2;
      v22 = a1[1];
    }
    sub_1800303D0(v23, v22, v16, a1, v28, v30);
  }
  catch ( ... )
  {
    sub_18002F460(v32, v33, a1);
    sub_18001A220(a1, v31, v29);
    throw;
  }
  v24 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v24 != i; v24 += 5 )
    {
      sub_180030E80(v24 + 1);
      sub_180036A90(v24);
    }
    v26 = *a1;
    if ( (unsigned __int64)(40 * ((a1[2] - *a1) / 40)) < 0x1000 )
      goto LABEL_24;
    if ( (unsigned __int64)(v26 - *(_QWORD *)(v26 - 8) - 8) <= 0x1F )
    {
      v26 = *(_QWORD *)(v26 - 8);
LABEL_24:
      sub_18001AE10(v26);
      goto LABEL_25;
    }
LABEL_26:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_25:
  *a1 = v14;
  a1[1] = v14 + 40 * v8;
  a1[2] = v12 + v14;
  return v15;
}


// ===== 函数: sub_1800303D0 (0x1800303D0) =====
_QWORD *__fastcall sub_1800303D0(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // r10
  char *v5; // r11
  __int64 v6; // r8
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r9
  __int64 v10; // rdx

  v3 = a3;
  if ( a1 != a2 )
  {
    v5 = (char *)a3 - a1;
    v6 = a1 + 16;
    do
    {
      v7 = *(_QWORD *)(v6 - 16);
      v6 += 40LL;
      *v3 = v7;
      v3 += 5;
      v8 = *(_QWORD *)(v6 - 48);
      v9 = *(_QWORD *)(v6 - 32);
      v10 = *(_QWORD *)(v6 - 40);
      *(_QWORD *)(v6 - 32) = 0LL;
      *(_QWORD *)(v6 - 40) = 0LL;
      *(_QWORD *)(v6 - 48) = 0LL;
      *(_QWORD *)(v6 - 56) = 0LL;
      *(_QWORD *)&v5[v6 - 48] = v8;
      *(_QWORD *)&v5[v6 - 40] = v10;
      *(_QWORD *)&v5[v6 - 32] = v9;
      *(_QWORD *)&v5[v6 - 24] = *(_QWORD *)(v6 - 24);
    }
    while ( v6 - 16 != a2 );
  }
  return v3;
}


// ===== 函数: sub_180006E90 (0x180006E90) =====
void __fastcall sub_180006E90(__int64 a1)
{
  double v1; // xmm0_8

  if ( *(_DWORD *)(a1 + 28) == 3 )
  {
    v1 = *(double *)a1 / 72.0;
    *(_DWORD *)(a1 + 28) = 0;
    *(double *)a1 = v1;
  }
}


// ===== 函数: sub_180006AB0 (0x180006AB0) =====
__int64 __fastcall sub_180006AB0(__int64 a1)
{
  __int64 result; // rax
  double v3; // [rsp+30h] [rbp+8h] BYREF

  if ( (unsigned int)(*(_DWORD *)(a1 + 28) - 1) <= 1 )
    return 0LL;
  v3 = 1.0;
  result = (*(__int64 (__fastcall **)(double *))(gAIDocumentSuite + 624))(&v3);
  if ( !(_DWORD)result )
    *(double *)a1 = v3 * *(double *)a1;
  return result;
}


// ===== 函数: sub_180006B10 (0x180006B10) =====
__int128 *sub_180006B10()
{
  _QWORD *v1; // rax

  if ( dword_180073E30 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180073E10;
  Init_thread_header(&dword_180073E30);
  if ( dword_180073E30 != -1 )
    return &xmmword_180073E10;
  xmmword_180073E10 = 0LL;
  qword_180073E20 = (__int64)"AI Hard Soft Suite";
  dword_180073E28 = 6;
  byte_180073E2C = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180073E10 = *v1;
  *v1 = &xmmword_180073E10;
  Init_thread_footer(&dword_180073E30);
  return &xmmword_180073E10;
}


// ===== 函数: sub_18002EC30 (0x18002EC30) =====
__int64 __fastcall sub_18002EC30(__int64 a1, __int64 a2, __int64 a3, __int64 **a4, _QWORD *a5, __int64 a6)
{
  __int64 **v6; // rdi
  unsigned int v8; // r13d
  char v9; // si
  __int64 *v10; // rax
  __int64 v11; // r15
  __int64 v12; // rax
  __int64 v13; // rsi
  __int64 v14; // r12
  __int64 v15; // rax
  int v16; // ebx
  double v17; // xmm0_8
  double v18; // xmm0_8
  _OWORD *v19; // rdx
  __int64 *v20; // rdi
  __int64 *v21; // rbx
  char *v22; // rbx
  void (__fastcall *v23)(_QWORD *, __int64, __int128 *); // rdi
  __int64 v24; // rbx
  _QWORD *v25; // rax
  void (__fastcall *v26)(const char *, const char *, __int64 *); // rdi
  unsigned __int64 v27; // r8
  char *v28; // r9
  unsigned __int64 v29; // rax
  __int64 *v30; // r8
  __int64 v31; // rcx
  unsigned int v32; // esi
  char *v33; // rdi
  char *v34; // rax
  __int64 v35; // rax
  __int64 (__fastcall *v36)(__int64); // rdi
  __int64 (__fastcall *v37)(__int64, __int64); // rbx
  __int64 v38; // rax
  __int64 v39; // rax
  void (*v40)(const char *, const char *, _QWORD, _QWORD, __int64, const char *, ...); // rbx
  __int64 v41; // rax
  __int128 v43; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v44; // [rsp+60h] [rbp-A0h]
  int v45; // [rsp+68h] [rbp-98h]
  __int64 v46; // [rsp+70h] [rbp-90h] BYREF
  __int64 v47; // [rsp+78h] [rbp-88h] BYREF
  __int64 v48; // [rsp+80h] [rbp-80h] BYREF
  __int64 v49; // [rsp+88h] [rbp-78h] BYREF
  __int64 v50; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int64 v51; // [rsp+98h] [rbp-68h] BYREF
  __int64 v52; // [rsp+A0h] [rbp-60h]
  _QWORD *v53; // [rsp+A8h] [rbp-58h]
  __int64 **v54; // [rsp+B0h] [rbp-50h]
  char v55; // [rsp+B8h] [rbp-48h]
  __int64 v56; // [rsp+C0h] [rbp-40h]
  __int64 v57; // [rsp+C8h] [rbp-38h]
  const char *v58; // [rsp+D0h] [rbp-30h]
  const char *v59; // [rsp+D8h] [rbp-28h]
  __int16 v60; // [rsp+E0h] [rbp-20h]
  __int64 v61; // [rsp+E8h] [rbp-18h]
  __int64 v62[2]; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v63; // [rsp+100h] [rbp+0h]
  unsigned __int64 v64; // [rsp+108h] [rbp+8h]
  _OWORD v65[2]; // [rsp+110h] [rbp+10h] BYREF
  __int128 v66; // [rsp+130h] [rbp+30h] BYREF
  _BYTE v67[3]; // [rsp+145h] [rbp+45h] BYREF

  v61 = -2LL;
  v6 = a4;
  v54 = a4;
  v52 = a3;
  v53 = a5;
  v8 = 0;
  v9 = 0;
  v45 = 0;
  v55 = 0;
  if ( gAIDevUtilsSuite )
  {
    v56 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
    v57 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
  }
  v58 = "PreCheckMemoryBounds";
  v59 = "SmartExport";
  v60 = 0;
  v43 = 0LL;
  v44 = 0LL;
  v10 = (__int64 *)sub_18000DE70(a2);
  v11 = *v10;
  v12 = v10[1];
  v48 = v12;
  if ( v11 != v12 )
  {
    do
    {
      v13 = *(_QWORD *)(v11 + 8);
      v14 = *(_QWORD *)(v11 + 16);
      if ( v13 != v14 )
      {
        do
        {
          v65[0] = *(_OWORD *)(v13 + 56);
          v65[1] = *(_OWORD *)(v13 + 72);
          v15 = sub_180031130(v52, *(unsigned __int8 *)(v13 + 24));
          LODWORD(v62[0]) = *(_DWORD *)(v15 + 32);
          v62[1] = *(_QWORD *)(v15 + 40);
          LOWORD(v63) = *(_WORD *)(v15 + 48);
          HIDWORD(v63) = *(_DWORD *)(v15 + 52);
          v64 = *(_QWORD *)(v15 + 56);
          sub_180031C50(v13, v62);
          v49 = 0LL;
          v50 = 0LL;
          v51 = 0LL;
          v16 = sub_18001A580(
                  (unsigned int)v65,
                  (unsigned int)v62,
                  (unsigned int)&v49,
                  (unsigned int)&v50,
                  (__int64)&v51);
          if ( v49 < 0 )
            v17 = (double)(int)(v49 & 1 | ((unsigned __int64)v49 >> 1))
                + (double)(int)(v49 & 1 | ((unsigned __int64)v49 >> 1));
          else
            v17 = (double)(int)v49;
          *(double *)&v66 = v17;
          if ( v50 < 0 )
            v18 = (double)(int)(v50 & 1 | ((unsigned __int64)v50 >> 1))
                + (double)(int)(v50 & 1 | ((unsigned __int64)v50 >> 1));
          else
            v18 = (double)(int)v50;
          *((double *)&v66 + 1) = v18;
          v19 = *(_OWORD **)(a6 + 8);
          if ( v19 == *(_OWORD **)(a6 + 16) )
          {
            sub_18002DC30(a6, v19, &v66);
          }
          else
          {
            *v19 = v66;
            *(_QWORD *)(a6 + 8) += 16LL;
          }
          if ( !v16 && v51 >= 0x7FFFFFF0 )
          {
            unknown_libname_2(&v47);
            BuildExportFilePath(v11, v13, v53, &v47);
            sub_180032AF0((__int64)&v47, &v46, 0);
            v20 = *v6;
            v21 = (__int64 *)v20[1];
            while ( !*((_BYTE *)v21 + 25) )
            {
              if ( (int)sub_1800372B0((__int64)(v21 + 4), (__int64)&v46) >= 0 )
              {
                v20 = v21;
                v21 = (__int64 *)*v21;
              }
              else
              {
                v21 = (__int64 *)v21[2];
              }
            }
            if ( *((_BYTE *)v20 + 25) || (int)sub_1800372B0((__int64)&v46, (__int64)(v20 + 4)) < 0 )
            {
              if ( *((_QWORD *)&v43 + 1) == v44 )
              {
                sub_18002DA50(&v43, *((_QWORD *)&v43 + 1), &v46);
              }
              else
              {
                sub_180036480(*((_QWORD **)&v43 + 1), (__int64)&v46);
                *((_QWORD *)&v43 + 1) += 8LL;
              }
            }
            sub_180036A90(&v46);
            sub_180032550(&v47);
            v6 = v54;
          }
          v13 += 88LL;
        }
        while ( v13 != v14 );
        v12 = v48;
      }
      v11 += 40LL;
    }
    while ( v11 != v12 );
    v9 = v45;
  }
  v22 = (char *)v43;
  if ( (_QWORD)v43 == *((_QWORD *)&v43 + 1) )
  {
    v32 = 0;
  }
  else
  {
    if ( gAIUserInterfaceUtilitySuite )
    {
      v23 = *(void (__fastcall **)(_QWORD *, __int64, __int128 *))(gAIUserInterfaceUtilitySuite + 152);
      v24 = sub_180004150(&off_180072290);
      v25 = sub_180036E50(&v48, (__int64)"Adobe Illustrator");
      v9 = 1;
      v45 = 1;
      v23(v25, v24, &v43);
      v22 = (char *)v43;
    }
    if ( (v9 & 1) != 0 )
    {
      sub_180036A90(&v48);
      v22 = (char *)v43;
    }
    if ( gAIAdobePIPSuite )
    {
      v26 = *(void (__fastcall **)(const char *, const char *, __int64 *))gAIAdobePIPSuite;
      v27 = (__int64)(*((_QWORD *)&v43 + 1) - (_QWORD)v22) >> 3;
      v28 = v67;
      do
      {
        *--v28 = v27 % 0xA + 48;
        v27 /= 0xAuLL;
      }
      while ( v27 );
      v62[0] = 0LL;
      v63 = 0LL;
      v29 = 15LL;
      v64 = 15LL;
      if ( v28 != v67 )
      {
        sub_180006EF0(v62, v28, v67 - v28);
        v29 = v64;
      }
      v30 = v62;
      if ( v29 >= 0x10 )
        v30 = (__int64 *)v62[0];
      v26("BackgroundExport", "BackgroundExportImageSizeLimitReached", v30);
      if ( v64 >= 0x10 )
      {
        v31 = v62[0];
        if ( v64 + 1 >= 0x1000 )
        {
          v31 = *(_QWORD *)(v62[0] - 8);
          if ( (unsigned __int64)(v62[0] - v31 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v31);
      }
      v22 = (char *)v43;
    }
    v32 = 558445122;
  }
  if ( v22 )
  {
    v33 = (char *)*((_QWORD *)&v43 + 1);
    if ( v22 != *((char **)&v43 + 1) )
    {
      do
      {
        sub_180036A90(v22);
        v22 += 8;
      }
      while ( v22 != v33 );
      v22 = (char *)v43;
    }
    v34 = v22;
    if ( (unsigned __int64)(8 * ((v44 - (__int64)v22) >> 3)) >= 0x1000 )
    {
      v22 = (char *)*((_QWORD *)v22 - 1);
      if ( (unsigned __int64)(v34 - v22 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10((__int64)v22);
    v43 = 0LL;
    v44 = 0LL;
  }
  v35 = gAIDevUtilsSuite;
  if ( gAIDevUtilsSuite )
  {
    v36 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
    v37 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
    v38 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v57);
    v39 = v37(v38, v56);
    v8 = v36(v39);
    v35 = gAIDevUtilsSuite;
  }
  v40 = *(void (**)(const char *, const char *, _QWORD, _QWORD, __int64, const char *, ...))(v35 + 248);
  v41 = sub_18000D970();
  v40("SmartExport", "PreCheckMemoryBounds", v8, 0LL, v41, "%u,%s,%s", v8, "SmartExport", "PreCheckMemoryBounds");
  return v32;
}


// ===== 函数: sub_18001A580 (0x18001A580) =====
__int64 __fastcall sub_18001A580(double *a1, __int64 a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  double v5; // xmm4_8
  double v9; // xmm2_8
  double v10; // xmm3_8
  unsigned __int16 v11; // ax
  _OWORD v13[2]; // [rsp+20h] [rbp-58h] BYREF

  v5 = a1[2];
  if ( v5 < *a1 || (v9 = a1[3], v10 = a1[1], v9 < v10) || *(double *)(a2 + 8) == 0.0 || v5 == *a1 && v9 == v10 )
  {
    a1 = (double *)v13;
    v13[1] = 0LL;
    v13[0] = xmmword_1800573C0;
  }
  sub_18003BE50(a1);
  if ( !*a3 || !*a4 )
    return 1346458189LL;
  v11 = sub_18001E3D0(a2);
  *a5 = *a4 * (unsigned int)sub_18001E650(*(unsigned int *)a3, v11);
  return 0LL;
}


// ===== 函数: sub_18003BE50 (0x18003BE50) =====
unsigned __int64 __fastcall sub_18003BE50(double *a1, double a2, _QWORD *a3, unsigned __int64 *a4)
{
  double v6; // xmm7_8
  double v7; // xmm0_8
  unsigned __int64 v8; // rcx
  double v9; // xmm0_8
  unsigned __int64 v10; // rcx
  unsigned __int64 result; // rax

  v6 = a1[1] - a1[3];
  v7 = ceil(fabs(a1[2] - *a1) * (a2 / 72.0) - 0.1);
  v8 = 0LL;
  if ( v7 >= 9.223372036854776e18 )
  {
    v7 = v7 - 9.223372036854776e18;
    if ( v7 < 9.223372036854776e18 )
      v8 = 0x8000000000000000uLL;
  }
  *a3 = v8 + (unsigned int)(int)v7;
  v9 = ceil(fabs(v6) * (a2 / 72.0) - 0.1);
  v10 = 0LL;
  if ( v9 >= 9.223372036854776e18 )
  {
    v9 = v9 - 9.223372036854776e18;
    if ( v9 < 9.223372036854776e18 )
      v10 = 0x8000000000000000uLL;
  }
  result = v10 + (unsigned int)(int)v9;
  *a4 = result;
  return result;
}


// ===== 函数: ceil (0x18004D13C) =====
// attributes: thunk
double __cdecl ceil(double X)
{
  return __imp_ceil(X);
}


// ===== 函数: sub_18001E650 (0x18001E650) =====
__int64 __fastcall sub_18001E650(unsigned __int64 a1, unsigned __int16 a2)
{
  if ( a2 == 1 )
  {
    a1 = (unsigned int)a1;
    if ( (a1 & 7) != 0 )
      return ((unsigned int)(((-(int)a1 & 7) + (unsigned __int64)(unsigned int)a1) >> 3) + 3) & 0xFFFFFFFC;
  }
  else
  {
    a1 = a2 * (unsigned int)a1;
  }
  return ((unsigned int)(a1 >> 3) + 3) & 0xFFFFFFFC;
}


// ===== 函数: sub_18001E3D0 (0x18001E3D0) =====
__int64 __fastcall sub_18001E3D0(_DWORD *a1)
{
  return 8 * (unsigned int)sub_18001E3F0(a1);
}


// ===== 函数: sub_18001E3F0 (0x18001E3F0) =====
__int64 __fastcall sub_18001E3F0(_DWORD *a1)
{
  __int64 result; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  switch ( *a1 )
  {
    case 0:
      result = 3LL;
      break;
    case 1:
    case 4:
      result = 4LL;
      break;
    case 2:
      result = 1LL;
      break;
    case 5:
      result = 5LL;
      break;
    case 6:
      result = 2LL;
      break;
    default:
      sub_180003F80((__int64)pExceptionObject, 558452048, 0LL);
      throw (ai::Error *)pExceptionObject;
  }
  return result;
}


// ===== 函数: BuildExportFilePath (0x180004C90) =====
// 函数分析报告: sub_180004C90
// 分析时间: 2025-09-23 11:15:23.594906
// 
// 目标函数: sub_180004C90 (地址: 0x180004C90)
// 
// 函数功能概述
// sub_180004C90 函数的核心功能是构建并验证一个完整的、用于导出资产的文件路径。它根据输入的导出设置（如文件名、文件格式、缩放比例等）、基础目录和资产名称来生成最终的输出路径。此函数还会根据用户的偏好设置（Preferences）决定是否要在基础路径下创建额外的子文件夹（例如，按比例或格式分类的文件夹），并确保该路径在文件系统上是有效且可用的。
// 
// 执行流程与参数分析
// 函数签名 (推测):
// unsigned int __fastcall BuildExportFilePath(__int64 assetName, ExportSettings* settings, AIFilePath* basePath, AIFilePath* outFinalPath)
// 
// 参数分析:
// 参数  类型  推测名称    描述
// a1  __int64 assetName   输入参数。一个指向 AIUnicodeString 对象的句柄，代表要导出的资产的名称（不含扩展名）。
// a2  __int64 settings    输入参数。一个指向结构体的指针，包含了本次导出的所有设置。根据代码分析，其结构至少包含： - +8: 资产名称的 AIUnicodeString 句柄。 - +16: 另一个 AIUnicodeString 句柄，可能是前缀或后缀。 - +24: 一个 unsigned char，表示文件格式的枚举值 (e.g., 0 for PNG, 6 for SVG)。 - +28: 一个 unsigned int，表示尺寸规格 (e.g., 0 for 1x, 1 for 2x, etc.)。
// a3  _QWORD* basePath    输入参数。一个指向 AIFilePath 对象的指针，代表用户选择的基础导出目录。
// a4  _QWORD* outFinalPath    输出参数。一个指向 AIFilePath 对象的指针。函数将把最终构建完成的完整文件路径（目录 + 文件名 + 扩展名）写入此对象。
// 
// Export to Sheets
// 执行流程:
// 组合基础文件名:
// 
// 函数首先调用 sub_180036480 和 sub_180036F90，将 assetName (a1) 和 settings (a2) 中的相关字符串部分（如前缀/后缀）组合成一个临时的基础文件名 v13。
// 
// 获取格式和扩展名:
// 
// 调用 sub_1800067F0，它根据 settings->format_enum (*(a2 + 24)) 这个枚举值，在一个 switch 语句中查找对应的文件格式全名（如 "Adobe PNG Format"）和文件扩展名（如 "png"）。结果分别存入临时字符串 v18 和 v15。
// 
// 初始化输出路径:
// 
// 调用 sub_180032600，将用户提供的基础目录 basePath (a3) 拷贝到输出路径 outFinalPath (a4) 中，作为构建的起点。
// 
// 创建子文件夹 (核心逻辑):
// 
// 调用 sub_1800051B0，这是构建子目录路径的核心。该函数会：
// 
// 检查 gAIPreferenceSuite 中的用户偏好设置，判断是否需要创建子文件夹 (CreateFoldersPreference)。
// 
// 如果需要，会进一步检查是按比例 (CreateFoldersByScalePreference) 还是按格式创建子文件夹。
// 
// 根据这些设置和 settings 结构中的信息，生成相应的子文件夹名称（例如 "2x" 或 "PNG"）。
// 
// 将生成的子文件夹路径追加到 outFinalPath (a4)。
// 
// 调用 sub_180014350，该函数会调用 Windows API CreateDirectoryW 来在文件系统上实际创建这个子目录（如果它不存在）。
// 
// 组合最终路径:
// 
// 如果 sub_1800051B0 成功执行（返回 0），函数继续构建最终路径。
// 
// 调用 sub_180032790，将第一步中组合的基础文件名 v13 追加到 outFinalPath（现在它包含了所有子目录）。
// 
// 调用 sub_1800364F0，将第二步中获取的文件扩展名 v15 转换为 AIUnicodeString。
// 
// 调用 sub_180032860，将文件扩展名追加到 outFinalPath。至此，outFinalPath (a4) 中包含了完整的 目录/子目录/文件名.扩展名 路径。
// 
// 清理和返回:
// 
// 释放所有在函数中临时创建的字符串和路径对象 (sub_18001AE10, sub_180036A90)。
// 
// 返回 sub_1800051B0 的结果码 v8，表示子目录创建步骤是否成功。如果成功，v8 为 0。
// 
// 结论
// sub_180004C90 是一个功能完备的文件路径构建和管理函数。它不仅仅是字符串的拼接，而是深度集成了应用程序的配置系统（用户偏好）和文件系统操作，以一种灵活的方式生成符合导出规则的最终文件路径，并确保所需的目录结构真实存在。这个函数在导出流程中起着至关重要的作用，为后续的文件写入操作准备了正确的目标位置。
__int64 __fastcall sub_180004C90(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  unsigned int v8; // ebx
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v13; // [rsp+20h] [rbp-39h] BYREF
  _QWORD v14[2]; // [rsp+28h] [rbp-31h] BYREF
  _QWORD v15[2]; // [rsp+38h] [rbp-21h] BYREF
  __int64 v16; // [rsp+48h] [rbp-11h]
  unsigned __int64 v17; // [rsp+50h] [rbp-9h]
  _QWORD v18[3]; // [rsp+58h] [rbp-1h] BYREF
  unsigned __int64 v19; // [rsp+70h] [rbp+17h]

  v14[1] = -2LL;
  sub_180036480(&v13, a2 + 16);
  sub_180036F90((__int64)&v13, a1);
  sub_180036F90((__int64)&v13, a2 + 8);
  v18[0] = 0LL;
  v18[2] = 0LL;
  v19 = 15LL;
  v15[0] = 0LL;
  v16 = 0LL;
  v17 = 15LL;
  sub_1800067F0(*(unsigned __int8 *)(a2 + 24), v18, v15);
  sub_180032600(a4, a3);
  v8 = sub_1800051B0(a2, a4);
  if ( !v8 )
  {
    sub_180032790(a4, &v13);
    v9 = sub_1800364F0(v14, v15, 0LL);
    sub_180032860(a4, v9);
    sub_180036A90(v14);
  }
  if ( v17 >= 0x10 )
  {
    v10 = v15[0];
    if ( v17 + 1 >= 0x1000 )
    {
      v10 = *(_QWORD *)(v15[0] - 8LL);
      if ( (unsigned __int64)(v15[0] - v10 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10(v10);
  }
  v16 = 0LL;
  v17 = 15LL;
  LOBYTE(v15[0]) = 0;
  if ( v19 >= 0x10 )
  {
    v11 = v18[0];
    if ( v19 + 1 >= 0x1000 )
    {
      v11 = *(_QWORD *)(v18[0] - 8LL);
      if ( (unsigned __int64)(v18[0] - v11 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10(v11);
  }
  sub_180036A90(&v13);
  return v8;
}


// ===== 函数: sub_180032860 (0x180032860) =====
__int64 __fastcall sub_180032860(__int64 a1, __int64 a2)
{
  __int128 *v4; // rax
  __int128 *v5; // rbx
  int v6; // eax
  _QWORD *v7; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v4 = sub_180032E90();
  v5 = v4;
  if ( !*((_QWORD *)v4 + 1) && qword_1800740D8 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v4 + 2),
           *((unsigned int *)v4 + 6),
           (__int64)v4 + 8);
    if ( v6 )
    {
      sub_180003F80((__int64)pExceptionObject, v6, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v5 + 28) )
    {
      v7 = sub_180012E90();
      *(_QWORD *)v5 = *v7;
      *v7 = v5;
    }
  }
  return (*(__int64 (__fastcall **)(__int64, __int64))(*((_QWORD *)v5 + 1) + 88LL))(a2, a1);
}


// ===== 函数: sub_1800067F0 (0x1800067F0) =====
__int64 *__fastcall sub_1800067F0(unsigned __int8 a1, __int64 *a2, __int64 *a3)
{
  __int64 *result; // rax

  result = (__int64 *)a1;
  switch ( a1 )
  {
    case 0u:
    case 1u:
      sub_180006EF0(a2, "Adobe PNG Format", 0x10uLL);
      result = sub_180006EF0(a3, "png", 3uLL);
      break;
    case 2u:
    case 3u:
    case 4u:
    case 5u:
      sub_180006EF0(a2, "JPEG file format", 0x10uLL);
      result = sub_180006EF0(a3, "jpg", 3uLL);
      break;
    case 6u:
      sub_180006EF0(a2, "svg file format", 0xFuLL);
      result = sub_180006EF0(a3, "svg", 3uLL);
      break;
    case 7u:
      sub_180006EF0(a2, "PDF File Format", 0xFuLL);
      result = sub_180006EF0(a3, "pdf", 3uLL);
      break;
    case 8u:
      sub_180006EF0(a2, "OBJ File Format", 0xFuLL);
      result = sub_180006EF0(a3, "obj", 3uLL);
      break;
    case 9u:
      sub_180006EF0(a2, "USDA File Format", 0x10uLL);
      result = sub_180006EF0(a3, "usda", 4uLL);
      break;
    case 0xAu:
      sub_180006EF0(a2, "USDZ File Format", 0x10uLL);
      result = sub_180006EF0(a3, "usdz", 4uLL);
      break;
    case 0xBu:
      sub_180006EF0(a2, "GLTF File Format", 0x10uLL);
      result = sub_180006EF0(a3, "gltf", 4uLL);
      break;
    case 0xCu:
      sub_180006EF0(a2, "WebP", 4uLL);
      result = sub_180006EF0(a3, "webp", 4uLL);
      break;
    default:
      return result;
  }
  return result;
}


// ===== 函数: sub_1800051B0 (0x1800051B0) =====
__int64 __fastcall sub_1800051B0(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  int v5; // esi
  __int64 v6; // r8
  char **v7; // rcx
  __int64 v8; // rax
  int v10; // [rsp+60h] [rbp+18h] BYREF
  __int64 v11; // [rsp+68h] [rbp+20h] BYREF

  v4 = 1128353364;
  if ( gAIPreferenceSuite )
    v4 = 0;
  v5 = 1;
  v10 = 1;
  if ( !gAIPreferenceSuite
    || ((*(void (__fastcall **)(const char *, const char *, int *))gAIPreferenceSuite)(
          "SmartExportUI",
          "CreateFoldersPreference",
          &v10),
        v10) )
  {
    unknown_libname_2(&v11);
    v10 = 1;
    if ( gAIPreferenceSuite )
    {
      (*(void (__fastcall **)(const char *, const char *, int *))gAIPreferenceSuite)(
        "SmartExportUI",
        "CreateFoldersByScalePreference",
        &v10);
      v5 = v10;
    }
    if ( v5 )
    {
      GetExportSubfolderOrSuffix_0(*(unsigned __int8 *)(a1 + 24), *(unsigned int *)(a1 + 28), v6, &v11, -2LL);
    }
    else
    {
      switch ( *(_BYTE *)(a1 + 24) )
      {
        case 0:
        case 1:
          v7 = &off_180072000;
          goto LABEL_19;
        case 2:
        case 3:
        case 4:
        case 5:
          v7 = (char **)&off_180072028;
          goto LABEL_19;
        case 6:
          v7 = &off_180072050;
          goto LABEL_19;
        case 7:
          v7 = &off_180072078;
          goto LABEL_19;
        case 8:
          v7 = &off_1800720A0;
          goto LABEL_19;
        case 9:
          v7 = &off_1800720C8;
          goto LABEL_19;
        case 0xA:
          v7 = &off_1800720F0;
          goto LABEL_19;
        case 0xB:
          v7 = &off_180072118;
          goto LABEL_19;
        case 0xC:
          v7 = &off_180072140;
LABEL_19:
          v8 = sub_180004150(v7);
          sub_180036B40((__int64)&v11, v8);
          break;
        default:
          break;
      }
    }
    if ( !(unsigned __int8)sub_180037360(&v11) )
    {
      sub_180032790(a2, &v11);
      v4 = sub_180014350(a2);
    }
    sub_180036A90(&v11);
  }
  return v4;
}


// ===== 函数: GetExportSubfolderOrSuffix_0 (0x180006620) =====
// 函数分析报告: sub_180006620
// 分析时间: 2025-09-23 11:15:23.615845
// 
// 目标函数: sub_180006620 (地址: 0x180006620)
// 
// 函数功能概述
// sub_180006620 函数的主要功能是根据导出的文件格式和尺寸规格，生成并返回一个对应的文件名后缀或子目录名称。此函数在构建最终导出文件路径的过程中扮演着关键角色，它为不同类型的导出任务（如按比例缩放、按固定宽度/高度或按分辨率导出）提供了标准化的命名约定。
// 
// 执行流程与参数分析
// 函数签名 (推测):
// void __fastcall GetExportSubfolderOrSuffix(unsigned char formatEnum, int scaleMode, __int64 unused, AIUnicodeString* outString)
// 
// 参数分析:
// 参数  类型  推测名称    描述
// a1  char    formatEnum  输入参数。一个单字节的枚举值，代表目标导出文件格式。例如 0 和 1 代表PNG，2-5 代表JPG，6 代表SVG等。
// a2  int scaleMode   输入参数。一个整数，代表尺寸调整的模式或规格。例如 0=按比例(x), 1=按宽度(w), 2=按高度(h), 3=按分辨率(ppi)。
// a3  __int64 unused  未使用参数。在当前函数实现中，此参数没有被读取或使用。
// a4  __int64 outString   输出参数。一个指向 AIUnicodeString 对象的指针。函数将把生成的后缀或子目录名字符串写入此对象。
// 
// Export to Sheets
// 执行流程:
// 该函数的核心是一个大型的 switch 语句，根据传入的 formatEnum (a1) 参数来决定执行哪个逻辑分支。
// 
// 分支一: 光栅格式 (PNG, JPG, WebP - cases 0-5, 12)
// 
// 这个分支处理需要根据具体尺寸（如 1x, 100w, 300ppi）生成后缀的格式。
// 
// 获取用户偏好: 首先，通过 gAIUserSuite 获取一个用户自定义的格式化字符串（存储在 v14 中）。例如，用户可能设置了模板如 "@%s" 或 "_%s"。
// 
// 检查是否为空: 如果用户没有设置偏好（sub_180037360 返回 true），则函数直接返回，outString 保持为空。
// 
// 根据 scaleMode (a2) 生成后缀:
// 
// case 0: 生成 "x" (例如，"1x", "2x")
// 
// case 1: 生成 "w" (例如，"100w")
// 
// case 2: 生成 "h" (例如，"100h")
// 
// case 3: 生成 "ppi" (例如，"300ppi")
// 
// 组合字符串: 将生成的后缀（如 "x"）追加到用户偏好字符串（如 "@%s"）后面，形成最终的后缀或子文件夹名（如 "@%sx"）。
// 
// 返回结果: 调用 sub_180036B40 将最终组合好的字符串拷贝到输出参数 outString (a4) 中。
// 
// 分支二: 矢量格式和3D格式 (SVG, PDF, OBJ, etc. - cases 6-11)
// 
// 这个分支处理那些通常不涉及多重尺寸缩放的格式。
// 
// 获取预定义字符串: 函数通过一个全局偏移量表（如 off_180072050）和辅助函数 sub_180004150 直接获取一个预定义的、硬编码的 AIUnicodeString 句柄。这些字符串可能就是格式本身的名称（如 "SVG"）。
// 
// 返回结果: 调用 sub_180036B40 将获取到的预定义字符串拷贝到输出参数 outString (a4) 中。
// 
// 默认情况:
// 
// 如果 formatEnum (a1) 不匹配任何 case，函数不执行任何操作直接返回。
// 
// 资源清理:
// 
// 在函数结束前，所有临时创建的 AIUnicodeString 对象（如 v14, v15）都会被 sub_180036A90 释放，以防止内存泄漏。
// 
// 结论
// sub_180006620 是一个专门用于生成导出文件名后缀或子目录名的工具函数。它通过一个清晰的 switch 结构，为不同文件格式及其导出规则提供了不同的命名逻辑。对于需要多种尺寸的光栅格式，它能根据用户偏好动态构建后缀；对于矢量等单一尺寸格式，它则返回固定的名称。这种逻辑分离的设计使得导出命名规则的管理变得集中和高效。
void __fastcall GetExportSubfolderOrSuffix_0(char a1, int a2, __int64 a3, __int64 a4)
{
  int v6; // ebx
  int v7; // ebx
  _QWORD *v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  char **v12; // rcx
  __int64 v13; // rax
  __int64 v14; // [rsp+20h] [rbp-38h] BYREF
  _QWORD v15[3]; // [rsp+28h] [rbp-30h] BYREF

  v15[1] = -2LL;
  switch ( a1 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 12:
      unknown_libname_2(&v14);
      (*(void (__fastcall **)(_QWORD, __int64, __int64 *))(gAIUserSuite + 40))(
        *(_QWORD *)(gAIUserSuite + 40),
        3LL,
        &v14);
      if ( sub_180037360((__int64)&v14) )
        goto LABEL_13;
      if ( a2 )
      {
        v6 = a2 - 1;
        if ( v6 )
        {
          v7 = v6 - 1;
          if ( v7 )
          {
            if ( v7 != 1 )
              goto LABEL_12;
            v8 = sub_180036E50(v15, (__int64)"ppi");
            sub_180036F90((__int64)&v14, (__int64)v8);
          }
          else
          {
            v9 = sub_180036E50(v15, (__int64)"h");
            sub_180036F90((__int64)&v14, (__int64)v9);
          }
        }
        else
        {
          v10 = sub_180036E50(v15, (__int64)"w");
          sub_180036F90((__int64)&v14, (__int64)v10);
        }
      }
      else
      {
        v11 = sub_180036E50(v15, (__int64)"x");
        sub_180036F90((__int64)&v14, (__int64)v11);
      }
      sub_180036A90(v15);
LABEL_12:
      sub_180036B40(a4, (__int64)&v14);
LABEL_13:
      sub_180036A90(&v14);
      return;
    case 6:
      v12 = &off_180072050;
      goto LABEL_20;
    case 7:
      v12 = &off_180072078;
      goto LABEL_20;
    case 8:
      v12 = &off_1800720A0;
      goto LABEL_20;
    case 9:
      v12 = &off_1800720C8;
      goto LABEL_20;
    case 10:
      v12 = &off_1800720F0;
      goto LABEL_20;
    case 11:
      v12 = &off_180072118;
LABEL_20:
      v13 = sub_180004150((__int64 *)v12);
      sub_180036B40(a4, v13);
      return;
    default:
      return;
  }
}


// ===== 函数: sub_180037360 (0x180037360) =====
bool __fastcall sub_180037360(__int64 a1)
{
  __int128 *v2; // rax
  __int64 v3; // rax

  v2 = sub_180036EE0();
  v3 = sub_180007790((__int64)v2);
  return (*(unsigned __int8 (__fastcall **)(__int64))(v3 + 136))(a1) != 0;
}


// ===== 函数: sub_180032790 (0x180032790) =====
__int64 __fastcall sub_180032790(__int64 a1, __int64 a2)
{
  __int128 *v4; // rax
  __int128 *v5; // rbx
  int v6; // eax
  _QWORD *v7; // rax
  __int64 result; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v4 = sub_180032E90();
  v5 = v4;
  if ( !*((_QWORD *)v4 + 1) && qword_1800740D8 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v4 + 2),
           *((unsigned int *)v4 + 6),
           (__int64)v4 + 8);
    if ( v6 )
    {
      sub_180003F80((__int64)pExceptionObject, v6, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v5 + 28) )
    {
      v7 = sub_180012E90();
      *(_QWORD *)v5 = *v7;
      *v7 = v5;
    }
  }
  result = (*(__int64 (__fastcall **)(__int64, __int64))(*((_QWORD *)v5 + 1) + 72LL))(a2, a1);
  if ( (_DWORD)result )
  {
    sub_180003F80((__int64)pExceptionObject, result, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return result;
}


// ===== 函数: sub_180014350 (0x180014350) =====
__int64 __fastcall sub_180014350(__int64 a1)
{
  __int64 v2; // rax
  unsigned int v3; // edi
  _QWORD *v4; // rax
  __int64 v5; // rax
  const WCHAR *v6; // rcx
  BOOL DirectoryW; // ebx
  _QWORD v9[3]; // [rsp+20h] [rbp-58h] BYREF
  void **v10; // [rsp+38h] [rbp-40h] BYREF
  _BYTE v11[32]; // [rsp+40h] [rbp-38h] BYREF

  v9[2] = -2LL;
  if ( (unsigned __int8)sub_180032DF0() || (unsigned __int8)sub_180032910(a1, 0LL, 0LL, 0LL) )
    return 0LL;
  v2 = sub_180032CF0(a1, v9);
  v3 = sub_180014350(v2);
  sub_180032550(v9);
  if ( !v3 )
  {
    v4 = sub_180032BF0(a1, v9, 0);
    v5 = sub_180037230(v4, &v10);
    v6 = (const WCHAR *)(v5 + 8);
    if ( *(_QWORD *)(v5 + 32) >= 8uLL )
      v6 = *(const WCHAR **)v6;
    DirectoryW = CreateDirectoryW(v6, 0LL);
    v10 = &ai::WCHARStr::`vftable';
    unknown_libname_110(v11);
    sub_180036A90(v9);
    if ( !DirectoryW )
      return GetLastError();
  }
  return v3;
}


// ===== 函数: sub_18002DC30 (0x18002DC30) =====
_OWORD *__fastcall sub_18002DC30(__int64 *a1, _BYTE *a2, _OWORD *a3)
{
  unsigned __int64 v5; // r12
  __int64 v6; // r14
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rax
  _QWORD *v13; // rbx
  _OWORD *v14; // r15
  _BYTE *v15; // r8
  _BYTE *v16; // rdx
  void *v17; // rcx
  size_t v18; // r8
  __int64 v19; // rcx
  unsigned __int64 v22; // [rsp+78h] [rbp+10h]
  _QWORD *v24; // [rsp+88h] [rbp+20h]

  v5 = (unsigned __int64)&a2[-*a1];
  v6 = (a1[1] - *a1) >> 4;
  if ( v6 == 0xFFFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen();
  v7 = v6 + 1;
  v8 = (a1[2] - *a1) >> 4;
  v9 = v8 >> 1;
  if ( v8 > 0xFFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_25;
  v10 = v7;
  if ( v9 + v8 >= v7 )
    v10 = v9 + v8;
  if ( v10 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_25;
  v11 = 16 * v10;
  v22 = v10;
  if ( 16 * v10 >= 0x1000 )
  {
    if ( v11 + 39 >= v11 )
    {
      v12 = sub_180031D20((ai *)(v11 + 39), v9, (void **)0xFFFFFFFFFFFFFFFLL);
      if ( !v12 )
        goto LABEL_24;
      v13 = (_QWORD *)((v12 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v13 - 1) = v12;
      goto LABEL_13;
    }
LABEL_25:
    Concurrency::cancel_current_task();
  }
  if ( v11 )
  {
    v13 = (_QWORD *)sub_180031D20((ai *)(16 * v10), v9, (void **)0xFFFFFFFFFFFFFFFLL);
    v24 = v13;
    v22 = v10;
    goto LABEL_28;
  }
  v13 = 0LL;
  v22 = v10;
LABEL_13:
  v24 = v13;
LABEL_28:
  try
  {
    v14 = (_OWORD *)((char *)v13 + (v5 & 0xFFFFFFFFFFFFFFF0uLL));
    *v14 = *a3;
    v15 = (_BYTE *)a1[1];
    v16 = (_BYTE *)*a1;
    v17 = v13;
    if ( a2 == v15 )
    {
      v18 = v15 - v16;
    }
    else
    {
      memmove(v13, v16, a2 - v16);
      v17 = v14 + 1;
      v18 = a1[1] - (_QWORD)a2;
      v16 = a2;
    }
    memmove(v17, v16, v18);
  }
  catch ( ... )
  {
    sub_18001A270(a1, v24, v22);
    throw;
  }
  v19 = *a1;
  if ( *a1 )
  {
    if ( ((a1[2] - v19) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
LABEL_22:
      sub_18001AE10(v19);
      goto LABEL_23;
    }
    if ( (unsigned __int64)(v19 - *(_QWORD *)(v19 - 8) - 8) <= 0x1F )
    {
      v19 = *(_QWORD *)(v19 - 8);
      goto LABEL_22;
    }
LABEL_24:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  *a1 = (__int64)v13;
  a1[1] = (__int64)&v13[2 * v7];
  a1[2] = (__int64)&v13[v11 / 8];
  return v14;
}


// ===== 函数: sub_180031130 (0x180031130) =====
__int64 __fastcall sub_180031130(_QWORD *a1, unsigned __int8 a2)
{
  _BYTE *v2; // r8
  __int64 *v3; // rax
  unsigned __int64 v4; // r9

  v2 = (_BYTE *)qword_1800744E8;
  v3 = *(__int64 **)(qword_1800744E8 + 8);
  while ( !*((_BYTE *)v3 + 25) )
  {
    if ( *((_BYTE *)v3 + 26) >= a2 )
    {
      v2 = v3;
      v3 = (__int64 *)*v3;
    }
    else
    {
      v3 = (__int64 *)v3[2];
    }
  }
  if ( v2[25] || a2 < v2[26] )
  {
    std::_Xout_of_range("invalid map<K, T> key");
    __debugbreak();
  }
  v4 = (unsigned __int8)v2[27];
  if ( (a1[1] - *a1) / 112LL <= v4 )
    std::vector<void *>::_Xlen();
  return *a1 + 112 * v4;
}


// ===== 函数: sub_180036E50 (0x180036E50) =====
_QWORD *__fastcall sub_180036E50(_QWORD *a1, __int64 a2)
{
  __int128 *v4; // rax
  __int64 (__fastcall **v5)(_QWORD *, __int64, __int64, __int64); // rax
  __int64 v6; // r8
  int v7; // eax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  *a1 = 0LL;
  if ( a2 )
  {
    v4 = sub_180036EE0();
    v5 = (__int64 (__fastcall **)(_QWORD *, __int64, __int64, __int64))sub_180007790((__int64)v4);
    v6 = -1LL;
    do
      ++v6;
    while ( *(_BYTE *)(a2 + v6) );
    v7 = (*v5)(a1, a2, v6, 16LL);
    if ( v7 )
    {
      sub_180003F80((__int64)pExceptionObject, v7, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
  }
  return a1;
}


// ===== 函数: sub_180031C50 (0x180031C50) =====
void __fastcall sub_180031C50(__int64 a1, __int64 a2)
{
  *(double *)(a2 + 8) = *(double *)(a1 + 40) * 72.0;
  if ( !*(_BYTE *)(a1 + 48) )
    *(_DWORD *)(a2 + 20) |= 4u;
}


// ===== 函数: sub_18002DA50 (0x18002DA50) =====
unsigned __int64 __fastcall sub_18002DA50(__int64 *a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v4; // rbx
  __int64 v6; // rsi
  __int64 v7; // rax
  unsigned __int64 v8; // r15
  void **v9; // r8
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rax
  _QWORD *v13; // r14
  unsigned __int64 v14; // r13
  _QWORD *v15; // r9
  _QWORD *v16; // rcx
  _QWORD *v17; // r8
  _QWORD *v18; // rcx
  unsigned __int64 v19; // r8
  _QWORD *v20; // rbx
  _QWORD *i; // rsi
  __int64 v22; // rcx
  unsigned __int64 result; // rax
  __int64 v24; // [rsp+20h] [rbp-58h]
  unsigned __int64 v25; // [rsp+30h] [rbp-48h]
  _QWORD *v27; // [rsp+88h] [rbp+10h]

  v4 = a2;
  v6 = ((__int64)a2 - *a1) >> 3;
  v7 = (a1[1] - *a1) >> 3;
  v8 = 0x1FFFFFFFFFFFFFFFLL;
  if ( v7 == 0x1FFFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen();
  v9 = (void **)(v7 + 1);
  v24 = v7 + 1;
  v10 = (a1[2] - *a1) >> 3;
  v11 = v10 >> 1;
  if ( v10 <= 0x1FFFFFFFFFFFFFFFLL - (v10 >> 1) )
  {
    v8 = v11 + v10;
    if ( v11 + v10 < (unsigned __int64)v9 )
      v8 = v7 + 1;
  }
  v12 = sub_1800182F0((__int64)a1, v8, v9);
  v13 = (_QWORD *)v12;
  v25 = v12;
  v14 = v12 + 8 * v6;
  try
  {
    sub_180036480((_QWORD *)(v12 + 8 * v6), a3);
    v27 = (_QWORD *)v14;
    v15 = (_QWORD *)a1[1];
    v16 = (_QWORD *)*a1;
    v17 = v13;
    if ( v4 == v15 )
    {
      for ( ; v16 != v15; ++v16 )
      {
        *v17 = *v16;
        *v16 = 0LL;
        ++v17;
      }
    }
    else
    {
      for ( ; v16 != v4; ++v16 )
      {
        *v17 = *v16;
        *v16 = 0LL;
        ++v17;
      }
      v27 = v13;
      v18 = (_QWORD *)a1[1];
      if ( v4 != v18 )
      {
        v19 = v14 - (_QWORD)v4;
        do
        {
          *(_QWORD *)((char *)v4 + v19 + 8) = *v4;
          *v4++ = 0LL;
        }
        while ( v4 != v18 );
      }
    }
    v20 = (_QWORD *)*a1;
    if ( *a1 )
    {
      for ( i = (_QWORD *)a1[1]; v20 != i; ++v20 )
        sub_180036A90(v20);
      v22 = *a1;
      if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
      {
        if ( (unsigned __int64)(v22 - *(_QWORD *)(v22 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v22 = *(_QWORD *)(v22 - 8);
      }
      sub_18001AE10(v22);
    }
    *a1 = (__int64)v13;
    a1[1] = (__int64)&v13[v24];
    a1[2] = (__int64)&v13[v8];
    result = v14;
  }
  catch ( ... )
  {
    sub_180017410(v27, v14 + 8, a1);
    sub_18000E4E0(a1, v25, v8);
    throw;
  }
  return result;
}


// ===== 函数: sub_1800182F0 (0x1800182F0) =====
unsigned __int64 __fastcall sub_1800182F0(__int64 a1, unsigned __int64 a2, void **a3)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 result; // rax

  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_10;
  v3 = 8 * a2;
  if ( 8 * a2 < 0x1000 )
  {
    if ( v3 )
      return sub_180031D20((ai *)v3, a2, a3);
    else
      return 0LL;
  }
  if ( v3 + 39 < v3 )
LABEL_10:
    Concurrency::cancel_current_task();
  v4 = sub_180031D20((ai *)(v3 + 39), a2, a3);
  v5 = v4;
  if ( !v4 )
    invalid_parameter_noinfo_noreturn();
  result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(result - 8) = v5;
  return result;
}


// ===== 函数: sub_18000DE70 (0x18000DE70) =====
__int64 __fastcall sub_18000DE70(__int64 a1)
{
  return a1;
}


// ===== 函数: sub_180032AF0 (0x180032AF0) =====
_QWORD *__fastcall sub_180032AF0(__int64 a1, _QWORD *a2, unsigned __int8 a3)
{
  __int128 *v6; // rax
  __int128 *v7; // rbx
  int v8; // eax
  _QWORD *v9; // rax
  int v10; // eax
  _BYTE pExceptionObject[48]; // [rsp+30h] [rbp-48h] BYREF

  unknown_libname_2(a2);
  v6 = sub_180032E90();
  v7 = v6;
  if ( !*((_QWORD *)v6 + 1) && qword_1800740D8 )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v6 + 2),
           *((unsigned int *)v6 + 6),
           (__int64)v6 + 8);
    if ( v8 )
    {
      sub_180003F80((__int64)pExceptionObject, v8, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v7 + 28) )
    {
      v9 = sub_180012E90();
      *(_QWORD *)v7 = *v9;
      *v9 = v7;
    }
  }
  v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD *))(*((_QWORD *)v7 + 1) + 136LL))(a1, a3, a2);
  if ( v10 )
  {
    sub_180003F80((__int64)pExceptionObject, v10, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a2;
}


// ===== 函数: sub_18000E230 (0x18000E230) =====
void __fastcall sub_18000E230(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v3; // rbp
  _QWORD *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  _QWORD *v8; // rdi
  __int64 v9; // r8

  v1 = *a1;
  if ( *a1 )
  {
    v3 = a1[1];
    if ( v1 != v3 )
    {
      v4 = (_QWORD *)(v1 + 104);
      do
      {
        if ( *v4 >= 0x10uLL )
        {
          v5 = *(v4 - 3);
          if ( (unsigned __int64)(*v4 + 1LL) >= 0x1000 )
          {
            if ( (unsigned __int64)(v5 - *(_QWORD *)(v5 - 8) - 8) > 0x1F )
              goto LABEL_21;
            v5 = *(_QWORD *)(v5 - 8);
          }
          sub_18001AE10(v5);
        }
        *(v4 - 1) = 0LL;
        *v4 = 15LL;
        *((_BYTE *)v4 - 24) = 0;
        sub_18000C030((__int64)(v4 - 5));
        v6 = *(v4 - 10);
        if ( v6 )
          sub_180031DC0(v6);
        v7 = *(v4 - 11);
        if ( v7 )
          sub_180031DC0(v7);
        v8 = (_QWORD *)*(v4 - 12);
        if ( v8 )
        {
          sub_180036A90(v8 + 19);
          sub_180036A90(v8 + 17);
          sub_180036A90(v8 + 15);
          sub_180031DC0(v8);
        }
        v1 += 112LL;
        v4 += 14;
      }
      while ( v1 != v3 );
    }
    v9 = *a1;
    if ( (unsigned __int64)(112 * ((a1[2] - *a1) / 112)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v9 - *(_QWORD *)(v9 - 8) - 8) > 0x1F )
LABEL_21:
        invalid_parameter_noinfo_noreturn();
      v9 = *(_QWORD *)(v9 - 8);
    }
    sub_18001AE10(v9);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }
}


// ===== 函数: sub_180012D50 (0x180012D50) =====
void __fastcall sub_180012D50(__int64 a1, __int64 a2)
{
  _BYTE *v4; // rcx
  __int64 v5; // rax
  _BYTE *v6; // r8
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rax
  _BYTE *v14; // rcx
  _BYTE *v15; // rdx
  _BYTE v16[56]; // [rsp+20h] [rbp-68h] BYREF
  _BYTE *v17; // [rsp+58h] [rbp-30h]

  v4 = *(_BYTE **)(a1 + 56);
  if ( v4 != (_BYTE *)a1 )
  {
    v5 = *(_QWORD *)(a2 + 56);
    if ( v5 != a2 )
    {
      *(_QWORD *)(a1 + 56) = v5;
      *(_QWORD *)(a2 + 56) = v4;
      return;
    }
  }
  v17 = 0LL;
  v6 = 0LL;
  if ( v4 )
  {
    if ( v4 == (_BYTE *)a1 )
    {
      v7 = (*(__int64 (__fastcall **)(_BYTE *, _BYTE *, _QWORD))(*(_QWORD *)v4 + 8LL))(v4, v16, 0LL);
      v9 = *(_QWORD *)(a1 + 56);
      v6 = (_BYTE *)v7;
      v17 = (_BYTE *)v7;
      if ( !v9 )
        goto LABEL_10;
      LOBYTE(v8) = v9 != a1;
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v9 + 32LL))(v9, v8, v7);
      v6 = v17;
    }
    else
    {
      v6 = v4;
      v17 = v4;
    }
    *(_QWORD *)(a1 + 56) = 0LL;
  }
LABEL_10:
  v10 = *(_QWORD *)(a2 + 56);
  if ( !v10 )
    goto LABEL_17;
  if ( v10 == a2 )
  {
    *(_QWORD *)(a1 + 56) = (*(__int64 (__fastcall **)(__int64, __int64, _BYTE *))(*(_QWORD *)v10 + 8LL))(v10, a1, v6);
    v12 = *(_QWORD *)(a2 + 56);
    if ( !v12 )
    {
      v6 = v17;
      goto LABEL_17;
    }
    LOBYTE(v11) = v12 != a2;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v12 + 32LL))(v12, v11);
    v6 = v17;
  }
  else
  {
    *(_QWORD *)(a1 + 56) = v10;
  }
  *(_QWORD *)(a2 + 56) = 0LL;
LABEL_17:
  if ( v6 )
  {
    if ( v6 == v16 )
    {
      v13 = (*(__int64 (__fastcall **)(_BYTE *, __int64))(*(_QWORD *)v6 + 8LL))(v6, a2);
      v14 = v17;
      *(_QWORD *)(a2 + 56) = v13;
      if ( v14 )
      {
        v15 = v16;
        LOBYTE(v15) = v14 != v16;
        (*(void (__fastcall **)(_BYTE *, _BYTE *))(*(_QWORD *)v14 + 32LL))(v14, v15);
      }
    }
    else
    {
      *(_QWORD *)(a2 + 56) = v6;
    }
  }
}


// ===== 函数: sub_180016BF0 (0x180016BF0) =====
__int64 __fastcall sub_180016BF0(__int64 a1)
{
  return *(_QWORD *)(a1 + 392);
}


// ===== 函数: sub_180028950 (0x180028950) =====
__int64 __fastcall sub_180028950(__int64 **a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // r15
  __int64 **v5; // r14
  __int64 v6; // rdx
  void **v7; // r8
  _BYTE *v8; // r13
  __int64 *v9; // rcx
  __int64 *v10; // r8
  char v11; // r9
  __int64 *v12; // rax
  __int64 *v13; // rdx
  __int64 *v14; // rdx
  __int64 v15; // rsi
  __int64 v16; // rax
  __int64 v17; // r15
  _QWORD *v18; // r14
  _QWORD *v19; // rsi
  __int64 v20; // rax
  volatile signed __int32 *v21; // rsi
  __int64 v22; // rax
  __int64 v23; // r15
  unsigned int v24; // esi
  __int64 *v25; // r14
  __int64 *v26; // r13
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  int v30; // esi
  __int64 v31; // rsi
  _QWORD *v32; // rax
  void **v33; // r8
  volatile signed __int32 *v34; // rsi
  volatile signed __int32 *v35; // rsi
  volatile signed __int32 *v36; // rsi
  _QWORD *v37; // r14
  _QWORD *v38; // rsi
  __int64 v39; // r8
  bool v40; // si
  __int64 v41; // rbx
  __int64 v42; // rax
  __int64 v43; // rcx
  unsigned int v44; // r15d
  void (__fastcall *v45)(const char *, const char *, _QWORD *); // r14
  unsigned int v46; // eax
  __int64 (__fastcall *v47)(__int64); // rsi
  __int64 (__fastcall *v48)(__int64, __int64); // rbx
  __int64 v49; // rax
  __int64 v50; // rax
  _QWORD *v51; // rax
  __int64 v52; // rcx
  int v53; // ebx
  __int64 v54; // rdx
  void **v55; // r8
  unsigned __int64 v56; // rax
  __int64 v57; // rdx
  void **v58; // r8
  unsigned __int64 v59; // rax
  __int64 v60; // rdx
  void **v61; // r8
  unsigned __int64 v62; // rax
  __int64 v63; // rdx
  void **v64; // r8
  unsigned __int64 v65; // rax
  void **v66; // r8
  __int64 i; // rsi
  __int64 v68; // r15
  unsigned __int64 v69; // rbx
  __int64 v70; // rax
  __int64 v71; // rcx
  unsigned __int8 v72; // dl
  unsigned __int64 v73; // rax
  __int64 v74; // r14
  __int64 v75; // rbx
  __int64 v76; // rdx
  unsigned __int64 v77; // rbx
  __int64 *v78; // rax
  unsigned __int64 v79; // rcx
  unsigned __int64 v80; // rax
  void **v81; // r8
  _QWORD *v82; // rbx
  __int64 v83; // rax
  __int64 v84; // rax
  void (__fastcall *v85)(__int64 *); // rbx
  __int64 v86; // rcx
  __int64 *v87; // r14
  __int64 v88; // rdx
  int v89; // ebx
  __int64 v90; // r15
  __int64 v91; // rax
  __int64 v92; // rcx
  double v93; // xmm0_8
  unsigned int v94; // esi
  __int64 v95; // rax
  __int64 v96; // rax
  __int64 v97; // rax
  __int64 v98; // rax
  __int64 v99; // rax
  __int64 v100; // rax
  unsigned int v101; // r15d
  void (__fastcall *v102)(unsigned __int64 *); // rdx
  __int64 (__fastcall *v103)(unsigned __int64, __int64, _QWORD); // rbx
  unsigned int v104; // esi
  __int64 v105; // rax
  __int64 v106; // rax
  int j; // r13d
  char v108; // r12
  __int64 v109; // r8
  __int64 v110; // rcx
  __int64 *v111; // r12
  __int64 v112; // rbx
  __int64 v113; // rdi
  __int64 v114; // rax
  __int64 v115; // rbx
  __int64 v116; // rax
  _QWORD *v117; // rax
  __int64 v118; // r8
  void (__fastcall *v119)(__int64, _QWORD); // rsi
  __int64 (__fastcall *v120)(__int64); // rdi
  __int64 v121; // r14
  __int64 v122; // rcx
  __int64 (__fastcall *v123)(__int64, __int64); // rbx
  __int64 v124; // rax
  unsigned int v125; // ebx
  __int64 v126; // rax
  __int64 v127; // rax
  void (__fastcall *v128)(__int64 *, _QWORD); // rsi
  __int64 (__fastcall *v129)(__int64); // rbx
  __int64 (__fastcall *v130)(__int64, __int64); // rdi
  __int64 v131; // rax
  __int64 v132; // rax
  unsigned int v133; // ebx
  __int64 v134; // rcx
  __int64 v135; // r8
  _QWORD *v136; // rdi
  _QWORD *v137; // rbx
  __int64 v138; // rax
  __int64 *v139; // rbx
  __int64 v140; // r8
  _QWORD *v141; // rdi
  _QWORD *v142; // rbx
  __int64 v143; // rax
  __int64 *v144; // rbx
  unsigned int v145; // eax
  __int64 v146; // r8
  _QWORD *v147; // rdi
  _QWORD *v148; // rbx
  __int64 v149; // rax
  volatile signed __int32 *v151; // rbx
  __int64 v152; // rcx
  __int64 (__fastcall *v153)(__int64); // rdi
  __int64 v154; // rsi
  __int64 v155; // rbx
  __int64 (__fastcall *v156)(__int64); // rbx
  __int64 v157; // rax
  __int64 v158; // rax
  unsigned __int8 v159; // [rsp+40h] [rbp-698h]
  char v160; // [rsp+40h] [rbp-698h]
  _BYTE v161[7]; // [rsp+41h] [rbp-697h] BYREF
  __int64 **v162; // [rsp+48h] [rbp-690h]
  __int16 v163; // [rsp+50h] [rbp-688h] BYREF
  __int64 *v164; // [rsp+58h] [rbp-680h]
  __int64 v165; // [rsp+60h] [rbp-678h] BYREF
  __int128 v166; // [rsp+68h] [rbp-670h] BYREF
  __int64 v167; // [rsp+78h] [rbp-660h]
  unsigned __int64 v168[2]; // [rsp+80h] [rbp-658h] BYREF
  __int128 v169; // [rsp+90h] [rbp-648h] BYREF
  __int64 v170; // [rsp+A0h] [rbp-638h]
  __int64 v171; // [rsp+A8h] [rbp-630h] BYREF
  __int128 *v172; // [rsp+B0h] [rbp-628h]
  __int64 v173; // [rsp+B8h] [rbp-620h] BYREF
  __int64 v174; // [rsp+C0h] [rbp-618h] BYREF
  __int64 v175; // [rsp+C8h] [rbp-610h]
  __int64 **v176[3]; // [rsp+D0h] [rbp-608h] BYREF
  __int64 v177; // [rsp+E8h] [rbp-5F0h] BYREF
  char v178[8]; // [rsp+F0h] [rbp-5E8h] BYREF
  __int64 v179; // [rsp+F8h] [rbp-5E0h] BYREF
  __int64 v180; // [rsp+100h] [rbp-5D8h] BYREF
  __int128 v181; // [rsp+108h] [rbp-5D0h] BYREF
  __int64 v182; // [rsp+118h] [rbp-5C0h] BYREF
  _BYTE *v183; // [rsp+120h] [rbp-5B8h]
  __int64 v184; // [rsp+128h] [rbp-5B0h] BYREF
  __int64 v185; // [rsp+130h] [rbp-5A8h] BYREF
  __int64 v186; // [rsp+138h] [rbp-5A0h] BYREF
  volatile signed __int32 *v187; // [rsp+140h] [rbp-598h]
  __int128 v188; // [rsp+148h] [rbp-590h] BYREF
  __int64 v189; // [rsp+158h] [rbp-580h]
  __int64 v190; // [rsp+160h] [rbp-578h] BYREF
  int v191; // [rsp+168h] [rbp-570h]
  unsigned __int64 v192; // [rsp+170h] [rbp-568h]
  __int64 v193; // [rsp+178h] [rbp-560h]
  unsigned __int64 v194; // [rsp+180h] [rbp-558h]
  __int64 v195; // [rsp+188h] [rbp-550h]
  unsigned __int64 v196; // [rsp+190h] [rbp-548h] BYREF
  __int64 v197; // [rsp+198h] [rbp-540h]
  unsigned __int64 v198; // [rsp+1A0h] [rbp-538h] BYREF
  __int64 v199; // [rsp+1A8h] [rbp-530h]
  char v200[8]; // [rsp+1B0h] [rbp-528h] BYREF
  __int64 v201; // [rsp+1B8h] [rbp-520h]
  __int64 v202; // [rsp+1C0h] [rbp-518h]
  __int128 v203; // [rsp+1C8h] [rbp-510h] BYREF
  __int64 v204; // [rsp+1D8h] [rbp-500h] BYREF
  volatile signed __int32 *v205; // [rsp+1E0h] [rbp-4F8h]
  __int64 v206; // [rsp+1E8h] [rbp-4F0h] BYREF
  __int64 v207; // [rsp+1F0h] [rbp-4E8h] BYREF
  __int64 v208; // [rsp+1F8h] [rbp-4E0h] BYREF
  char v209; // [rsp+200h] [rbp-4D8h]
  int v210; // [rsp+204h] [rbp-4D4h]
  int v211; // [rsp+208h] [rbp-4D0h]
  int v212; // [rsp+20Ch] [rbp-4CCh]
  __int64 v213; // [rsp+210h] [rbp-4C8h] BYREF
  _QWORD v214[2]; // [rsp+218h] [rbp-4C0h] BYREF
  _QWORD v215[2]; // [rsp+228h] [rbp-4B0h] BYREF
  __int64 v216; // [rsp+238h] [rbp-4A0h]
  unsigned __int64 *v217; // [rsp+240h] [rbp-498h]
  __int64 v218; // [rsp+248h] [rbp-490h]
  _QWORD v219[2]; // [rsp+250h] [rbp-488h] BYREF
  unsigned __int64 v220[4]; // [rsp+260h] [rbp-478h] BYREF
  __int64 *v221; // [rsp+280h] [rbp-458h]
  __int64 v222; // [rsp+2A0h] [rbp-438h]
  _BYTE v223[24]; // [rsp+2A8h] [rbp-430h] BYREF
  _QWORD v224[2]; // [rsp+2C0h] [rbp-418h] BYREF
  char v225[8]; // [rsp+2D0h] [rbp-408h] BYREF
  char v226[8]; // [rsp+2D8h] [rbp-400h] BYREF
  char v227[120]; // [rsp+2E0h] [rbp-3F8h] BYREF
  char v228[104]; // [rsp+358h] [rbp-380h] BYREF
  __int64 v229[3]; // [rsp+3C0h] [rbp-318h] BYREF
  unsigned __int64 v230; // [rsp+3D8h] [rbp-300h]
  __int64 v231[3]; // [rsp+3E0h] [rbp-2F8h] BYREF
  unsigned __int64 v232; // [rsp+3F8h] [rbp-2E0h]
  __int128 v233; // [rsp+400h] [rbp-2D8h] BYREF
  unsigned __int64 v234; // [rsp+418h] [rbp-2C0h]
  unsigned __int64 v235; // [rsp+420h] [rbp-2B8h]
  _QWORD v236[4]; // [rsp+428h] [rbp-2B0h] BYREF
  __int128 v237; // [rsp+448h] [rbp-290h] BYREF
  _OWORD v238[2]; // [rsp+458h] [rbp-280h] BYREF
  char v239[8]; // [rsp+480h] [rbp-258h] BYREF
  __int64 v240[13]; // [rsp+488h] [rbp-250h] BYREF
  volatile signed __int32 *v241; // [rsp+4F0h] [rbp-1E8h]
  volatile signed __int32 *v242; // [rsp+500h] [rbp-1D8h]
  __int64 v243; // [rsp+520h] [rbp-1B8h] BYREF
  _QWORD v244[21]; // [rsp+528h] [rbp-1B0h] BYREF
  _BYTE v245[16]; // [rsp+5D0h] [rbp-108h] BYREF
  __int64 v246[20]; // [rsp+5E0h] [rbp-F8h] BYREF

  v222 = -2LL;
  v3 = a3;
  v164 = a3;
  v5 = a1;
  v162 = a1;
  v214[1] = a3;
  LODWORD(v168[0]) = 0;
  if ( *a1 == a1[1] || !*(_QWORD *)(a2 + 72) )
  {
    v151 = (volatile signed __int32 *)a3[1];
    if ( v151 )
    {
      if ( _InterlockedExchangeAdd(v151 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v151)(v151);
        if ( _InterlockedExchangeAdd(v151 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v151 + 8LL))(v151);
      }
    }
    return 0LL;
  }
  else
  {
    sub_18001A2C0(v178, *(_QWORD *)(qword_180074190 + 8), 0LL);
    (*(void (__fastcall **)(__int64))(gAIUndoSuite + 72))(1LL);
    sub_18000BC80((__int64)v219, a2);
    v200[0] = 0;
    if ( gAIDevUtilsSuite )
    {
      v201 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
      v202 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
    }
    unknown_libname_2(&v174);
    sub_180032600(&v174, v219);
    sub_18003CD20((__int64)v176, v6, v7);
    v8 = &unk_180058410;
    while ( 1 )
    {
      v183 = v8;
      if ( v8 == (_BYTE *)&unk_180058413 )
        break;
      v166 = 0LL;
      v167 = 0LL;
      v9 = (__int64 *)v221[1];
      v10 = v221;
      v11 = *((_BYTE *)v9 + 25);
      if ( !v11 )
      {
        v12 = (__int64 *)v221[1];
        do
        {
          if ( *((_BYTE *)v12 + 32) >= *v8 )
          {
            v10 = v12;
            v12 = (__int64 *)*v12;
          }
          else
          {
            v12 = (__int64 *)v12[2];
          }
        }
        while ( !*((_BYTE *)v12 + 25) );
      }
      if ( *((_BYTE *)v10 + 25) || *v8 < *((_BYTE *)v10 + 32) || (v13 = v221, v10 == v221) )
      {
        *((_QWORD *)&v166 + 1) = 0LL;
      }
      else
      {
        if ( !v11 )
        {
          do
          {
            if ( *((_BYTE *)v9 + 32) >= *v8 )
            {
              v13 = v9;
              v9 = (__int64 *)*v9;
            }
            else
            {
              v9 = (__int64 *)v9[2];
            }
          }
          while ( !*((_BYTE *)v9 + 25) );
        }
        if ( *((_BYTE *)v13 + 25) || *v8 < *((_BYTE *)v13 + 32) )
        {
          std::_Xout_of_range("invalid map<K, T> key");
LABEL_251:
          v152 = sub_180027590(v223);
          sub_180026D60(v152);
        }
        v14 = v13 + 5;
        if ( &v166 != (__int128 *)v14 )
          sub_180025F40((__int64 *)&v166, *v14, (void **)v14[1]);
        v15 = *((_QWORD *)&v166 + 1);
        sub_180026D90(&v213, v166, *((__int64 *)&v166 + 1));
        if ( v213 != v15 )
        {
          v16 = sub_1800267D0(v15, *((__int64 *)&v166 + 1), v213);
          v17 = v16;
          v18 = (_QWORD *)*((_QWORD *)&v166 + 1);
          if ( v16 != *((_QWORD *)&v166 + 1) )
          {
            v19 = (_QWORD *)(v16 + 8);
            do
            {
              sub_180036A90(v19 + 1);
              sub_180036A90(v19);
              v19 += 5;
            }
            while ( v19 - 1 != v18 );
          }
          *((_QWORD *)&v166 + 1) = v17;
          v5 = v162;
          v3 = v164;
        }
      }
      v181 = 0LL;
      v20 = v3[1];
      if ( v20 )
        _InterlockedIncrement((volatile signed __int32 *)(v20 + 8));
      *(_QWORD *)&v181 = *v3;
      v21 = (volatile signed __int32 *)v3[1];
      *((_QWORD *)&v181 + 1) = v21;
      v172 = &v181;
      v182 = a2;
      if ( (unsigned __int8)sub_18002C840(&v182) )
      {
        v235 = 0LL;
      }
      else
      {
        v236[0] = v182;
        v235 = (unsigned __int64)&off_180058F18 + 1;
      }
      v22 = *((_QWORD *)&v166 + 1);
      v175 = *((_QWORD *)&v166 + 1);
      v23 = v166;
      while ( v23 != v22 )
      {
        v24 = sub_18002BFB0(v23);
        LODWORD(v171) = 1;
        (*(void (__fastcall **)(_QWORD, const char *, __int64 *))gAIPreferenceSuite)(
          0LL,
          "AlignToPixelGridDuringExport",
          &v171);
        if ( (_DWORD)v171 != v24 )
          (*(void (__fastcall **)(_QWORD, const char *, _QWORD))(gAIPreferenceSuite + 8))(
            0LL,
            "AlignToPixelGridDuringExport",
            v24);
        v206 = *(_QWORD *)v23;
        sub_180036480(&v207, v23 + 8);
        sub_180036480(&v208, v23 + 16);
        v209 = *(_BYTE *)(v23 + 24);
        v210 = *(_DWORD *)(v23 + 28);
        v211 = *(_DWORD *)(v23 + 32);
        v212 = *(_DWORD *)(v23 + 36);
        if ( v210 == 3 )
          sub_180006E90((__int64)&v206);
        sub_180006AB0((__int64)&v206);
        sub_180039170((__int64)v239);
        sub_18002B190((__int64)&v206, (__int64)v239);
        v25 = *v5;
        v26 = v162[1];
        while ( v25 != v26 )
        {
          v27 = sub_180016BE0(qword_180074190);
          v28 = sub_18001D820(v27);
          sub_180021470(v28, &v186);
          if ( v186 )
          {
            unknown_libname_2(&v165);
            v29 = sub_180032310(v186, &v179);
            v30 = BuildExportFilePath(v29, v23, &v174, &v165);
            sub_180036A90(&v179);
            if ( v30 )
            {
              v31 = v181;
              if ( (_QWORD)v181 )
              {
                v32 = sub_180032AF0((__int64)&v165, &v180, 0);
                sub_180017CF0(v31, (__int64)v32);
                sub_180036A90(&v180);
              }
            }
            else
            {
              if ( !v235 )
                goto LABEL_251;
              if ( (*(unsigned __int8 (__fastcall **)(_QWORD *, __int64 *))((v235 & 0xFFFFFFFFFFFFFFFEuLL) + 8))(
                     v236,
                     &v165) )
              {
                sub_180039540((__int64)v239, &v165);
                v243 = *v25;
                sub_1800271C0((__int64)v244, (__int64)v239);
                sub_18003CDB0(v245, &v243);
                sub_18003D250(v176, (__int64)v245, v33);
                sub_180027890(v246);
                sub_180027890(v244);
              }
            }
            sub_180032550(&v165);
          }
          v34 = v187;
          if ( v187 && _InterlockedExchangeAdd(v187 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v34)(v34);
            if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v34 + 8LL))(v34);
          }
          ++v25;
        }
        v35 = v242;
        if ( v242 )
        {
          if ( _InterlockedExchangeAdd(v242 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v35)(v35);
            if ( _InterlockedExchangeAdd(v35 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v35 + 8LL))(v35);
          }
        }
        v36 = v241;
        if ( v241 )
        {
          if ( _InterlockedExchangeAdd(v241 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v36)(v36);
            if ( _InterlockedExchangeAdd(v36 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v36 + 8LL))(v36);
          }
        }
        sub_180032550(v240);
        sub_180036A90(&v208);
        sub_180036A90(&v207);
        LODWORD(v173) = 1;
        (*(void (__fastcall **)(_QWORD, const char *, __int64 *))gAIPreferenceSuite)(
          0LL,
          "AlignToPixelGridDuringExport",
          &v173);
        if ( (_DWORD)v171 != (_DWORD)v173 )
          (*(void (__fastcall **)(_QWORD, const char *))(gAIPreferenceSuite + 8))(0LL, "AlignToPixelGridDuringExport");
        v23 += 40LL;
        v21 = (volatile signed __int32 *)*((_QWORD *)&v181 + 1);
        v22 = v175;
        v5 = v162;
      }
      if ( v21 )
      {
        if ( _InterlockedExchangeAdd(v21 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v21)(v21);
          if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v21 + 8LL))(v21);
        }
      }
      if ( v235 && (v235 & 1) == 0 && *(_QWORD *)(v235 & 0xFFFFFFFFFFFFFFFEuLL) )
        (*(void (__fastcall **)(_QWORD *, _QWORD *, __int64))(v235 & 0xFFFFFFFFFFFFFFFEuLL))(v236, v236, 2LL);
      if ( (_QWORD)v166 )
      {
        v37 = (_QWORD *)*((_QWORD *)&v166 + 1);
        if ( (_QWORD)v166 != *((_QWORD *)&v166 + 1) )
        {
          v38 = (_QWORD *)(v166 + 8);
          do
          {
            sub_180036A90(v38 + 1);
            sub_180036A90(v38);
            v38 += 5;
          }
          while ( v38 - 1 != v37 );
        }
        v39 = v166;
        if ( (unsigned __int64)(40 * ((v167 - (__int64)v166) / 40)) >= 0x1000 )
        {
          v39 = *(_QWORD *)(v166 - 8);
          if ( (unsigned __int64)(v166 - v39 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v39);
      }
      v8 = v183 + 1;
      v5 = v162;
      v3 = v164;
    }
    v40 = (unsigned int)sub_18003D590((__int64)v176) != 0;
    v41 = *v3;
    v203 = 0LL;
    v42 = v3[1];
    if ( v42 )
      _InterlockedIncrement((volatile signed __int32 *)(v42 + 8));
    v203 = *(_OWORD *)v3;
    sub_18003D5A0(v176, &v203, (_QWORD *)(v41 + 112));
    v43 = *(_QWORD *)(v41 + 112);
    if ( v43 && (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v43 + 24LL))(v43) )
    {
      v44 = 1398034256;
    }
    else
    {
      if ( v40 && gAIAdobePIPSuite )
      {
        v45 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
        v46 = gAIDevUtilsSuite;
        if ( gAIDevUtilsSuite )
        {
          v47 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
          v48 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
          v49 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v202);
          v50 = v48(v49, v201);
          v46 = v47(v50);
        }
        v51 = sub_18002CA00(&v233, v46);
        if ( v51[3] >= 0x10uLL )
          v51 = (_QWORD *)*v51;
        v45("Smart Export", "TimeOnMainThreadForAIDEFormats", v51);
        if ( v234 >= 0x10 )
        {
          v52 = v233;
          if ( v234 + 1 >= 0x1000 )
          {
            v52 = *(_QWORD *)(v233 - 8);
            if ( (unsigned __int64)(v233 - v52 - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
          }
          sub_18001AE10(v52);
        }
      }
      v44 = v168[0];
    }
    if ( gAIDevUtilsSuite )
    {
      v201 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
      v202 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
    }
    v169 = 0LL;
    v170 = 0LL;
    if ( v44 || (sub_18002B4E0(v219, &v169), (_QWORD)v169 == *((_QWORD *)&v169 + 1)) )
    {
      v144 = v164;
      v145 = sub_180017D30(*v164);
      if ( !v44 && v145 )
        v44 = v145;
      v146 = v169;
      if ( (_QWORD)v169 )
      {
        v147 = (_QWORD *)*((_QWORD *)&v169 + 1);
        if ( (_QWORD)v169 != *((_QWORD *)&v169 + 1) )
        {
          v148 = (_QWORD *)(v169 + 8);
          do
          {
            sub_180036A90(v148 + 1);
            sub_180036A90(v148);
            v148 += 5;
          }
          while ( v148 - 1 != v147 );
          v146 = v169;
          v144 = v164;
        }
        v149 = v146;
        if ( (unsigned __int64)(40 * ((v170 - v146) / 40)) >= 0x1000 )
        {
          v146 = *(_QWORD *)(v146 - 8);
          if ( (unsigned __int64)(v149 - v146 - 8) > 0x1F )
            goto LABEL_242;
        }
        sub_18001AE10(v146);
        v169 = 0LL;
        v170 = 0LL;
      }
      sub_1800261E0((__int64)v176, (__int64)v176, (__int64)v176[0][1]);
      sub_18001AE10((__int64)v176[0]);
      sub_180032550(&v174);
      sub_18000C4E0(v219);
      sub_18001A320(v178);
      sub_180004840((__int64)v144);
      return v44;
    }
    else
    {
      v53 = *(_DWORD *)(a2 + 8);
      sub_180032460(&v190, (__int64)&v174);
      v191 = v53;
      v192 = 0LL;
      v193 = 0LL;
      v56 = sub_180031D20((ai *)0x28, v54, v55);
      *(_QWORD *)v56 = v56;
      *(_QWORD *)(v56 + 8) = v56;
      *(_QWORD *)(v56 + 16) = v56;
      *(_WORD *)(v56 + 24) = 257;
      v192 = v56;
      v194 = 0LL;
      v195 = 0LL;
      v59 = sub_180031D20((ai *)0x28, v57, v58);
      *(_QWORD *)v59 = v59;
      *(_QWORD *)(v59 + 8) = v59;
      *(_QWORD *)(v59 + 16) = v59;
      *(_WORD *)(v59 + 24) = 257;
      v194 = v59;
      v196 = 0LL;
      v197 = 0LL;
      v62 = sub_180031D20((ai *)0x40, v60, v61);
      *(_QWORD *)v62 = v62;
      *(_QWORD *)(v62 + 8) = v62;
      *(_QWORD *)(v62 + 16) = v62;
      *(_WORD *)(v62 + 24) = 257;
      v196 = v62;
      v198 = 0LL;
      v199 = 0LL;
      v65 = sub_180031D20((ai *)0x20, v63, v64);
      *(_QWORD *)v65 = v65;
      *(_QWORD *)(v65 + 8) = v65;
      *(_QWORD *)(v65 + 16) = v65;
      *(_WORD *)(v65 + 24) = 257;
      v198 = v65;
      v68 = *((_QWORD *)&v169 + 1);
      for ( i = v169; i != v68; i += 40LL )
      {
        v69 = v196;
        v70 = *(_QWORD *)(v196 + 8);
        *(_QWORD *)&v166 = v70;
        DWORD2(v166) = 0;
        v71 = v196;
        if ( !*(_BYTE *)(v70 + 25) )
        {
          v72 = *(_BYTE *)(i + 24);
          do
          {
            *(_QWORD *)&v166 = v70;
            if ( *(_BYTE *)(v70 + 32) >= v72 )
            {
              DWORD2(v166) = 1;
              v71 = v70;
              v70 = *(_QWORD *)v70;
            }
            else
            {
              DWORD2(v166) = 0;
              v70 = *(_QWORD *)(v70 + 16);
            }
          }
          while ( !*(_BYTE *)(v70 + 25) );
        }
        if ( *(_BYTE *)(v71 + 25) || *(_BYTE *)(i + 24) < *(_BYTE *)(v71 + 32) )
        {
          if ( v197 == 0x3FFFFFFFFFFFFFFLL )
            std::vector<void *>::_Xlen();
          v215[1] = &v196;
          v216 = 0LL;
          v73 = sub_180031D20((ai *)0x40, 0x3FFFFFFFFFFFFFFLL, v66);
          *(_BYTE *)(v73 + 32) = *(_BYTE *)(i + 24);
          *(_QWORD *)(v73 + 40) = 0LL;
          *(_QWORD *)(v73 + 48) = 0LL;
          *(_QWORD *)(v73 + 56) = 0LL;
          *(_QWORD *)v73 = v69;
          *(_QWORD *)(v73 + 8) = v69;
          *(_QWORD *)(v73 + 16) = v69;
          *(_WORD *)(v73 + 24) = 0;
          v216 = 0LL;
          v233 = v166;
          v71 = sub_180013B10(&v196, (__int64)&v233, v73);
        }
        v74 = v71 + 40;
        v75 = *(_QWORD *)(v71 + 48);
        if ( v75 == *(_QWORD *)(v71 + 56) )
        {
          sub_1800183E0(v71 + 40, *(_QWORD *)(v71 + 48), i);
        }
        else
        {
          v172 = *(__int128 **)(v71 + 48);
          *(_QWORD *)v75 = *(_QWORD *)i;
          sub_180036480((_QWORD *)(v75 + 8), i + 8);
          sub_180036480((_QWORD *)(v75 + 16), i + 16);
          *(_BYTE *)(v75 + 24) = *(_BYTE *)(i + 24);
          *(_DWORD *)(v75 + 28) = *(_DWORD *)(i + 28);
          *(_DWORD *)(v75 + 32) = *(_DWORD *)(i + 32);
          *(_DWORD *)(v75 + 36) = *(_DWORD *)(i + 36);
          *(_QWORD *)(v74 + 8) += 40LL;
        }
        v77 = v198;
        v78 = *(__int64 **)(v198 + 8);
        *(_QWORD *)&v166 = v78;
        DWORD2(v166) = 0;
        v79 = v198;
        if ( !*((_BYTE *)v78 + 25) )
        {
          v76 = *(unsigned __int8 *)(i + 24);
          do
          {
            *(_QWORD *)&v166 = v78;
            if ( *((_BYTE *)v78 + 26) >= (unsigned __int8)v76 )
            {
              DWORD2(v166) = 1;
              v79 = (unsigned __int64)v78;
              v78 = (__int64 *)*v78;
            }
            else
            {
              DWORD2(v166) = 0;
              v78 = (__int64 *)v78[2];
            }
          }
          while ( !*((_BYTE *)v78 + 25) );
        }
        if ( *(_BYTE *)(v79 + 25) || *(_BYTE *)(i + 24) < *(_BYTE *)(v79 + 26) )
        {
          if ( v199 == 0x7FFFFFFFFFFFFFFLL )
            std::vector<void *>::_Xlen();
          v217 = &v198;
          v218 = 0LL;
          v80 = sub_180031D20((ai *)0x20, v76, v66);
          *(_BYTE *)(v80 + 26) = *(_BYTE *)(i + 24);
          *(_QWORD *)v80 = v77;
          *(_QWORD *)(v80 + 8) = v77;
          *(_QWORD *)(v80 + 16) = v77;
          *(_WORD *)(v80 + 24) = 0;
          v218 = 0LL;
          v233 = v166;
          sub_180013B10(&v198, (__int64)&v233, v80);
        }
      }
      sub_180018A30(v219, &v190);
      sub_18000C4E0(&v190);
      sub_18000BB30(v168, a2 + 16, v81);
      v82 = (_QWORD *)v220[0];
      sub_18000B770((__int64)v220, (__int64)v220, *(_QWORD *)(v220[0] + 8));
      v82[1] = v82;
      *v82 = v82;
      v82[2] = v82;
      v220[1] = 0LL;
      sub_18000AF50(v220, v168, v159);
      sub_18000B770((__int64)v168, (__int64)v168, *(_QWORD *)(v168[0] + 8));
      sub_18001AE10(v168[0]);
      v83 = sub_180016BE0(qword_180074190);
      v175 = sub_18001D820(v83);
      v160 = 1;
      if ( gAIDevUtilsSuite )
        v173 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
      else
        v173 = (__int64)v172;
      if ( sub_18000D970() && (v84 = gAISmartExportUISuite) != 0 )
      {
        if ( gAIDevUtilsSuite )
        {
          v165 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
          v84 = gAISmartExportUISuite;
        }
        else
        {
          v165 = v175;
        }
        v160 = 0;
        v85 = *(void (__fastcall **)(__int64 *))(v84 + 24);
        v229[0] = 0LL;
        v229[2] = 0LL;
        v230 = 15LL;
        sub_180006EF0(v229, "ASSET EXPORT", 0xCuLL);
        v85(v229);
        if ( v230 >= 0x10 )
        {
          v86 = v229[0];
          if ( v230 + 1 >= 0x1000 )
          {
            v86 = *(_QWORD *)(v229[0] - 8);
            if ( (unsigned __int64)(v229[0] - v86 - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
          }
          sub_18001AE10(v86);
        }
      }
      else
      {
        v165 = v175;
      }
      v185 = 0LL;
      v177 = 0LL;
      v188 = 0LL;
      v171 = 0LL;
      v189 = 0LL;
      v87 = (__int64 *)v162;
      v88 = v162[1] - *v162;
      if ( v88 )
      {
        sub_180026840(&v188, v88, v161);
        v171 = v189;
      }
      v89 = 0;
      v90 = v188;
      while ( v89 < (unsigned __int64)((v87[1] - *v87) >> 3) )
      {
        v91 = sub_180027CA0(v161);
        sub_1800064F0(v92, v91, v90 + 8LL * v89++);
        v87 = (__int64 *)v162;
      }
      v237 = 0LL;
      memset(v238, 0, sizeof(v238));
      v93 = sub_180037800();
      v163 = -1;
      v94 = (*(__int64 (__fastcall **)(__int64 *))(gAIDocumentSuite + 160))(&v185);
      if ( !v94 )
      {
        v95 = sub_180008580(&unk_1800743A0);
        v96 = sub_180007790(v95);
        v94 = (*(__int64 (__fastcall **)(_OWORD *))(v96 + 88))(v238);
        if ( !v94 )
        {
          (*(void (__fastcall **)(__int128 *))(gAIDocumentSuite + 192))(&v237);
          v94 = (*(__int64 (__fastcall **)(__int16 *))(gAIDocumentSuite + 40))(&v163);
          if ( !v94 )
          {
            v94 = sub_18002CC60(&v177);
            if ( v93 > 1.0 && v94 == 0 )
            {
              v97 = sub_180008580(&unk_1800743A0);
              v98 = sub_180007790(v97);
              v94 = (*(__int64 (**)(void))(v98 + 104))();
            }
            if ( !v94 )
            {
              v99 = sub_180008580(&unk_1800743A0);
              v100 = sub_180007790(v99);
              v101 = (*(__int64 (__fastcall **)(_OWORD *))(v100 + 96))(v238);
              if ( !v101 )
              {
                v101 = (*(__int64 (__fastcall **)(__int128 *))(gAIDocumentSuite + 32))(&v237);
                if ( !v101 )
                {
                  v168[0] = 0LL;
                  v102 = *(void (__fastcall **)(unsigned __int64 *))(gAIDocumentSuite + 320);
                  v168[0] = 0LL;
                  v102(v168);
                  v103 = *(__int64 (__fastcall **)(unsigned __int64, __int64, _QWORD))(gAIDictionarySuite + 232);
                  v104 = v163;
                  v105 = qword_1800743B0;
                  if ( !qword_1800743B0 )
                  {
                    v105 = (*(__int64 (__fastcall **)(const char *))(gAIDictionarySuite + 64))("-ExportKeyForRulerUnits");
                    qword_1800743B0 = v105;
                  }
                  v101 = v103(v168[0], v105, v104);
                  if ( v168[0] )
                  {
                    v106 = sub_18001E230();
                    (*(void (__fastcall **)(unsigned __int64))(v106 + 8))(v168[0]);
                  }
                }
              }
              v184 = 0LL;
              if ( v101 || (v101 = (*(__int64 (__fastcall **)(__int64 *))(gAILayerSuite + 16))(&v184)) != 0 )
              {
                v111 = v164;
                sub_180028220(v87, a2, v164);
              }
              else
              {
                for ( j = 0; j < (unsigned __int64)((v87[1] - *v87) >> 3); ++j )
                {
                  v108 = 1;
                  v109 = gAIDevUtilsSuite;
                  if ( gAIDevUtilsSuite )
                  {
                    v180 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
                    v109 = gAIDevUtilsSuite;
                  }
                  if ( dword_180074078 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer
                                                     + (unsigned int)TlsIndex)
                                                   + 4LL) )
                  {
                    Init_thread_header(&dword_180074078);
                    if ( dword_180074078 == -1 )
                    {
                      v153 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 120);
                      v154 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 232))();
                      v155 = (*(__int64 (__fastcall **)(_QWORD))(gAIDevUtilsSuite + 120))(0LL);
                      if ( v153(v154) == v155 )
                      {
                        v158 = 0LL;
                      }
                      else
                      {
                        v156 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 120);
                        v157 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 232))();
                        v158 = v156(v157);
                      }
                      qword_180074070 = v158;
                      Init_thread_footer(&dword_180074078);
                    }
                    v109 = gAIDevUtilsSuite;
                  }
                  if ( qword_180074070 )
                  {
                    if ( v109 )
                      v179 = (*(__int64 (**)(void))(v109 + 56))();
                    v108 = 0;
                  }
                  sub_180021470(v175, &v204);
                  v110 = sub_180032310(v204, v214);
                  v101 = sub_18002A600(
                           v185,
                           v177,
                           v184,
                           (unsigned int)v219,
                           *(_QWORD *)(v188 + 8LL * j),
                           v110,
                           (__int64)v164,
                           (__int64)v200);
                  sub_180036A90(v214);
                  if ( v101 == 1398034256 )
                  {
                    if ( v205 )
                      sub_18000DB90(v205);
                    break;
                  }
                  if ( sub_18000D970() && gAISmartExportUISuite )
                  {
                    sub_180026F00(v224, 1LL);
                    v115 = sub_180013D90(v225, "Export Asset with name - ");
                    v116 = sub_180032310(v204, v215);
                    v117 = sub_180037530(v116, v229, 0);
                    v118 = v117[2];
                    if ( v117[3] >= 0x10uLL )
                      v117 = (_QWORD *)*v117;
                    sub_180016310(v115, v117, v118);
                    sub_1800047E0(v229);
                    sub_180036A90(v215);
                    v119 = *(void (__fastcall **)(__int64, _QWORD))(gAISmartExportUISuite + 16);
                    if ( gAIDevUtilsSuite )
                    {
                      v120 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
                      v121 = v180;
                      v122 = v180;
                      if ( !v108 )
                      {
                        v123 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
                        v124 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v179);
                        v122 = v123(v124, v121);
                      }
                      v125 = v120(v122);
                    }
                    else
                    {
                      v125 = 0;
                    }
                    v126 = sub_18002C930(v224, v229);
                    v119(v126, v125);
                    sub_1800047E0(v229);
                    *(_QWORD *)((char *)v224 + *(int *)(v224[0] + 4LL)) = &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
                    *(_DWORD *)&v223[*(int *)(v224[0] + 4LL) + 20] = *(_DWORD *)(v224[0] + 4LL) - 152;
                    sub_180012EA0(v226);
                    std::iostream::~basic_iostream<char,std::char_traits<char>>(v227);
                    std::ios::~ios<char,std::char_traits<char>>(v228);
                  }
                  v127 = sub_180027CA0(v161);
                  sub_180004B80(v127);
                  if ( v205 )
                    sub_18000DB90(v205);
                  v87 = (__int64 *)v162;
                }
                v87 = (__int64 *)v162;
                v111 = v164;
              }
              sub_18002CEB0(&v177);
              v112 = *v87;
              v113 = v87[1];
              while ( v112 != v113 )
              {
                v114 = sub_180027CA0(v161);
                sub_180004B80(v114);
                v112 += 8LL;
              }
              if ( sub_18000D970() && gAISmartExportUISuite )
              {
                v128 = *(void (__fastcall **)(__int64 *, _QWORD))(gAISmartExportUISuite + 16);
                if ( gAIDevUtilsSuite )
                {
                  v129 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
                  if ( v160 )
                  {
                    v132 = v173;
                  }
                  else
                  {
                    v130 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
                    v131 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v165);
                    v132 = v130(v131, v173);
                  }
                  v133 = v129(v132);
                }
                else
                {
                  v133 = 0;
                }
                v231[0] = 0LL;
                v231[2] = 0LL;
                v232 = 15LL;
                sub_180006EF0(v231, "\nExporting All Assets", 0x15uLL);
                v128(v231, v133);
                if ( v232 >= 0x10 )
                {
                  v134 = v231[0];
                  if ( v232 + 1 >= 0x1000 )
                  {
                    v134 = *(_QWORD *)(v231[0] - 8);
                    if ( (unsigned __int64)(v231[0] - v134 - 8) > 0x1F )
                      invalid_parameter_noinfo_noreturn();
                  }
                  sub_18001AE10(v134);
                }
              }
              if ( (_QWORD)v188 )
                sub_18000E4E0(&v188, v188, (v171 - (__int64)v188) >> 3);
              v135 = v169;
              if ( !(_QWORD)v169 )
                goto LABEL_220;
              v136 = (_QWORD *)*((_QWORD *)&v169 + 1);
              if ( (_QWORD)v169 != *((_QWORD *)&v169 + 1) )
              {
                v137 = (_QWORD *)(v169 + 8);
                do
                {
                  sub_180036A90(v137 + 1);
                  sub_180036A90(v137);
                  v137 += 5;
                }
                while ( v137 - 1 != v136 );
                v135 = v169;
              }
              v138 = v135;
              if ( (unsigned __int64)(40 * ((v170 - v135) / 40)) < 0x1000
                || (v135 = *(_QWORD *)(v135 - 8), (unsigned __int64)(v138 - v135 - 8) <= 0x1F) )
              {
                sub_18001AE10(v135);
                v169 = 0LL;
                v170 = 0LL;
LABEL_220:
                sub_1800261E0((__int64)v176, (__int64)v176, (__int64)v176[0][1]);
                sub_18001AE10((__int64)v176[0]);
                sub_180032550(&v174);
                sub_18000C4E0(v219);
                sub_18001A320(v178);
                sub_180004840((__int64)v111);
                return v101;
              }
LABEL_242:
              invalid_parameter_noinfo_noreturn();
            }
          }
        }
      }
      v139 = v164;
      sub_180028220(v87, a2, v164);
      if ( v90 )
        sub_18000E4E0(&v188, v90, (v171 - v90) >> 3);
      v140 = v169;
      if ( (_QWORD)v169 )
      {
        v141 = (_QWORD *)*((_QWORD *)&v169 + 1);
        if ( (_QWORD)v169 != *((_QWORD *)&v169 + 1) )
        {
          v142 = (_QWORD *)(v169 + 8);
          do
          {
            sub_180036A90(v142 + 1);
            sub_180036A90(v142);
            v142 += 5;
          }
          while ( v142 - 1 != v141 );
          v140 = v169;
          v139 = v164;
        }
        v143 = v140;
        if ( (unsigned __int64)(40 * ((v170 - v140) / 40)) >= 0x1000 )
        {
          v140 = *(_QWORD *)(v140 - 8);
          if ( (unsigned __int64)(v143 - v140 - 8) > 0x1F )
            goto LABEL_242;
        }
        sub_18001AE10(v140);
        v169 = 0LL;
        v170 = 0LL;
      }
      sub_1800261E0((__int64)v176, (__int64)v176, (__int64)v176[0][1]);
      sub_18001AE10((__int64)v176[0]);
      sub_180032550(&v174);
      sub_18000C4E0(v219);
      sub_18001A320(v178);
      sub_180004840((__int64)v139);
      return v94;
    }
  }
}


// ===== 函数: sub_18002CA00 (0x18002CA00) =====
_QWORD *__fastcall sub_18002CA00(_QWORD *a1, unsigned int a2)
{
  _BYTE *v4; // r9
  _BYTE v6[3]; // [rsp+45h] [rbp-13h] BYREF

  v4 = v6;
  do
  {
    *--v4 = a2 % 0xA + 48;
    a2 /= 0xAu;
  }
  while ( a2 );
  *a1 = 0LL;
  a1[2] = 0LL;
  a1[3] = 15LL;
  *(_BYTE *)a1 = 0;
  if ( v4 != v6 )
    sub_180006EF0(a1, v4, v6 - v4);
  return a1;
}


// ===== 函数: sub_180037800 (0x180037800) =====
double sub_180037800()
{
  __int128 *v0; // rax
  __int128 *v1; // rbx
  _QWORD *v2; // rax
  __int128 *v3; // rax
  __int64 v4; // rax
  double v6; // [rsp+40h] [rbp+8h] BYREF

  v6 = 1.0;
  v0 = sub_180007F60();
  v1 = v0;
  if ( !*((_QWORD *)v0 + 1) && qword_1800740D8 )
  {
    if ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v0 + 2),
           *((unsigned int *)v0 + 6),
           (__int64)v0 + 8) )
    {
      *((_QWORD *)v1 + 1) = 0LL;
    }
    else if ( !*((_BYTE *)v1 + 28) )
    {
      v2 = sub_180012E90();
      *(_QWORD *)v1 = *v2;
      *v2 = v1;
    }
  }
  if ( *((_QWORD *)v1 + 1) )
  {
    v3 = sub_180007F60();
    v4 = sub_180007790((__int64)v3);
    (*(void (__fastcall **)(double *))(v4 + 624))(&v6);
  }
  return v6;
}


// ===== 函数: sub_180007F60 (0x180007F60) =====
__int128 *sub_180007F60()
{
  _QWORD *v1; // rax

  if ( dword_180073F38 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180073F18;
  Init_thread_header(&dword_180073F38);
  if ( dword_180073F38 != -1 )
    return &xmmword_180073F18;
  xmmword_180073F18 = 0LL;
  qword_180073F28 = (__int64)"AI Document Suite";
  dword_180073F30 = 21;
  byte_180073F34 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180073F18 = *v1;
  *v1 = &xmmword_180073F18;
  Init_thread_footer(&dword_180073F38);
  return &xmmword_180073F18;
}


// ===== 函数: sub_18002A600 (0x18002A600) =====
__int64 __fastcall sub_18002A600(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int128 *a7,
        __int64 a8)
{
  unsigned int v11; // ebx
  unsigned int v13; // r15d
  __int64 v14; // rdx
  void **v15; // r8
  BOOL v16; // r12d
  char v17; // bl
  __int64 v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rdi
  void (__fastcall *v21)(_QWORD *, _QWORD); // r13
  __int64 (__fastcall *v22)(__int64); // r14
  __int64 (__fastcall *v23)(__int64, __int64); // rbx
  __int64 v24; // rax
  unsigned int v25; // ebx
  char *v26; // rax
  __int64 v27; // rcx
  char v28; // r13
  __int64 v29; // rsi
  __int64 v30; // r14
  __int128 *v31; // rcx
  __int64 v32; // rax
  volatile signed __int32 *v33; // rbx
  void (__fastcall *v34)(_QWORD *, _QWORD); // r12
  __int64 (__fastcall *v35)(__int64); // rdi
  __int64 (__fastcall *v36)(__int64, __int64); // rbx
  __int64 v37; // rax
  unsigned int v38; // ebx
  char *v39; // rax
  __int64 v40; // rcx
  __int64 v41; // [rsp+20h] [rbp-81h] BYREF
  __int64 v42; // [rsp+28h] [rbp-79h] BYREF
  __int64 v43; // [rsp+30h] [rbp-71h]
  __int128 v44; // [rsp+38h] [rbp-69h] BYREF
  __int128 *v45; // [rsp+48h] [rbp-59h]
  __int64 v46; // [rsp+50h] [rbp-51h]
  __int64 v47; // [rsp+58h] [rbp-49h]
  __int64 v48; // [rsp+60h] [rbp-41h]
  __int64 v49; // [rsp+68h] [rbp-39h]
  _QWORD v50[2]; // [rsp+70h] [rbp-31h] BYREF
  __int64 v51; // [rsp+80h] [rbp-21h]
  unsigned __int64 v52; // [rsp+88h] [rbp-19h]

  v49 = -2LL;
  v48 = a4;
  v43 = a3;
  v41 = a5;
  v46 = a6;
  v45 = a7;
  v47 = a8;
  v42 = 0LL;
  (*(void (__fastcall **)(__int64))(gAIUndoSuite + 136))(1LL);
  v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(gAILayerSuite + 48))(a3, 5LL, &v42);
  (*(void (__fastcall **)(_QWORD))(gAIUndoSuite + 136))(0LL);
  if ( v11 )
    return v11;
  v13 = (*(__int64 (__fastcall **)(__int64))(gAILayerSuite + 24))(v42);
  v16 = sub_18000D970() != 0;
  v17 = 1;
  v18 = gAIDevUtilsSuite;
  if ( gAIDevUtilsSuite )
  {
    v19 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
    v18 = gAIDevUtilsSuite;
  }
  else
  {
    v19 = v43;
  }
  if ( v16 )
  {
    if ( v18 )
    {
      v20 = (*(__int64 (**)(void))(v18 + 56))();
      v18 = gAIDevUtilsSuite;
    }
    else
    {
      v20 = v41;
    }
    v17 = 0;
  }
  else
  {
    v20 = v41;
  }
  if ( !v13 )
  {
    v13 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD))(gAIDocumentListPrivateSuite + 40))(
            a1,
            a2,
            v41,
            0LL);
    if ( !v13 )
      v13 = sub_18002CEE0();
    v18 = gAIDevUtilsSuite;
  }
  if ( v16 && gAISmartExportUISuite )
  {
    v21 = *(void (__fastcall **)(_QWORD *, _QWORD))(gAISmartExportUISuite + 16);
    if ( v18 )
    {
      v22 = *(__int64 (__fastcall **)(__int64))(v18 + 80);
      if ( !v17 )
      {
        v23 = *(__int64 (__fastcall **)(__int64, __int64))(v18 + 64);
        v24 = (*(__int64 (__fastcall **)(__int64))(v18 + 112))(v20);
        v19 = v23(v24, v19);
      }
      v25 = v22(v19);
    }
    else
    {
      v25 = 0;
    }
    v50[0] = 0LL;
    v51 = 0LL;
    v52 = 15LL;
    v26 = (char *)sub_180031D20((ai *)0x20, v14, v15);
    v51 = 22LL;
    v52 = 31LL;
    strcpy(v26, "Copy Asset to Document");
    v50[0] = v26;
    v21(v50, v25);
    v14 = v52;
    if ( v52 >= 0x10 )
    {
      v27 = v50[0];
      if ( v52 + 1 >= 0x1000 )
      {
        v27 = *(_QWORD *)(v50[0] - 8LL);
        if ( (unsigned __int64)(v50[0] - v27 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18001AE10(v27);
    }
    v18 = gAIDevUtilsSuite;
  }
  v28 = 1;
  if ( v18 )
  {
    v29 = (*(__int64 (**)(void))(v18 + 152))();
    v18 = gAIDevUtilsSuite;
  }
  else
  {
    v29 = v43;
  }
  if ( v16 )
  {
    if ( v18 )
    {
      v30 = (*(__int64 (**)(void))(v18 + 56))();
      v18 = gAIDevUtilsSuite;
    }
    else
    {
      v30 = v41;
    }
    v28 = 0;
  }
  else
  {
    v30 = v41;
  }
  if ( !v13 )
  {
    v44 = 0LL;
    v31 = v45;
    v32 = *((_QWORD *)v45 + 1);
    if ( v32 )
      _InterlockedIncrement((volatile signed __int32 *)(v32 + 8));
    v44 = *v31;
    v45 = &v44;
    LOBYTE(v31) = 1;
    (*(void (__fastcall **)(__int128 *))(qword_180074348 + 56))(v31);
    sub_180036480(&v41, v46);
    v13 = sub_1800233C0((__int64)&v41, v48, (__int64 *)&v44, v47);
    sub_180036A90(&v41);
    v33 = (volatile signed __int32 *)*((_QWORD *)&v44 + 1);
    if ( *((_QWORD *)&v44 + 1) )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v44 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v33)(v33);
        if ( _InterlockedExchangeAdd(v33 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v33 + 8LL))(v33);
      }
    }
    v18 = gAIDevUtilsSuite;
  }
  if ( v16 && gAISmartExportUISuite )
  {
    v34 = *(void (__fastcall **)(_QWORD *, _QWORD))(gAISmartExportUISuite + 16);
    if ( v18 )
    {
      v35 = *(__int64 (__fastcall **)(__int64))(v18 + 80);
      if ( !v28 )
      {
        v36 = *(__int64 (__fastcall **)(__int64, __int64))(v18 + 64);
        v37 = (*(__int64 (__fastcall **)(__int64))(v18 + 112))(v30);
        v29 = v36(v37, v29);
      }
      v38 = v35(v29);
    }
    else
    {
      v38 = 0;
    }
    v50[0] = 0LL;
    v51 = 0LL;
    v52 = 15LL;
    v39 = (char *)sub_180031D20((ai *)0x20, v14, v15);
    v51 = 24LL;
    v52 = 31LL;
    strcpy(v39, "Export Current Document ");
    v50[0] = v39;
    v34(v50, v38);
    if ( v52 >= 0x10 )
    {
      v40 = v50[0];
      if ( v52 + 1 >= 0x1000 )
      {
        v40 = *(_QWORD *)(v50[0] - 8LL);
        if ( (unsigned __int64)(v50[0] - v40 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18001AE10(v40);
    }
  }
  (*(void (__fastcall **)(__int64))(gAIUndoSuite + 136))(1LL);
  (*(void (__fastcall **)(__int64))(gAILayerSuite + 56))(v42);
  (*(void (__fastcall **)(_QWORD))(gAIUndoSuite + 136))(0LL);
  (*(void (__fastcall **)(__int64))(gAILayerSuite + 24))(v43);
  return v13;
}


// ===== 函数: sub_18002CEE0 (0x18002CEE0) =====
__int64 sub_18002CEE0()
{
  __int64 result; // rax
  unsigned int v1; // ebx
  __int64 v2; // [rsp+30h] [rbp-78h] BYREF
  __int64 v3; // [rsp+38h] [rbp-70h] BYREF
  _QWORD v4[2]; // [rsp+40h] [rbp-68h] BYREF
  _OWORD v5[2]; // [rsp+50h] [rbp-58h] BYREF
  __int128 v6; // [rsp+70h] [rbp-38h] BYREF
  __int128 v7; // [rsp+80h] [rbp-28h]

  v4[1] = -2LL;
  v6 = xmmword_180058FB0;
  v7 = xmmword_180058FC0;
  v4[0] = 0LL;
  result = (*(__int64 (__fastcall **)(_QWORD *))(gAILayerSuite + 16))(v4);
  v1 = result;
  if ( !(_DWORD)result )
  {
    if ( !v4[0]
      || (v2 = 0LL,
          result = (*(__int64 (__fastcall **)(_QWORD, __int64 *))(gAIArtSuite + 32))(v4[0], &v2),
          (v1 = result) == 0)
      && (!v2 || (result = sub_180039A20(v2, (int)&v6, 1, 0LL, 0LL, 80), (v1 = result) == 0)) )
    {
      sub_180035940(&v2);
      sub_180035F90((__int64)&v2, &v3, 0);
      v5[0] = v6;
      v5[1] = v7;
      sub_180036320(&v3, v5);
      sub_1800363C0(&v2, 0LL, &v3);
      sub_180035AA0((__int64)&v3);
      sub_1800359F0(&v2);
      return v1;
    }
  }
  return result;
}


// ===== 函数: sub_180036320 (0x180036320) =====
__int64 __fastcall sub_180036320(__int64 a1, __int64 a2)
{
  __int128 *v4; // rax
  __int128 *v5; // rbx
  int v6; // eax
  _QWORD *v7; // rax
  _BYTE pExceptionObject[72]; // [rsp+20h] [rbp-48h] BYREF

  v4 = sub_180036270();
  v5 = v4;
  if ( !*((_QWORD *)v4 + 1) && qword_1800740D8 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v4 + 2),
           *((unsigned int *)v4 + 6),
           (__int64)v4 + 8);
    if ( v6 )
    {
      sub_180003F80((__int64)pExceptionObject, v6, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v5 + 28) )
    {
      v7 = sub_180012E90();
      *(_QWORD *)v5 = *v7;
      *v7 = v5;
    }
  }
  return (*(__int64 (__fastcall **)(__int64, __int64))(*((_QWORD *)v5 + 1) + 32LL))(a1, a2);
}


// ===== 函数: sub_180036270 (0x180036270) =====
__int128 *sub_180036270()
{
  _QWORD *v1; // rax

  if ( dword_1800745D0 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_1800745B0;
  Init_thread_header(&dword_1800745D0);
  if ( dword_1800745D0 != -1 )
    return &xmmword_1800745B0;
  xmmword_1800745B0 = 0LL;
  qword_1800745C0 = (__int64)"AI Artboard Suite";
  dword_1800745C8 = 6;
  byte_1800745CC = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_1800745B0 = *v1;
  *v1 = &xmmword_1800745B0;
  Init_thread_footer(&dword_1800745D0);
  return &xmmword_1800745B0;
}


// ===== 函数: sub_180035940 (0x180035940) =====
_QWORD *__fastcall sub_180035940(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  int v4; // eax
  _QWORD *v5; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  *a1 = 0LL;
  v2 = sub_180036270(&unk_1800745AC);
  v3 = v2;
  if ( !*(_QWORD *)(v2 + 8) && qword_1800740D8 )
  {
    v4 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *(_QWORD *)(v2 + 16),
           *(unsigned int *)(v2 + 24),
           v2 + 8);
    if ( v4 )
    {
      sub_180003F80((__int64)pExceptionObject, v4, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*(_BYTE *)(v3 + 28) )
    {
      v5 = sub_180012E90();
      *(_QWORD *)v3 = *v5;
      *v5 = v3;
    }
  }
  (*(void (__fastcall **)(_QWORD *))(*(_QWORD *)(v3 + 8) + 88LL))(a1);
  return a1;
}


// ===== 函数: sub_1800363C0 (0x1800363C0) =====
__int64 __fastcall sub_1800363C0(__int64 a1, unsigned int a2, __int64 a3)
{
  __int128 *v6; // rax
  __int128 *v7; // rbx
  int v8; // eax
  _QWORD *v9; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v6 = sub_180036270();
  v7 = v6;
  if ( !*((_QWORD *)v6 + 1) && qword_1800740D8 )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v6 + 2),
           *((unsigned int *)v6 + 6),
           (__int64)v6 + 8);
    if ( v8 )
    {
      sub_180003F80((__int64)pExceptionObject, v8, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v7 + 28) )
    {
      v9 = sub_180012E90();
      *(_QWORD *)v7 = *v9;
      *v9 = v7;
    }
  }
  return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(*((_QWORD *)v7 + 1) + 144LL))(a1, a2, a3);
}


// ===== 函数: sub_180035AA0 (0x180035AA0) =====
__int64 __fastcall sub_180035AA0(__int64 a1)
{
  __int128 *v2; // rax
  __int128 *v3; // rbx
  int v4; // eax
  _QWORD *v5; // rax
  __int64 result; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  try
  {
    v2 = sub_180036270();
    v3 = v2;
    if ( !*((_QWORD *)v2 + 1) && qword_1800740D8 )
    {
      v4 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
             *((_QWORD *)v2 + 2),
             *((unsigned int *)v2 + 6),
             (__int64)v2 + 8);
      if ( v4 )
      {
        sub_180003F80((__int64)pExceptionObject, v4, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      if ( !*((_BYTE *)v3 + 28) )
      {
        v5 = sub_180012E90();
        *(_QWORD *)v3 = *v5;
        *v5 = v3;
      }
    }
    result = (*(__int64 (__fastcall **)(__int64))(*((_QWORD *)v3 + 1) + 16LL))(a1);
  }
  catch ( ai::Error )
  {
  }
  v2 = sub_180036270();
}


// ===== 函数: sub_180035F90 (0x180035F90) =====
_QWORD *__fastcall sub_180035F90(__int64 a1, _QWORD *a2, unsigned int a3)
{
  __int128 *v6; // rax
  __int128 *v7; // rbx
  int v8; // eax
  _QWORD *v9; // rax
  _BYTE pExceptionObject[48]; // [rsp+30h] [rbp-48h] BYREF

  *a2 = 0LL;
  v6 = sub_180036270();
  v7 = v6;
  if ( !*((_QWORD *)v6 + 1) && qword_1800740D8 )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v6 + 2),
           *((unsigned int *)v6 + 6),
           (__int64)v6 + 8);
    if ( v8 )
    {
      sub_180003F80((__int64)pExceptionObject, v8, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v7 + 28) )
    {
      v9 = sub_180012E90();
      *(_QWORD *)v7 = *v9;
      *v9 = v7;
    }
  }
  (*(void (__fastcall **)(__int64, _QWORD, _QWORD *))(*((_QWORD *)v7 + 1) + 152LL))(a1, a3, a2);
  return a2;
}


// ===== 函数: sub_1800359F0 (0x1800359F0) =====
void __fastcall sub_1800359F0(_QWORD *a1)
{
  __int128 *v2; // rax
  __int128 *v3; // rbx
  int v4; // eax
  _QWORD *v5; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  if ( *a1 )
  {
    if ( __eh34_try(-1, 0) )
    {
      __eh34_scope_strut(0);
      v2 = sub_180036270();
      v3 = v2;
      if ( !*((_QWORD *)v2 + 1) && qword_1800740D8 )
      {
        v4 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, char *))qword_1800740D8)(
               *((_QWORD *)v2 + 2),
               *((unsigned int *)v2 + 6),
               (char *)v2 + 8);
        if ( v4 )
        {
          sub_180003F80((__int64)pExceptionObject, v4, 0LL);
          throw (ai::Error *)pExceptionObject;
        }
        if ( !*((_BYTE *)v3 + 28) )
        {
          v5 = sub_180012E90();
          *(_QWORD *)v3 = *v5;
          *v5 = v3;
        }
      }
      (*(void (__fastcall **)(_QWORD *))(*((_QWORD *)v3 + 1) + 96LL))(a1);
    }
    if ( __eh34_catch(0) )
    {
      if ( __eh34_catch_type(0, &ai::Error `RTTI Type Descriptor', 0LL) )
        __eh34_try_continuation(0, &ai::Error `RTTI Type Descriptor', &loc_180035A6B);
    }
  }
}


// ===== 函数: sub_1800233C0 (0x1800233C0) =====
__int64 __fastcall sub_1800233C0(__int64 a1, _QWORD *a2, void **a3, __int64 a4)
{
  int v8; // eax
  unsigned int v10; // ebx
  unsigned int v11; // eax
  _BYTE v12[4]; // [rsp+20h] [rbp-18h] BYREF
  int v13; // [rsp+24h] [rbp-14h]
  __int64 v14; // [rsp+28h] [rbp-10h]

  v14 = -2LL;
  try
  {
    byte_180073E5C = 1;
    v12[1] = 1;
    v8 = sub_180024C90(a1, a2, a3);
  }
  catch ( ... )
  {
    v13 = 1128353364;
    v10 = 1128353364;
    goto LABEL_8;
  }
  if ( v8 == 1398034256 )
  {
    sub_180027790((__int64)v12);
    return 1398034256LL;
  }
  else
  {
    v10 = sub_180025880(a1, (__int64)a2, a3, a4);
    if ( *a3 )
    {
      v11 = sub_180017D30((__int64)*a3);
      if ( !v10 )
      {
        if ( v11 )
          v10 = v11;
      }
    }
LABEL_8:
    sub_180027790((__int64)v12);
    return v10;
  }
}


// ===== 函数: sub_180024C90 (0x180024C90) =====
__int64 __fastcall sub_180024C90(__int64 a1, _QWORD *a2, void **a3)
{
  __int64 v5; // r15
  _QWORD *v6; // r14
  unsigned __int64 v7; // rax
  void **v8; // r8
  __int64 v9; // rdx
  void **v10; // r8
  __int64 *i; // rbx
  __int64 *v12; // rdx
  __int64 *v13; // rcx
  __int64 *v14; // r8
  char v15; // r10
  __int64 *v16; // rax
  __int64 *v17; // rdx
  __int64 v18; // rsi
  __int64 v19; // rax
  _QWORD *v20; // r15
  _QWORD *v21; // rsi
  __int64 v22; // rsi
  volatile signed __int32 *v23; // rax
  _QWORD *v24; // rsi
  __int64 v25; // rax
  __int64 **v26; // rax
  __int64 *j; // rax
  __int64 *k; // rcx
  bool v29; // di
  _QWORD *v30; // rbx
  volatile signed __int32 *v31; // rax
  void (__fastcall *v32)(const char *, const char *, _QWORD *); // rsi
  __int64 (__fastcall *v33)(__int64); // rdi
  __int64 (__fastcall *v34)(__int64, __int64); // rbx
  __int64 v35; // rax
  __int64 v36; // rax
  unsigned int v37; // eax
  _QWORD *v38; // rax
  __int64 v39; // rcx
  __int64 **v40; // rcx
  __int64 v41; // rbx
  __int64 v42; // rcx
  __int128 v44; // [rsp+38h] [rbp-91h] BYREF
  __int64 v45; // [rsp+48h] [rbp-81h]
  __int64 **v46; // [rsp+50h] [rbp-79h] BYREF
  __int64 v47; // [rsp+58h] [rbp-71h]
  __int128 v48; // [rsp+60h] [rbp-69h] BYREF
  __int64 v49; // [rsp+70h] [rbp-59h] BYREF
  __int64 v50; // [rsp+78h] [rbp-51h]
  __int64 v51; // [rsp+80h] [rbp-49h]
  __int64 **v52[3]; // [rsp+88h] [rbp-41h] BYREF
  __int128 v53; // [rsp+A0h] [rbp-29h] BYREF
  __int64 v54[3]; // [rsp+B0h] [rbp-19h] BYREF
  __int64 v55[3]; // [rsp+C8h] [rbp-1h] BYREF
  unsigned __int64 v56; // [rsp+E0h] [rbp+17h]

  v54[2] = -2LL;
  v5 = a1;
  *(_QWORD *)&v48 = a1;
  if ( gAIDevUtilsSuite )
  {
    v51 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
    v50 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
  }
  else
  {
    v50 = v48;
    v51 = v48;
  }
  v6 = 0LL;
  v47 = 0LL;
  v7 = sub_180031D20((ai *)0x20, (__int64)a2, a3);
  *(_QWORD *)v7 = v7;
  *(_QWORD *)(v7 + 8) = v7;
  *(_QWORD *)(v7 + 16) = v7;
  *(_WORD *)(v7 + 24) = 257;
  v46 = (__int64 **)v7;
  sub_18002B3B0((__int64)a2, &v46, v8);
  if ( v47 )
  {
    sub_18003CD20((__int64)v52, v9, v10);
    for ( i = *v46; !*((_BYTE *)i + 25); v6 = 0LL )
    {
      v44 = 0LL;
      v45 = 0LL;
      v12 = (__int64 *)a2[6];
      v13 = (__int64 *)v12[1];
      v14 = v12;
      v15 = *((_BYTE *)v13 + 25);
      if ( !v15 )
      {
        v16 = (__int64 *)v12[1];
        do
        {
          if ( *((_BYTE *)v16 + 32) >= *((_BYTE *)i + 26) )
          {
            v14 = v16;
            v16 = (__int64 *)*v16;
          }
          else
          {
            v16 = (__int64 *)v16[2];
          }
        }
        while ( !*((_BYTE *)v16 + 25) );
      }
      if ( !*((_BYTE *)v14 + 25) && *((_BYTE *)i + 26) >= *((_BYTE *)v14 + 32) && v14 != v12 )
      {
        if ( !v15 )
        {
          do
          {
            if ( *((_BYTE *)v13 + 32) >= *((_BYTE *)i + 26) )
            {
              v12 = v13;
              v13 = (__int64 *)*v13;
            }
            else
            {
              v13 = (__int64 *)v13[2];
            }
          }
          while ( !*((_BYTE *)v13 + 25) );
        }
        if ( *((_BYTE *)v12 + 25) || *((_BYTE *)i + 26) < *((_BYTE *)v12 + 32) )
        {
          std::_Xout_of_range("invalid map<K, T> key");
          __debugbreak();
        }
        v17 = v12 + 5;
        if ( &v44 != (__int128 *)v17 )
          sub_180025F40((__int64 *)&v44, *v17, (void **)v17[1]);
        v18 = *((_QWORD *)&v44 + 1);
        sub_180026D90(v54, v44, *((__int64 *)&v44 + 1));
        if ( v54[0] == v18 )
        {
          v6 = (_QWORD *)*((_QWORD *)&v44 + 1);
          goto LABEL_30;
        }
        v19 = sub_1800267D0(v18, *((__int64 *)&v44 + 1), v54[0]);
        v6 = (_QWORD *)v19;
        v20 = (_QWORD *)*((_QWORD *)&v44 + 1);
        if ( v19 != *((_QWORD *)&v44 + 1) )
        {
          v21 = (_QWORD *)(v19 + 8);
          do
          {
            sub_180036A90(v21 + 1);
            sub_180036A90(v21);
            v21 += 5;
          }
          while ( v21 - 1 != v20 );
        }
        v5 = v48;
      }
      *((_QWORD *)&v44 + 1) = v6;
LABEL_30:
      v22 = v44;
      if ( (_QWORD *)v44 != v6 )
      {
        do
        {
          unknown_libname_2(&v49);
          sub_180032600(&v49, a2);
          v53 = 0LL;
          v23 = (volatile signed __int32 *)a3[1];
          if ( v23 )
            _InterlockedIncrement(v23 + 2);
          v53 = *(_OWORD *)a3;
          sub_180023850(v5, v52, v22, (__int64)a2, (__int64 *)&v53);
          sub_180032550(&v49);
          v22 += 40LL;
        }
        while ( (_QWORD *)v22 != v6 );
        v6 = (_QWORD *)*((_QWORD *)&v44 + 1);
        v22 = v44;
      }
      if ( v22 )
      {
        if ( (_QWORD *)v22 != v6 )
        {
          v24 = (_QWORD *)(v22 + 8);
          do
          {
            sub_180036A90(v24 + 1);
            sub_180036A90(v24);
            v24 += 5;
          }
          while ( v24 - 1 != v6 );
          v22 = v44;
        }
        v25 = v22;
        if ( (unsigned __int64)(40 * ((v45 - v22) / 40)) >= 0x1000 )
        {
          v22 = *(_QWORD *)(v22 - 8);
          if ( (unsigned __int64)(v25 - v22 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v22);
      }
      v26 = (__int64 **)i[2];
      if ( *((_BYTE *)v26 + 25) )
      {
        for ( j = (__int64 *)i[1]; !*((_BYTE *)j + 25); j = (__int64 *)j[1] )
        {
          if ( i != (__int64 *)j[2] )
            break;
          i = j;
        }
        i = j;
      }
      else
      {
        i = (__int64 *)i[2];
        for ( k = *v26; !*((_BYTE *)k + 25); k = (__int64 *)*k )
          i = k;
      }
    }
    v29 = (unsigned int)sub_18003D590((__int64)v52) != 0;
    if ( !*a3 )
      goto LABEL_60;
    v30 = (char *)*a3 + 112;
    v48 = 0LL;
    v31 = (volatile signed __int32 *)a3[1];
    if ( v31 )
      _InterlockedIncrement(v31 + 2);
    v48 = *(_OWORD *)a3;
    sub_18003D5A0(v52, &v48, v30);
    if ( *v30 && (*(unsigned int (__fastcall **)(_QWORD))(*(_QWORD *)*v30 + 24LL))(*v30) )
    {
      sub_180017D30((__int64)*a3);
      LODWORD(v6) = 1398034256;
    }
    else
    {
LABEL_60:
      if ( v29 && gAIAdobePIPSuite )
      {
        v32 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
        if ( gAIDevUtilsSuite )
        {
          v33 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
          v34 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
          v35 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v50);
          v36 = v34(v35, v51);
          v37 = v33(v36);
        }
        else
        {
          v37 = 0;
        }
        v38 = sub_18002CA00(v55, v37);
        if ( v38[3] >= 0x10uLL )
          v38 = (_QWORD *)*v38;
        v32("Smart Export", "TimeOnMainThreadForAIDEFormats", v38);
        if ( v56 >= 0x10 )
        {
          v39 = v55[0];
          if ( v56 + 1 >= 0x1000 )
          {
            v39 = *(_QWORD *)(v55[0] - 8);
            if ( (unsigned __int64)(v55[0] - v39 - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
          }
          sub_18001AE10(v39);
        }
      }
    }
    sub_1800261E0((__int64)v52, (__int64)v52, (__int64)v52[0][1]);
    sub_18001AE10((__int64)v52[0]);
  }
  v40 = v46;
  v41 = (__int64)v46[1];
  if ( !*(_BYTE *)(v41 + 25) )
  {
    do
    {
      sub_18000B870((__int64)&v46, (__int64)&v46, *(_QWORD *)(v41 + 16));
      v42 = v41;
      v41 = *(_QWORD *)v41;
      sub_18001AE10(v42);
    }
    while ( !*(_BYTE *)(v41 + 25) );
    v40 = v46;
  }
  sub_18001AE10((__int64)v40);
  return (unsigned int)v6;
}


// ===== 函数: sub_18003D590 (0x18003D590) =====
__int64 __fastcall sub_18003D590(__int64 a1)
{
  return *(unsigned int *)(a1 + 8);
}


// ===== 函数: sub_18003CD20 (0x18003CD20) =====
__int64 __fastcall sub_18003CD20(__int64 a1, __int64 a2, void **a3)
{
  unsigned __int64 v4; // rax
  __int64 result; // rax

  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  v4 = sub_180031D20((ai *)0xD0, a2, a3);
  *(_QWORD *)v4 = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)(v4 + 16) = v4;
  *(_WORD *)(v4 + 24) = 257;
  *(_QWORD *)a1 = v4;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}


// ===== 函数: sub_18003D5A0 (0x18003D5A0) =====
__int64 __fastcall sub_18003D5A0(__int64 ***a1, _QWORD *a2, _QWORD *a3)
{
  int v5; // esi
  __int64 v6; // r14
  __int64 *v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rax
  volatile signed __int32 *v10; // rbx
  volatile signed __int32 *v11; // rbx
  __int64 result; // rax
  unsigned int v13; // edx
  _QWORD *v14; // r14
  unsigned int v15; // r12d
  __int64 *v16; // rbx
  __int64 v17; // rax
  volatile signed __int32 *v18; // r14
  __int64 v19; // rax
  volatile signed __int32 *v20; // r14
  int v21; // r14d
  int v22; // eax
  __int64 v23; // rdx
  int v24; // r14d
  int v25; // r14d
  int v26; // r14d
  _BYTE *v27; // r8
  _BYTE *v28; // r9
  _BYTE *v29; // r9
  _BYTE *v30; // r9
  _BYTE *v31; // r9
  void (__fastcall *v32)(_QWORD, __int128 *, __int64); // r14
  __int64 v33; // rax
  __int64 v34; // r13
  __int64 v35; // rax
  _QWORD *v36; // r14
  volatile signed __int32 *v37; // r14
  unsigned int (__fastcall ***v38)(_QWORD, _QWORD, _QWORD); // rcx
  unsigned int (__fastcall **v39)(_QWORD, _QWORD, _QWORD); // rax
  volatile signed __int32 *v40; // rbx
  volatile signed __int32 *v41; // rbx
  __int64 v42; // rbx
  volatile signed __int32 *v43; // rbx
  volatile signed __int32 *v44; // r14
  volatile signed __int32 *v45; // r14
  __int64 **v46; // rax
  __int64 *i; // rax
  __int64 *j; // rcx
  __int64 v49; // rbx
  unsigned __int64 v50; // rdi
  __int64 v51; // rax
  _QWORD *v52; // rbx
  int v53; // [rsp+30h] [rbp-2A8h]
  __int128 v54; // [rsp+38h] [rbp-2A0h] BYREF
  _QWORD *v55; // [rsp+48h] [rbp-290h]
  int v56; // [rsp+50h] [rbp-288h]
  __int128 v57; // [rsp+60h] [rbp-278h] BYREF
  unsigned int v58; // [rsp+70h] [rbp-268h]
  __int64 *v59; // [rsp+78h] [rbp-260h]
  __int64 v60; // [rsp+80h] [rbp-258h] BYREF
  __int64 v61; // [rsp+88h] [rbp-250h] BYREF
  __int64 v62; // [rsp+90h] [rbp-248h] BYREF
  __int64 v63; // [rsp+98h] [rbp-240h] BYREF
  _QWORD *v64; // [rsp+A0h] [rbp-238h]
  __int128 v65; // [rsp+B0h] [rbp-228h] BYREF
  __int64 v66; // [rsp+C0h] [rbp-218h]
  _BYTE v67[8]; // [rsp+C8h] [rbp-210h] BYREF
  volatile signed __int32 *v68; // [rsp+D0h] [rbp-208h]
  __int64 v69; // [rsp+D8h] [rbp-200h]
  unsigned __int64 v70[3]; // [rsp+E0h] [rbp-1F8h] BYREF
  unsigned __int64 v71; // [rsp+F8h] [rbp-1E0h] BYREF
  _BYTE v72[168]; // [rsp+108h] [rbp-1D0h] BYREF
  int v73; // [rsp+1B0h] [rbp-128h] BYREF
  __int64 v74; // [rsp+1B8h] [rbp-120h] BYREF
  int v75; // [rsp+1C0h] [rbp-118h]
  __int128 v76; // [rsp+1C8h] [rbp-110h]
  __int128 v77; // [rsp+1D8h] [rbp-100h]
  int v78; // [rsp+1E8h] [rbp-F0h]
  int v79; // [rsp+1ECh] [rbp-ECh]
  int v80; // [rsp+1F0h] [rbp-E8h]
  int v81; // [rsp+1F4h] [rbp-E4h]
  __int16 v82; // [rsp+1F8h] [rbp-E0h]
  __int128 v83; // [rsp+200h] [rbp-D8h]
  int v84; // [rsp+210h] [rbp-C8h]
  int v85; // [rsp+214h] [rbp-C4h]
  __int64 v86; // [rsp+218h] [rbp-C0h]
  volatile signed __int32 *v87; // [rsp+220h] [rbp-B8h]
  __int64 v88; // [rsp+228h] [rbp-B0h]
  volatile signed __int32 *v89; // [rsp+230h] [rbp-A8h]
  int v90; // [rsp+238h] [rbp-A0h]
  __int16 v91; // [rsp+23Ch] [rbp-9Ch]
  int v92; // [rsp+240h] [rbp-98h]
  int v93; // [rsp+244h] [rbp-94h]
  int v94; // [rsp+248h] [rbp-90h]
  _BYTE v95[32]; // [rsp+250h] [rbp-88h] BYREF
  _BYTE v96[40]; // [rsp+270h] [rbp-68h] BYREF

  v66 = -2LL;
  v55 = a2;
  v64 = a2;
  v5 = 0;
  v53 = 0;
  v6 = *((int *)a1 + 2);
  v54 = 0LL;
  if ( (_DWORD)v6 == 1 )
  {
    v7 = (__int64 *)sub_18003CC70(v67);
    v8 = *v7;
    v9 = v7[1];
    *v7 = 0LL;
    v7[1] = 0LL;
    *(_QWORD *)&v54 = v8;
    *((_QWORD *)&v54 + 1) = v9;
    v10 = v68;
    if ( v68 )
    {
      if ( _InterlockedExchangeAdd(v68 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v10)(v10);
        if ( _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
      }
    }
  }
  else
  {
    sub_18003D3E0(a1 + 2, &v54);
  }
  if ( *((_QWORD *)&v54 + 1) )
    _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v54 + 1) + 8LL));
  *a3 = v54;
  v11 = (volatile signed __int32 *)a3[1];
  result = *((_QWORD *)&v54 + 1);
  a3[1] = *((_QWORD *)&v54 + 1);
  if ( v11 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v11 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
      result = (unsigned int)_InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
    }
  }
  if ( (_DWORD)v6 && (_QWORD)v54 )
  {
    *(_QWORD *)(v54 + 40) = v6;
    v13 = v6 + 1;
    v58 = v6 + 1;
    v14 = v55;
    if ( *v55 )
      (**(void (__fastcall ***)(_QWORD, _QWORD, _QWORD))*v55)(*v55, 0LL, v13);
    v15 = 0;
    v56 = 0;
    sub_180041F70(v96);
    v16 = **a1;
    while ( 1 )
    {
      v59 = v16;
      if ( *((_BYTE *)v16 + 25) )
      {
LABEL_80:
        result = sub_180042000(v96);
        if ( *((_QWORD *)&v54 + 1) )
        {
          result = (unsigned int)_InterlockedExchangeAdd(
                                   (volatile signed __int32 *)(*((_QWORD *)&v54 + 1) + 8LL),
                                   0xFFFFFFFF);
          if ( (_DWORD)result == 1 )
          {
            v42 = *((_QWORD *)&v54 + 1);
            (***((void (__fastcall ****)(_QWORD))&v54 + 1))(*((_QWORD *)&v54 + 1));
            result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(v42 + 12), 0xFFFFFFFF);
            if ( (_DWORD)result == 1 )
              result = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)&v54 + 1) + 8LL))(*((_QWORD *)&v54 + 1));
          }
        }
        v43 = (volatile signed __int32 *)v14[1];
        goto LABEL_106;
      }
      sub_180039170(&v73);
      try
      {
        v73 = *((_DWORD *)v16 + 12);
        sub_180032600(&v74, v16 + 7);
        v75 = *((_DWORD *)v16 + 16);
        v76 = *(_OWORD *)(v16 + 9);
        v77 = *(_OWORD *)(v16 + 11);
        v78 = *((_DWORD *)v16 + 26);
        v79 = *((_DWORD *)v16 + 27);
        v80 = *((_DWORD *)v16 + 28);
        v81 = *((_DWORD *)v16 + 29);
        v82 = *((_WORD *)v16 + 60);
        v83 = *((_OWORD *)v16 + 8);
        v84 = *((_DWORD *)v16 + 36);
        v85 = *((_DWORD *)v16 + 37);
        v17 = v16[20];
        if ( v17 )
          _InterlockedIncrement((volatile signed __int32 *)(v17 + 8));
        v86 = v16[19];
        v18 = v87;
        v87 = (volatile signed __int32 *)v16[20];
        if ( v18 )
        {
          if ( _InterlockedExchangeAdd(v18 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v18)(v18);
            if ( _InterlockedExchangeAdd(v18 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v18 + 8LL))(v18);
          }
        }
        v19 = v16[22];
        if ( v19 )
          _InterlockedIncrement((volatile signed __int32 *)(v19 + 8));
        v88 = v16[21];
        v20 = v89;
        v89 = (volatile signed __int32 *)v16[22];
        if ( v20 )
        {
          if ( _InterlockedExchangeAdd(v20 + 2, 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v20)(v20);
            if ( _InterlockedExchangeAdd(v20 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v20 + 8LL))(v20);
          }
        }
        v90 = *((_DWORD *)v16 + 46);
        v91 = *((_WORD *)v16 + 94);
        v92 = *((_DWORD *)v16 + 48);
        v93 = *((_DWORD *)v16 + 49);
        v94 = *((_DWORD *)v16 + 50);
        v21 = *((_DWORD *)v16 + 8);
        v22 = sub_180039300(&v73, v95);
        v57 = 0LL;
        if ( v21 )
        {
          v24 = v21 - 1;
          if ( v24 )
          {
            v25 = v24 - 1;
            if ( v25 )
            {
              v26 = v25 - 2;
              if ( v26 )
              {
                if ( v26 == 1 )
                {
                  v27 = v95;
                  if ( !v22 )
                    v27 = 0LL;
                  v5 = sub_1800425D0(v96, &v73, v27, &v57);
                  v53 = v5;
                }
                goto LABEL_57;
              }
              if ( *((_DWORD *)v16 + 8) == 4 )
              {
                v28 = v95;
                if ( !v22 )
                  LODWORD(v28) = 0;
                v5 = sub_180042BC0((__int64)v96, v23, (int)&v73, (int)v28, (__int64)&v57);
                v53 = v5;
                goto LABEL_57;
              }
            }
            else if ( *((_DWORD *)v16 + 8) == 2 )
            {
              v29 = v95;
              if ( !v22 )
                LODWORD(v29) = 0;
              v5 = sub_1800427E0(
                     (unsigned int)v96,
                     *((_DWORD *)v16 + 10),
                     (unsigned int)&v73,
                     (_DWORD)v29,
                     (__int64)&v57);
              v53 = v5;
              goto LABEL_57;
            }
          }
          else if ( *((_DWORD *)v16 + 8) == 1 )
          {
            v30 = v95;
            if ( !v22 )
              LODWORD(v30) = 0;
            v5 = sub_180042F70((unsigned int)v96, v16[5], (unsigned int)&v73, (_DWORD)v30, (__int64)&v57);
            v53 = v5;
            goto LABEL_57;
          }
        }
        else if ( !*((_DWORD *)v16 + 8) )
        {
          v31 = v95;
          if ( !v22 )
            LODWORD(v31) = 0;
          v5 = sub_180042EC0((unsigned int)v96, v16[5], (unsigned int)&v73, (_DWORD)v31, (__int64)&v57);
          v53 = v5;
          goto LABEL_57;
        }
        v5 = 1346458189;
        v53 = 1346458189;
LABEL_57:
        if ( v5 )
        {
          v34 = v54 + 48;
          v35 = sub_180039350(&v73, &v61);
          v36 = (_QWORD *)sub_180032AF0(v35, &v60, 0LL);
          v69 = v34;
          *(_QWORD *)tbb::internal::concurrent_vector_base_v3::internal_push_back(
                       (tbb::internal::concurrent_vector_base_v3 *)(v34 + 8),
                       8uLL,
                       v70) = *v36;
          *v36 = 0LL;
          sub_180036A90(&v60);
          sub_180032550(&v61);
        }
        else
        {
          v32 = *(void (__fastcall **)(_QWORD, __int128 *, __int64))(*(_QWORD *)v54 + 32LL);
          v33 = sub_1800271C0(v72, &v73);
          v65 = 0LL;
          if ( *((_QWORD *)&v57 + 1) )
            _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v57 + 1) + 8LL));
          v65 = v57;
          v32(v54, &v65, v33);
        }
        v37 = (volatile signed __int32 *)*((_QWORD *)&v57 + 1);
        if ( *((_QWORD *)&v57 + 1) )
        {
          if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v57 + 1) + 8LL), 0xFFFFFFFF) == 1 )
          {
            (**(void (__fastcall ***)(volatile signed __int32 *))v37)(v37);
            if ( _InterlockedExchangeAdd(v37 + 3, 0xFFFFFFFF) == 1 )
              (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v37 + 8LL))(v37);
          }
        }
        v14 = v55;
      }
      catch ( ... )
      {
        v50 = v54 + 48;
        v51 = sub_180039350(&v73, &v63);
        v52 = (_QWORD *)sub_180032AF0(v51, &v62, 0LL);
        v70[2] = v50;
        *(_QWORD *)tbb::internal::concurrent_vector_base_v3::internal_push_back(
                     (tbb::internal::concurrent_vector_base_v3 *)(v50 + 8),
                     8uLL,
                     &v71) = *v52;
        *v52 = 0LL;
        sub_180036A90(&v62);
        sub_180032550(&v63);
        v5 = v53;
        v15 = v56;
        v16 = v59;
        v14 = v64;
        v55 = v64;
      }
      v38 = (unsigned int (__fastcall ***)(_QWORD, _QWORD, _QWORD))*v14;
      if ( *v14 )
      {
        v39 = *v38;
        v56 = ++v15;
        if ( !(*v39)(v38, v15, v58) )
        {
          if ( (_QWORD)v54 )
            sub_180041070();
          v40 = v89;
          if ( v89 )
          {
            if ( _InterlockedExchangeAdd(v89 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v40)(v40);
              if ( _InterlockedExchangeAdd(v40 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v40 + 8LL))(v40);
            }
          }
          v41 = v87;
          if ( v87 )
          {
            if ( _InterlockedExchangeAdd(v87 + 2, 0xFFFFFFFF) == 1 )
            {
              (**(void (__fastcall ***)(volatile signed __int32 *))v41)(v41);
              if ( _InterlockedExchangeAdd(v41 + 3, 0xFFFFFFFF) == 1 )
                (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v41 + 8LL))(v41);
            }
          }
          sub_180032550(&v74);
          goto LABEL_80;
        }
      }
      v44 = v89;
      if ( v89 )
      {
        if ( _InterlockedExchangeAdd(v89 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v44)(v44);
          if ( _InterlockedExchangeAdd(v44 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v44 + 8LL))(v44);
        }
      }
      v45 = v87;
      if ( v87 )
      {
        if ( _InterlockedExchangeAdd(v87 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v45)(v45);
          if ( _InterlockedExchangeAdd(v45 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v45 + 8LL))(v45);
        }
      }
      sub_180032550(&v74);
      v46 = (__int64 **)v16[2];
      if ( *((_BYTE *)v46 + 25) )
      {
        for ( i = (__int64 *)v16[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
        {
          if ( v16 != (__int64 *)i[2] )
            break;
          v16 = i;
        }
        v16 = i;
        v14 = v55;
      }
      else
      {
        v16 = (__int64 *)v16[2];
        for ( j = *v46; !*((_BYTE *)j + 25); j = (__int64 *)*j )
          v16 = j;
        v14 = v55;
      }
    }
  }
  if ( *((_QWORD *)&v54 + 1) )
  {
    result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v54 + 1) + 8LL), 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      v49 = *((_QWORD *)&v54 + 1);
      (***((void (__fastcall ****)(_QWORD))&v54 + 1))(*((_QWORD *)&v54 + 1));
      result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(v49 + 12), 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)&v54 + 1) + 8LL))(*((_QWORD *)&v54 + 1));
    }
  }
  v43 = (volatile signed __int32 *)v55[1];
LABEL_106:
  if ( v43 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v43 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v43)(v43);
      if ( _InterlockedExchangeAdd(v43 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v43 + 8LL))(v43);
    }
  }
  return result;
}


// ===== 函数: sub_180039300 (0x180039300) =====
__int64 __fastcall sub_180039300(__int64 a1, _OWORD *a2)
{
  if ( *(_DWORD *)(a1 + 60) )
  {
    *a2 = *(_OWORD *)(a1 + 24);
    a2[1] = *(_OWORD *)(a1 + 40);
  }
  return *(unsigned int *)(a1 + 60);
}


// ===== 函数: sub_180042000 (0x180042000) =====
__int64 __fastcall sub_180042000(__int64 a1)
{
  _DWORD *v2; // rdi
  _QWORD *v3; // rax
  int v4; // eax
  _QWORD *v5; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  if ( *(_QWORD *)(a1 + 32) )
  {
    v2 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL);
    if ( dword_180074B38 > *v2 )
    {
      Init_thread_header(&dword_180074B38);
      if ( dword_180074B38 == -1 )
      {
        xmmword_180074B18 = 0LL;
        qword_180074B28 = (__int64)"SP Basic Suite";
        dword_180074B30 = 4;
        byte_180074B34 = 0;
        Init_thread_footer(&dword_180074B38);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074B18 + 1) && qword_1800740D8 )
    {
      if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
             qword_180074B28,
             (unsigned int)dword_180074B30,
             (char *)&xmmword_180074B18 + 8) )
      {
        *((_QWORD *)&xmmword_180074B18 + 1) = 0LL;
      }
      else if ( !byte_180074B34 )
      {
        v3 = sub_180012E90();
        *(_QWORD *)&xmmword_180074B18 = *v3;
        *v3 = &xmmword_180074B18;
      }
    }
    if ( *((_QWORD *)&xmmword_180074B18 + 1) )
    {
      if ( dword_180074B38 > *v2 )
      {
        Init_thread_header(&dword_180074B38);
        if ( dword_180074B38 == -1 )
        {
          xmmword_180074B18 = 0LL;
          qword_180074B28 = (__int64)"SP Basic Suite";
          dword_180074B30 = 4;
          byte_180074B34 = 0;
          Init_thread_footer(&dword_180074B38);
        }
      }
      if ( !*((_QWORD *)&xmmword_180074B18 + 1) && qword_1800740D8 )
      {
        v4 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
               qword_180074B28,
               (unsigned int)dword_180074B30,
               (char *)&xmmword_180074B18 + 8);
        if ( v4 )
        {
          sub_180003F80((__int64)pExceptionObject, v4, 0LL);
          throw (ai::Error *)pExceptionObject;
        }
        if ( !byte_180074B34 )
        {
          v5 = sub_180012E90();
          *(_QWORD *)&xmmword_180074B18 = *v5;
          *v5 = &xmmword_180074B18;
        }
      }
      (*(void (__fastcall **)(const char *, __int64))(*((_QWORD *)&xmmword_180074B18 + 1) + 8LL))(
        "AI SmartExport Suite",
        1LL);
    }
  }
  return sub_180007420(a1);
}


// ===== 函数: sub_180042BC0 (0x180042BC0) =====
__int64 __fastcall sub_180042BC0(__int64 a1, __int64 a2, int a3, int a4, __int64 a5)
{
  unsigned int v8; // ebx
  __int64 v9; // r14
  __int64 v10; // rcx
  _QWORD *v11; // rax
  unsigned int v12; // eax
  __int64 v13; // rcx
  _QWORD *v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rax
  __int64 v18; // [rsp+38h] [rbp-70h] BYREF
  char v19; // [rsp+40h] [rbp-68h]
  _BYTE pExceptionObject[40]; // [rsp+48h] [rbp-60h] BYREF
  __int64 v21; // [rsp+B0h] [rbp+8h] BYREF

  v8 = 0;
  if ( !*(_QWORD *)(a1 + 32) )
  {
    v9 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
    if ( dword_180074B38 > *(_DWORD *)(v9 + 4) )
    {
      Init_thread_header(&dword_180074B38);
      if ( dword_180074B38 == -1 )
      {
        xmmword_180074B18 = 0LL;
        qword_180074B28 = (__int64)"SP Basic Suite";
        dword_180074B30 = 4;
        byte_180074B34 = 0;
        Init_thread_footer(&dword_180074B38);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074B18 + 1) && qword_1800740D8 )
    {
      if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
             qword_180074B28,
             (unsigned int)dword_180074B30,
             (char *)&xmmword_180074B18 + 8) )
      {
        *((_QWORD *)&xmmword_180074B18 + 1) = 0LL;
      }
      else if ( !byte_180074B34 )
      {
        v11 = (_QWORD *)sub_180012E90(v10);
        *(_QWORD *)&xmmword_180074B18 = *v11;
        *v11 = &xmmword_180074B18;
      }
    }
    if ( *((_QWORD *)&xmmword_180074B18 + 1) )
    {
      if ( dword_180074B38 > *(_DWORD *)(v9 + 4) )
      {
        Init_thread_header(&dword_180074B38);
        if ( dword_180074B38 == -1 )
        {
          xmmword_180074B18 = 0LL;
          qword_180074B28 = (__int64)"SP Basic Suite";
          dword_180074B30 = 4;
          byte_180074B34 = 0;
          Init_thread_footer(&dword_180074B38);
        }
      }
      if ( !*((_QWORD *)&xmmword_180074B18 + 1) && qword_1800740D8 )
      {
        v12 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
                qword_180074B28,
                (unsigned int)dword_180074B30,
                (char *)&xmmword_180074B18 + 8);
        if ( v12 )
        {
          sub_180003F80(pExceptionObject, v12, 0LL);
          throw (ai::Error *)pExceptionObject;
        }
        if ( !byte_180074B34 )
        {
          v14 = (_QWORD *)sub_180012E90(v13);
          *(_QWORD *)&xmmword_180074B18 = *v14;
          *v14 = &xmmword_180074B18;
        }
      }
      (**((void (__fastcall ***)(const char *, __int64, __int64))&xmmword_180074B18 + 1))(
        "AI SmartExport Suite",
        1LL,
        a1 + 32);
    }
    else
    {
      v8 = 1128353364;
    }
  }
  if ( *(_QWORD *)(a1 + 32) && !v8 )
  {
    v21 = 0LL;
    v15 = *(_QWORD *)sub_180042210(&qword_180074AE0);
    v16 = sub_180008570(a1);
    v8 = sub_180043BD0(v16, v15, &v21);
    if ( !v8 )
      v8 = (*(__int64 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(a1 + 32) + 160LL))(
             *(_QWORD *)(*(_QWORD *)(a1 + 32) + 160LL),
             v21);
    v18 = a1;
    v19 = 1;
    if ( !v8 )
      v8 = sub_180042EC0(a1, v21, a3, a4, a5);
    sub_180041FB0(&v18);
  }
  return v8;
}


// ===== 函数: sub_180042EC0 (0x180042EC0) =====
__int64 __fastcall sub_180042EC0(int a1, __int64 a2, int a3, int a4, __int64 a5)
{
  unsigned int v9; // ebx
  int v10; // eax
  __int64 result; // rax
  int v12; // [rsp+30h] [rbp-18h] BYREF
  __int64 v13; // [rsp+38h] [rbp-10h]

  v13 = -2LL;
  v9 = 0;
  try
  {
    sub_1800153F0();
    if ( (unsigned __int8)sub_1800155C0(&v12) )
    {
      sub_180015750(&v12, a2);
      v10 = sub_180015740(&v12);
      v9 = sub_180042F70(a1, v10, a3, a4, a5);
    }
    sub_180015530(&v12);
    result = v9;
  }
  catch ( ... )
  {
    return 1128353364LL;
  }
  return result;
}


// ===== 函数: sub_180042210 (0x180042210) =====
_QWORD *__fastcall sub_180042210(_QWORD *a1)
{
  int v2; // eax
  _QWORD *v3; // rax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  if ( !*a1 )
  {
    if ( dword_180074A68 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                     + 4LL) )
    {
      Init_thread_header(&dword_180074A68);
      if ( dword_180074A68 == -1 )
      {
        xmmword_180074A48 = 0LL;
        qword_180074A58 = (__int64)"AI Dictionary Suite";
        dword_180074A60 = 10;
        byte_180074A64 = 0;
        Init_thread_footer(&dword_180074A68);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074A48 + 1) && qword_1800740D8 )
    {
      v2 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
             qword_180074A58,
             (unsigned int)dword_180074A60,
             (char *)&xmmword_180074A48 + 8);
      if ( v2 )
      {
        sub_180003F80((__int64)pExceptionObject, v2, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      if ( !byte_180074A64 )
      {
        v3 = sub_180012E90();
        *(_QWORD *)&xmmword_180074A48 = *v3;
        *v3 = &xmmword_180074A48;
      }
    }
    *a1 = (*(__int64 (__fastcall **)(const char *))(*((_QWORD *)&xmmword_180074A48 + 1) + 64LL))("ScratchKey For Asset");
  }
  return a1;
}


// ===== 函数: sub_180043BD0 (0x180043BD0) =====
__int64 __fastcall sub_180043BD0(__int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *v6; // rbx
  int v7; // eax
  _QWORD *v8; // rax
  __int64 result; // rax
  int v10; // eax
  _QWORD *v11; // rax
  _BYTE pExceptionObject[64]; // [rsp+28h] [rbp-40h] BYREF

  v6 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL);
  if ( dword_180074A68 > *v6 )
  {
    Init_thread_header(&dword_180074A68);
    if ( dword_180074A68 == -1 )
    {
      xmmword_180074A48 = 0LL;
      qword_180074A58 = (__int64)"AI Dictionary Suite";
      dword_180074A60 = 10;
      byte_180074A64 = 0;
      Init_thread_footer(&dword_180074A68);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074A48 + 1) && qword_1800740D8 )
  {
    v7 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074A58,
           (unsigned int)dword_180074A60,
           (char *)&xmmword_180074A48 + 8);
    if ( v7 )
    {
      sub_180003F80((__int64)pExceptionObject, v7, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !byte_180074A64 )
    {
      v8 = sub_180012E90();
      *(_QWORD *)&xmmword_180074A48 = *v8;
      *v8 = &xmmword_180074A48;
    }
  }
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*((_QWORD *)&xmmword_180074A48 + 1) + 136LL))(
             a1,
             a2,
             1LL);
  if ( !(_DWORD)result )
  {
    if ( dword_180074A68 > *v6 )
    {
      Init_thread_header(&dword_180074A68);
      if ( dword_180074A68 == -1 )
      {
        xmmword_180074A48 = 0LL;
        qword_180074A58 = (__int64)"AI Dictionary Suite";
        dword_180074A60 = 10;
        byte_180074A64 = 0;
        Init_thread_footer(&dword_180074A68);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074A48 + 1) && qword_1800740D8 )
    {
      v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
              qword_180074A58,
              (unsigned int)dword_180074A60,
              (char *)&xmmword_180074A48 + 8);
      if ( v10 )
      {
        sub_180003F80((__int64)pExceptionObject, v10, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      if ( !byte_180074A64 )
      {
        v11 = sub_180012E90();
        *(_QWORD *)&xmmword_180074A48 = *v11;
        *v11 = &xmmword_180074A48;
      }
    }
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*((_QWORD *)&xmmword_180074A48 + 1) + 128LL))(
             a1,
             a2,
             a3);
  }
  return result;
}


// ===== 函数: sub_180041FB0 (0x180041FB0) =====
void __fastcall sub_180041FB0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rbx
  __int64 v3; // rax

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = *(_QWORD *)a1;
    try
    {
      v2 = *sub_180042210(&qword_180074AE0);
      v3 = sub_180008570(v1);
      sub_1800424A0(v3, v2);
    }
    catch ( ... )
    {
    }
  }
}


// ===== 函数: sub_1800271C0 (0x1800271C0) =====
__int64 __fastcall sub_1800271C0(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rax

  *(_DWORD *)a1 = *(_DWORD *)a2;
  sub_180032460((_QWORD *)(a1 + 8), a2 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_WORD *)(a1 + 72) = *(_WORD *)(a2 + 72);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a2 + 100);
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_QWORD *)(a1 + 112) = 0LL;
  v4 = *(_QWORD *)(a2 + 112);
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 8));
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 120) = 0LL;
  *(_QWORD *)(a1 + 128) = 0LL;
  v5 = *(_QWORD *)(a2 + 128);
  if ( v5 )
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 8));
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(_WORD *)(a1 + 140) = *(_WORD *)(a2 + 140);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 148);
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  return a1;
}


// ===== 函数: sub_1800425D0 (0x1800425D0) =====
__int64 __fastcall sub_1800425D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v8; // eax
  _QWORD *v9; // rax
  __int64 (__fastcall *v10)(__int64, __int64); // rbx
  __int64 v11; // rax
  unsigned int v12; // ebx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v16[2]; // [rsp+30h] [rbp-88h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+40h] [rbp-78h] BYREF
  __int128 v18; // [rsp+68h] [rbp-50h] BYREF
  __int128 v19; // [rsp+78h] [rbp-40h]

  v16[1] = -2LL;
  sub_1800153F0((unsigned __int64 *)v16, 0LL, (void **)a3);
  if ( dword_180074B10 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                   + 4LL) )
  {
    Init_thread_header(&dword_180074B10);
    if ( dword_180074B10 == -1 )
    {
      xmmword_180074AF0 = 0LL;
      qword_180074B00 = (__int64)"AI Art Set Generator Suite";
      dword_180074B08 = 3;
      byte_180074B0C = 0;
      Init_thread_footer(&dword_180074B10);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074AF0 + 1) && qword_1800740D8 )
  {
    v8 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074B00,
           (unsigned int)dword_180074B08,
           (char *)&xmmword_180074AF0 + 8);
    if ( v8 )
    {
      sub_180003F80((__int64)pExceptionObject, v8, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !byte_180074B0C )
    {
      v9 = sub_180012E90();
      *(_QWORD *)&xmmword_180074AF0 = *v9;
      *v9 = &xmmword_180074AF0;
    }
  }
  v10 = *(__int64 (__fastcall **)(__int64, __int64))(*((_QWORD *)&xmmword_180074AF0 + 1) + 40LL);
  v11 = sub_180015740((__int64)v16);
  v12 = v10(v11, 1LL);
  v18 = xmmword_18005BDE0;
  v19 = xmmword_18005BDD0;
  if ( !v12 )
  {
    if ( a3 )
    {
      v18 = *(_OWORD *)a3;
      v19 = *(_OWORD *)(a3 + 16);
LABEL_11:
      v14 = sub_180015740((__int64)v16);
      v12 = sub_180042F70(a1, v14, a2, (__int64)&v18, a4);
      goto LABEL_12;
    }
    v13 = sub_180015740((__int64)v16);
    v12 = sub_18003A510(v13, (int)&v18, 1, 0, 0LL);
    if ( !v12 )
      goto LABEL_11;
  }
LABEL_12:
  sub_180015530(v16);
  return v12;
}


// ===== 函数: sub_180015740 (0x180015740) =====
__int64 __fastcall sub_180015740(__int64 a1)
{
  return **(_QWORD **)a1;
}


// ===== 函数: sub_1800153F0 (0x1800153F0) =====
unsigned __int64 *__fastcall sub_1800153F0(unsigned __int64 *a1, __int64 a2, void **a3)
{
  char v3; // si
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rax
  int v9; // eax
  _BYTE pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF

  v3 = a2;
  v5 = sub_180031D20((ai *)0x10, a2, a3);
  v6 = v5;
  if ( v5 )
  {
    sub_1800154A0(v5);
    if ( v3 )
    {
      v7 = sub_1800155E0(&unk_18007413D);
      v8 = sub_180007790(v7);
      v9 = (*(__int64 (__fastcall **)(_QWORD))(v8 + 40))(*(_QWORD *)v6);
      *(_DWORD *)(v6 + 8) = v9;
      if ( v9 )
      {
        sub_180003F80((__int64)pExceptionObject, v9, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
    }
  }
  else
  {
    v6 = 0LL;
  }
  *a1 = v6;
  return a1;
}


// ===== 函数: sub_18003A510 (0x18003A510) =====
__int64 __fastcall sub_18003A510(__int64 a1, int a2, int a3, int a4, __int64 a5)
{
  __int128 *v9; // rax
  __int64 v10; // rax
  int v11; // eax
  unsigned __int64 i; // rbx
  __int128 *v13; // rax
  __int64 v14; // rax
  int v15; // eax
  int v16; // eax
  unsigned __int64 v18; // [rsp+30h] [rbp-C8h] BYREF
  __int64 v19; // [rsp+38h] [rbp-C0h] BYREF
  unsigned int v20; // [rsp+40h] [rbp-B8h] BYREF
  __int64 v21; // [rsp+48h] [rbp-B0h]
  const ai::Error *v22; // [rsp+50h] [rbp-A8h] BYREF
  _BYTE pExceptionObject[40]; // [rsp+58h] [rbp-A0h] BYREF
  _BYTE v24[40]; // [rsp+80h] [rbp-78h] BYREF
  _BYTE v25[40]; // [rsp+A8h] [rbp-50h] BYREF
  const std::exception *v26; // [rsp+D0h] [rbp-28h] BYREF

  v21 = -2LL;
  try
  {
    v18 = 0LL;
    v9 = sub_1800155E0();
    v10 = sub_180007790((__int64)v9);
    v11 = (*(__int64 (__fastcall **)(__int64, unsigned __int64 *))(v10 + 16))(a1, &v18);
    if ( v11 )
    {
      sub_180003F80(
        (__int64)pExceptionObject,
        v11,
        (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\p"
                 "rivate\\api\\AIS4WUtils.cpp line: 274 ");
      throw (ai::Error *)pExceptionObject;
    }
    for ( i = 0LL; i < v18; ++i )
    {
      v19 = 0LL;
      v13 = sub_1800155E0();
      v14 = sub_180007790((__int64)v13);
      v15 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64 *))(v14 + 24))(a1, i, &v19);
      if ( v15 )
      {
        sub_180003F80(
          (__int64)v24,
          v15,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 274 ");
        throw (ai::Error *)v24;
      }
      v16 = sub_180039A20(v19, a2, a3, a4, a5, 80);
      if ( v16 )
      {
        sub_180003F80(
          (__int64)v25,
          v16,
          (__int64)"AI exception from ErrorThrower declared in file: D:\\Jenkins\\ws\\ilst_rel_27_9\\shared\\illustrator\\"
                   "private\\api\\AIS4WUtils.cpp line: 274 ");
        throw (ai::Error *)v25;
      }
    }
  }
  catch ( const ai::Error *v22 )
  {
    return *((unsigned int *)v22 + 6);
  }
  catch ( const std::exception *v26 )
  {
    return 1398031704LL;
  }
  catch ( int v20 )
  {
    return v20;
  }
  catch ( ... )
  {
    return 1431192920LL;
  }
  return 0LL;
}


// ===== 函数: sub_180042F70 (0x180042F70) =====
__int64 __fastcall sub_180042F70(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // r14
  int v8; // edi
  __int64 v9; // rbx
  __int64 v10; // rax
  unsigned int v11; // esi
  double v12; // xmm6_8
  double v13; // xmm1_8
  double v14; // xmm0_8
  double v15; // xmm6_8
  double v16; // xmm0_8
  unsigned __int16 *v18; // rbx
  int v19; // eax
  _QWORD *v20; // rax
  __int128 *v21; // rax
  int v22; // r9d
  __int64 v23; // rbx
  __int64 v24; // rax
  unsigned int v25; // [rsp+50h] [rbp-1A8h] BYREF
  int v26; // [rsp+54h] [rbp-1A4h] BYREF
  __int16 v27; // [rsp+58h] [rbp-1A0h]
  __int64 v28; // [rsp+60h] [rbp-198h]
  int v29; // [rsp+68h] [rbp-190h] BYREF
  double v30; // [rsp+70h] [rbp-188h]
  __int16 v31; // [rsp+78h] [rbp-180h]
  __int64 v32; // [rsp+7Ch] [rbp-17Ch]
  int v33; // [rsp+84h] [rbp-174h]
  __int64 v34; // [rsp+88h] [rbp-170h] BYREF
  __int64 v35; // [rsp+90h] [rbp-168h]
  __int64 v36; // [rsp+98h] [rbp-160h] BYREF
  __int64 v37; // [rsp+A0h] [rbp-158h]
  __int64 v38; // [rsp+A8h] [rbp-150h]
  __int64 v39; // [rsp+B0h] [rbp-148h]
  __int64 v40; // [rsp+B8h] [rbp-140h]
  __int64 v41; // [rsp+C0h] [rbp-138h]
  _BYTE pExceptionObject[40]; // [rsp+C8h] [rbp-130h] BYREF
  __m128d v43; // [rsp+F0h] [rbp-108h] BYREF
  __m128d v44; // [rsp+100h] [rbp-F8h]
  __int128 v45; // [rsp+110h] [rbp-E8h] BYREF
  __int128 v46; // [rsp+120h] [rbp-D8h]
  __int128 v47; // [rsp+130h] [rbp-C8h]
  __int128 v48; // [rsp+140h] [rbp-B8h]
  __int128 v49; // [rsp+150h] [rbp-A8h]
  __int128 v50; // [rsp+160h] [rbp-98h]
  __int128 v51; // [rsp+170h] [rbp-88h]
  __int128 v52; // [rsp+180h] [rbp-78h]
  __int64 v53; // [rsp+190h] [rbp-68h]

  v41 = -2LL;
  v6 = a3;
  v37 = a1;
  v35 = a2;
  v28 = a3;
  v40 = a5;
  v43 = (__m128d)xmmword_1800594A0;
  v44 = (__m128d)xmmword_180059490;
  v8 = 0;
  v34 = 0LL;
  v9 = *(_QWORD *)sub_180042340(&unk_180074AE8);
  v10 = sub_180008570(a1);
  v11 = sub_180043BD0(v10, v9, &v34);
  if ( !v11 )
  {
    if ( a4 )
    {
      v43 = *(__m128d *)a4;
      v44 = *(__m128d *)(a4 + 16);
    }
    else
    {
      v11 = sub_18003A510(v35, (unsigned int)&v43, 1, 0, 0LL);
    }
  }
  sub_1800394B0(v6, &v43);
  v36 = 0LL;
  v29 = 2;
  v30 = 0.0;
  v31 = 1;
  v32 = 0LL;
  v33 = 0;
  sub_180039400(v6, &v29);
  if ( !v11 )
  {
    if ( (v32 & 4) == 0 )
    {
      *(float *)&v25 = v30;
      sub_180038A30(&v25, &v43);
    }
    v12 = _mm_unpackhi_pd(v43, v43).m128d_f64[0] - _mm_unpackhi_pd(v44, v44).m128d_f64[0];
    v13 = (v44.m128d_f64[0] - v43.m128d_f64[0]) * v30 / 72.0;
    if ( v13 <= 0.0 )
      v14 = ceil(v13 - 0.5);
    else
      v14 = floor(v13 + 0.5);
    v39 = (int)v14;
    v15 = v12 * v30 / 72.0;
    if ( v15 <= 0.0 )
      v16 = ceil(v15 - 0.5);
    else
      v16 = floor(v15 + 0.5);
    v38 = (int)v16;
    v25 = 1;
    try
    {
      v25 = sub_18001E3F0(&v29);
    }
    catch ( ai::Error )
    {
      v6 = v28;
      v8 = 0;
    }
    catch ( std::exception )
    {
      v6 = v28;
      v8 = 0;
    }
    catch ( int )
    {
      v6 = v28;
      v8 = 0;
    }
    catch ( ... )
    {
      v6 = v28;
      v8 = 0;
    }
    if ( v39 * v38 * (unsigned __int64)v25 > 0x7FFFFFFF )
      return 558445122LL;
    v26 = 0;
    v27 = 0;
    v18 = (unsigned __int16 *)&v26;
    if ( !(unsigned int)sub_180039390(v6, &v26) )
      v18 = 0LL;
    v45 = 0LL;
    v46 = 0LL;
    v47 = 0LL;
    v48 = 0LL;
    v49 = 0LL;
    v50 = 0LL;
    v51 = 0LL;
    v52 = 0LL;
    v53 = 0LL;
    if ( v18 )
    {
      LODWORD(v45) = 5;
      *((double *)&v45 + 1) = (double)*v18 / 65535.0;
      *(double *)&v46 = (double)v18[1] / 65535.0;
      *((double *)&v46 + 1) = (double)v18[2] / 65535.0;
    }
    if ( dword_180074840 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                     + 4LL) )
    {
      Init_thread_header(&dword_180074840);
      if ( dword_180074840 == -1 )
      {
        xmmword_180074820 = 0LL;
        qword_180074830 = (__int64)"AI Rasterize Suite";
        dword_180074838 = 12;
        byte_18007483C = 0;
        Init_thread_footer(&dword_180074840);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074820 + 1) && qword_1800740D8 )
    {
      v19 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
              qword_180074830,
              (unsigned int)dword_180074838,
              (char *)&xmmword_180074820 + 8);
      if ( v19 )
      {
        sub_180003F80((__int64)pExceptionObject, v19, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      if ( !byte_18007483C )
      {
        v20 = sub_180012E90();
        *(_QWORD *)&xmmword_180074820 = *v20;
        *v20 = &xmmword_180074820;
      }
    }
    v21 = &v45;
    if ( !v18 )
      v21 = 0LL;
    v11 = (*(__int64 (__fastcall **)(__int64, int *, __m128d *, __int64, __int64, __int64 *, _QWORD, _QWORD, __int128 *))(*((_QWORD *)&xmmword_180074820 + 1) + 64LL))(
            v35,
            &v29,
            &v43,
            3LL,
            v34,
            &v36,
            0LL,
            0LL,
            v21);
    if ( !v11 )
    {
      LOBYTE(v8) = (unsigned int)sub_180039340(v6) != 3;
      v11 = sub_1800434D0(v37, v36, (unsigned int)&v43, v22, v8, v40);
    }
  }
  v23 = *(_QWORD *)sub_180042340(&unk_180074AE8);
  v24 = sub_180008570(v37);
  sub_1800424A0(v24, v23);
  return v11;
}


// ===== 函数: sub_180015530 (0x180015530) =====
void __fastcall sub_180015530(__int64 *a1)
{
  __int64 v1; // rbx
  __int128 *v2; // rax
  __int64 v3; // rax

  v1 = *a1;
  if ( *a1 )
  {
    v2 = sub_1800155E0();
    v3 = sub_180007790((__int64)v2);
    (*(void (__fastcall **)(__int64))(v3 + 8))(v1);
    sub_180031DC0(v1);
  }
}


// ===== 函数: sub_180039350 (0x180039350) =====
_QWORD *__fastcall sub_180039350(__int64 a1, _QWORD *a2)
{
  sub_180032460(a2, a1 + 8);
  return a2;
}


// ===== 函数: sub_18003D3E0 (0x18003D3E0) =====
__int64 __fastcall sub_18003D3E0(_DWORD *a1, _QWORD *a2, void **a3)
{
  __int64 result; // rax
  __int64 v5; // rcx
  __int64 v6; // rdx
  volatile signed __int32 *v7; // rdi
  volatile signed __int32 *v8; // rdi
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rbx
  struct tbb::task *v11; // rax
  volatile signed __int32 *v12; // rbx
  char v13[8]; // [rsp+30h] [rbp-38h] BYREF
  volatile signed __int32 *v14; // [rsp+38h] [rbp-30h]
  unsigned __int64 v15; // [rsp+70h] [rbp+8h] BYREF
  _QWORD *v16; // [rsp+78h] [rbp+10h]
  unsigned __int64 v17; // [rsp+80h] [rbp+18h]
  unsigned __int64 v18; // [rsp+88h] [rbp+20h]

  v16 = a2;
  try
  {
    if ( *a1 )
    {
      result = sub_18003CC70(v13);
      v5 = *(_QWORD *)result;
      v6 = *(_QWORD *)(result + 8);
      *(_QWORD *)result = 0LL;
      *(_QWORD *)(result + 8) = 0LL;
      *a2 = v5;
      v7 = (volatile signed __int32 *)a2[1];
      a2[1] = v6;
      if ( v7 )
      {
        result = (unsigned int)_InterlockedExchangeAdd(v7 + 2, 0xFFFFFFFF);
        if ( (_DWORD)result == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
          result = (unsigned int)_InterlockedExchangeAdd(v7 + 3, 0xFFFFFFFF);
          if ( (_DWORD)result == 1 )
            result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8LL))(v7);
        }
      }
      v8 = v14;
      if ( v14 )
      {
LABEL_14:
        result = (unsigned int)_InterlockedExchangeAdd(v8 + 2, 0xFFFFFFFF);
        if ( (_DWORD)result == 1 )
        {
          result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v8)(v8);
          if ( _InterlockedExchangeAdd(v8 + 3, 0xFFFFFFFF) == 1 )
            result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v8 + 8LL))(v8);
        }
      }
    }
    else
    {
      v9 = sub_180031D20((ai *)0x188, (__int64)a2, a3);
      v10 = v9;
      v17 = v9;
      if ( v9 )
      {
        *(_DWORD *)(v9 + 8) = 1;
        *(_DWORD *)(v9 + 12) = 1;
        *(_QWORD *)v9 = &std::_Ref_count_obj2<AideAsyncExecutionContext>::`vftable';
        v18 = v9 + 16;
        memset((void *)(v9 + 16), 0, 0x178uLL);
        sub_18003EB40(v10 + 16);
        *(_QWORD *)(v10 + 16) = &AideAsyncExecutionContext::`vftable';
        *(_DWORD *)(v10 + 136) = 1;
        *(_QWORD *)(v10 + 264) = 327683LL;
        *(_DWORD *)(v10 + 304) = 55;
        tbb::task_group_context::init((tbb::task_group_context *)(v10 + 136));
        v15 = v10 + 136;
        v11 = tbb::internal::allocate_root_with_context_proxy::allocate(
                (tbb::internal::allocate_root_with_context_proxy *)&v15,
                8uLL);
        if ( v11 )
        {
          *((_BYTE *)v11 - 11) = 1;
          *(_QWORD *)v11 = &tbb::empty_task::`vftable';
        }
        *(_QWORD *)(v10 + 128) = v11;
        *((_QWORD *)v11 - 3) = 1LL;
      }
      result = v10 + 16;
      *a2 = v10 + 16;
      v8 = (volatile signed __int32 *)a2[1];
      a2[1] = v10;
      if ( v8 )
        goto LABEL_14;
    }
  }
  catch ( ... )
  {
    result = (__int64)v16;
    *v16 = 0LL;
    v12 = *(volatile signed __int32 **)(result + 8);
    *(_QWORD *)(result + 8) = 0LL;
    if ( v12 )
    {
      result = (unsigned int)_InterlockedExchangeAdd(v12 + 2, 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v12)(v12);
        result = (unsigned int)_InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF);
        if ( (_DWORD)result == 1 )
          return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v12 + 8LL))(v12);
      }
    }
  }
  return result;
}


// ===== 函数: sub_18003EB40 (0x18003EB40) =====
__int64 __fastcall sub_18003EB40(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rax
  __int64 v4; // r8
  _QWORD *v5; // rcx
  __int64 v6; // rdx
  void **v7; // r8
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rdi
  volatile signed __int32 *v10; // rbx
  __int64 (__fastcall *v12)(); // [rsp+28h] [rbp-40h] BYREF
  __int64 (__fastcall *v13)(__int64); // [rsp+30h] [rbp-38h]
  __int64 v14; // [rsp+38h] [rbp-30h]
  __int64 v15; // [rsp+40h] [rbp-28h]
  __int64 v16; // [rsp+78h] [rbp+10h] BYREF
  unsigned __int64 v17; // [rsp+80h] [rbp+18h]

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &AideExecutionContextForFormat::`vftable';
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  v2 = a1 + 32;
  v16 = a1 + 32;
  *(_QWORD *)(a1 + 32) = 0LL;
  v3 = 3LL;
  v4 = a1 + 88;
  v5 = (_QWORD *)(a1 + 88);
  do
  {
    *v5++ = 0LL;
    --v3;
  }
  while ( v3 );
  *(_QWORD *)(v2 + 40) = 0LL;
  *(_QWORD *)(v2 + 32) = 0LL;
  *(_QWORD *)(v2 + 48) = v4;
  *(_QWORD *)(v2 + 24) = &sub_180041440;
  _InterlockedExchange64((volatile __int64 *)v2, 0LL);
  *(_QWORD *)(a1 + 40) = 0LL;
  AIDE::AIDELibInitCallBacks::AIDELibInitCallBacks((AIDE::AIDELibInitCallBacks *)&v12);
  v13 = sub_18001AE10;
  v12 = sub_18001AE00;
  v14 = 0LL;
  v15 = 0LL;
  AIDE::AIDEFormatType::AIDEFormatType((AIDE::AIDEFormatType *)&v16, 1347307264);
  AIDE::AIDEFormatType::AIDEFormatType((AIDE::AIDEFormatType *)((char *)&v16 + 4), 1246774599);
  v8 = sub_180031D20((ai *)0x18, v6, v7);
  v9 = v8;
  v17 = v8;
  if ( v8 )
  {
    *(_OWORD *)v8 = 0LL;
    *(_DWORD *)(v8 + 8) = 1;
    *(_DWORD *)(v8 + 12) = 1;
    *(_QWORD *)v8 = &std::_Ref_count_obj2<AIDE::Lib>::`vftable';
    sub_18003AD80(v8 + 16, &v12, &v16, 2LL, -2LL, v12, v13, v14, v15);
  }
  else
  {
    v9 = 0LL;
  }
  *(_QWORD *)(a1 + 16) = v9 + 16;
  v10 = *(volatile signed __int32 **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v9;
  if ( v10 )
  {
    if ( _InterlockedExchangeAdd(v10 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v10)(v10);
      if ( _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
    }
  }
  `eh vector destructor iterator'(&v16, 4uLL, 2uLL, (void (*)(void *))AIDE::AIDEFormatType::~AIDEFormatType);
  AIDE::AIDELibInitCallBacks::~AIDELibInitCallBacks((AIDE::AIDELibInitCallBacks *)&v12);
  return a1;
}


// ===== 函数: ?allocate@allocate_root_with_context_proxy@internal@tbb@@QEBAAEAVtask@3@_K@Z (0x18004BC40) =====
// attributes: thunk
struct tbb::task *__fastcall tbb::internal::allocate_root_with_context_proxy::allocate(
        tbb::internal::allocate_root_with_context_proxy *this,
        unsigned __int64 a2)
{
  return __imp_?allocate@allocate_root_with_context_proxy@internal@tbb@@QEBAAEAVtask@3@_K@Z(this, a2);
}


// ===== 函数: sub_18003CC70 (0x18003CC70) =====
_QWORD *__fastcall sub_18003CC70(_QWORD *a1, __int64 a2, void **a3)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdi

  v4 = sub_180031D20((ai *)0x80, a2, a3);
  v5 = v4;
  if ( v4 )
  {
    *(_OWORD *)v4 = 0LL;
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)(v4 + 12) = 1;
    *(_QWORD *)v4 = &std::_Ref_count_obj2<AideSyncExecutionContext>::`vftable';
    *(_OWORD *)(v4 + 16) = 0LL;
    *(_OWORD *)(v4 + 32) = 0LL;
    *(_OWORD *)(v4 + 48) = 0LL;
    *(_OWORD *)(v4 + 64) = 0LL;
    *(_OWORD *)(v4 + 80) = 0LL;
    *(_OWORD *)(v4 + 96) = 0LL;
    *(_OWORD *)(v4 + 112) = 0LL;
    sub_18003EB40(v4 + 16);
    *(_QWORD *)(v5 + 16) = &AideSyncExecutionContext::`vftable';
  }
  else
  {
    v5 = 0LL;
  }
  a1[1] = 0LL;
  *a1 = v5 + 16;
  a1[1] = v5;
  return a1;
}


// ===== 函数: ?init@task_group_context@tbb@@IEAAXXZ (0x18004BC58) =====
// attributes: thunk
void __fastcall tbb::task_group_context::init(tbb::task_group_context *this)
{
  __imp_?init@task_group_context@tbb@@IEAAXXZ(this);
}


// ===== 函数: sub_1800427E0 (0x1800427E0) =====
__int64 __fastcall sub_1800427E0(__int64 a1, unsigned int a2, void **a3, __int128 *a4, __int64 a5)
{
  __int64 v7; // r14
  __int64 v8; // r15
  _DWORD *v9; // r12
  int v10; // eax
  _QWORD *v11; // rax
  __int64 (__fastcall *v12)(_QWORD, __int64, __int64); // rbx
  __int64 v13; // rax
  unsigned int v14; // esi
  int v15; // eax
  _QWORD *v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 (__fastcall *v19)(__int64); // rdi
  __int64 (__fastcall *v20)(__int64, __int64); // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  unsigned int v23; // edi
  void (*v24)(const char *, const char *, _QWORD, _QWORD, __int64, const char *, ...); // rbx
  __int64 v25; // rax
  unsigned int v27; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v28; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v29; // [rsp+60h] [rbp-A0h]
  void **v30; // [rsp+68h] [rbp-98h]
  __int64 v31; // [rsp+70h] [rbp-90h]
  char v32; // [rsp+78h] [rbp-88h]
  __int64 v33; // [rsp+80h] [rbp-80h]
  __int64 v34; // [rsp+88h] [rbp-78h]
  const char *v35; // [rsp+90h] [rbp-70h]
  const char *v36; // [rsp+98h] [rbp-68h]
  __int16 v37; // [rsp+A0h] [rbp-60h]
  __int64 v38; // [rsp+A8h] [rbp-58h]
  _BYTE pExceptionObject[40]; // [rsp+B0h] [rbp-50h] BYREF
  __int128 v40; // [rsp+D8h] [rbp-28h] BYREF
  __int128 v41; // [rsp+E8h] [rbp-18h]

  v38 = -2LL;
  v30 = a3;
  v31 = a1;
  v29 = a5;
  v40 = 0LL;
  v41 = 0LL;
  v32 = 0;
  if ( gAIDevUtilsSuite )
  {
    v7 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
    v33 = v7;
    v8 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
    v34 = v8;
  }
  else
  {
    v8 = v34;
    v7 = v33;
  }
  v35 = "SingleThreadedTotal Time";
  v36 = "MtRasterizationTime";
  v37 = 0;
  sub_1800153F0((unsigned __int64 *)&v28, 0LL, a3);
  v9 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL);
  if ( dword_180074B10 > *v9 )
  {
    Init_thread_header(&dword_180074B10);
    if ( dword_180074B10 == -1 )
    {
      xmmword_180074AF0 = 0LL;
      qword_180074B00 = (__int64)"AI Art Set Generator Suite";
      dword_180074B08 = 3;
      byte_180074B0C = 0;
      Init_thread_footer(&dword_180074B10);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074AF0 + 1) && qword_1800740D8 )
  {
    v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
            qword_180074B00,
            (unsigned int)dword_180074B08,
            (char *)&xmmword_180074AF0 + 8);
    if ( v10 )
    {
      sub_180003F80((__int64)pExceptionObject, v10, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !byte_180074B0C )
    {
      v11 = sub_180012E90();
      *(_QWORD *)&xmmword_180074AF0 = *v11;
      *v11 = &xmmword_180074AF0;
    }
  }
  v12 = *(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*((_QWORD *)&xmmword_180074AF0 + 1) + 24LL);
  v13 = sub_180015740((__int64)&v28);
  v14 = v12(a2, v13, 1LL);
  if ( !v14 )
  {
    if ( a4 )
    {
      v40 = *a4;
      v41 = a4[1];
LABEL_20:
      v17 = sub_180015740((__int64)&v28);
      v14 = sub_180042F70(v31, v17, (__int64)v30, (__int64)&v40, v29);
      goto LABEL_21;
    }
    v27 = 1;
    if ( dword_180074868 > *v9 )
    {
      Init_thread_header(&dword_180074868);
      if ( dword_180074868 == -1 )
      {
        xmmword_180074848 = 0LL;
        qword_180074858 = (__int64)"AI Preference Suite";
        dword_180074860 = 7;
        byte_180074864 = 0;
        Init_thread_footer(&dword_180074868);
      }
    }
    if ( !*((_QWORD *)&xmmword_180074848 + 1) && qword_1800740D8 )
    {
      v15 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
              qword_180074858,
              (unsigned int)dword_180074860,
              (char *)&xmmword_180074848 + 8);
      if ( v15 )
      {
        sub_180003F80((__int64)pExceptionObject, v15, 0LL);
        throw (ai::Error *)pExceptionObject;
      }
      if ( !byte_180074864 )
      {
        v16 = sub_180012E90();
        *(_QWORD *)&xmmword_180074848 = *v16;
        *v16 = &xmmword_180074848;
      }
    }
    (**((void (__fastcall ***)(const char *, const char *, unsigned int *))&xmmword_180074848 + 1))(
      "SmartExportUI",
      "IncludeBleedInExport",
      &v27);
    v14 = sub_1800439A0(a2, &v40, v27);
    if ( !v14 )
      goto LABEL_20;
  }
LABEL_21:
  sub_180015530(&v28);
  v18 = gAIDevUtilsSuite;
  if ( gAIDevUtilsSuite )
  {
    v19 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
    v20 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
    v21 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v8);
    v22 = v20(v21, v7);
    v23 = v19(v22);
    v18 = gAIDevUtilsSuite;
  }
  else
  {
    v23 = 0;
  }
  v24 = *(void (**)(const char *, const char *, _QWORD, _QWORD, __int64, const char *, ...))(v18 + 248);
  v25 = sub_18000D970();
  v24(
    "MtRasterizationTime",
    "SingleThreadedTotal Time",
    v23,
    0LL,
    v25,
    "%u,%s,%s",
    v23,
    "MtRasterizationTime",
    "SingleThreadedTotal Time");
  return v14;
}


// ===== 函数: sub_1800439A0 (0x1800439A0) =====
__int64 __fastcall sub_1800439A0(unsigned int a1, double *a2, int a3)
{
  unsigned int v6; // ebx
  int v7; // eax
  _QWORD *v8; // rax
  __m128d v9; // xmm2
  __int64 v11; // [rsp+20h] [rbp-78h] BYREF
  _BYTE v12[8]; // [rsp+28h] [rbp-70h] BYREF
  __int64 v13; // [rsp+30h] [rbp-68h]
  _BYTE pExceptionObject[40]; // [rsp+38h] [rbp-60h] BYREF
  __m128d v15; // [rsp+60h] [rbp-38h] BYREF
  __int128 v16; // [rsp+70h] [rbp-28h]

  v13 = -2LL;
  sub_180035940(v12);
  sub_180035F90(v12, &v11, a1);
  if ( v11 )
  {
    v6 = sub_1800361C0(&v11, a2);
    sub_180035AA0(&v11);
  }
  else
  {
    sub_180035AA0(&v11);
    v6 = 1346458189;
  }
  sub_1800359F0(v12);
  if ( a3 )
  {
    v15 = 0LL;
    v16 = 0LL;
    if ( !v6 )
    {
      if ( dword_180074A40 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                       + 4LL) )
      {
        Init_thread_header(&dword_180074A40);
        if ( dword_180074A40 == -1 )
        {
          xmmword_180074A20 = 0LL;
          qword_180074A30 = (__int64)"AI Document Suite";
          dword_180074A38 = 21;
          byte_180074A3C = 0;
          Init_thread_footer(&dword_180074A40);
        }
      }
      if ( !*((_QWORD *)&xmmword_180074A20 + 1) && qword_1800740D8 )
      {
        v7 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
               qword_180074A30,
               (unsigned int)dword_180074A38,
               (char *)&xmmword_180074A20 + 8);
        if ( v7 )
        {
          sub_180003F80((__int64)pExceptionObject, v7, 0LL);
          throw (ai::Error *)pExceptionObject;
        }
        if ( !byte_180074A3C )
        {
          v8 = sub_180012E90();
          *(_QWORD *)&xmmword_180074A20 = *v8;
          *v8 = &xmmword_180074A20;
        }
      }
      v6 = (*(__int64 (__fastcall **)(__m128d *))(*((_QWORD *)&xmmword_180074A20 + 1) + 560LL))(&v15);
      if ( !v6 )
      {
        v9 = v15;
        *a2 = *a2 - v15.m128d_f64[0];
        a2[3] = a2[3] - *((double *)&v16 + 1);
        a2[2] = *(double *)&v16 + a2[2];
        a2[1] = _mm_unpackhi_pd(v9, v9).m128d_f64[0] + a2[1];
      }
    }
  }
  return v6;
}


// ===== 函数: ?internal_push_back@concurrent_vector_base_v3@internal@tbb@@IEAAPEAX_KAEA_K@Z (0x18004BC6A) =====
// attributes: thunk
void *__fastcall tbb::internal::concurrent_vector_base_v3::internal_push_back(
        tbb::internal::concurrent_vector_base_v3 *this,
        unsigned __int64 a2,
        unsigned __int64 *a3)
{
  return __imp_?internal_push_back@concurrent_vector_base_v3@internal@tbb@@IEAAPEAX_KAEA_K@Z(this, a2, a3);
}


// ===== 函数: sub_180039170 (0x180039170) =====
__int64 __fastcall sub_180039170(__int64 a1)
{
  int v3; // [rsp+48h] [rbp+10h] BYREF

  *(_DWORD *)a1 = 0;
  unknown_libname_2((_QWORD *)(a1 + 8));
  *(_DWORD *)(a1 + 16) = 1;
  *(_OWORD *)(a1 + 24) = 0LL;
  *(_OWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_WORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 1;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 1LL;
  sub_180038C40(a1 + 104);
  sub_180038CC0(a1 + 120);
  *(_DWORD *)(a1 + 136) = 4;
  *(_WORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = 1;
  *(_QWORD *)(a1 + 148) = 2LL;
  v3 = 1;
  (*(void (__fastcall **)(_QWORD, const char *, int *))gAIPreferenceSuite)(0LL, "AlignToPixelGridDuringExport", &v3);
  if ( !v3 )
    *(_DWORD *)(a1 + 144) |= 4u;
  return a1;
}


// ===== 函数: sub_180038C40 (0x180038C40) =====
_QWORD *__fastcall sub_180038C40(_QWORD *a1, __int64 a2, void **a3)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdx

  v4 = sub_180031D20((ai *)0x20, a2, a3);
  v5 = v4;
  if ( v4 )
  {
    *(_OWORD *)v4 = 0LL;
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)(v4 + 12) = 1;
    *(_QWORD *)v4 = &std::_Ref_count_obj2<ai::AutoBuffer<unsigned char,unsigned __int64,ai::SPAlloc>>::`vftable';
    *(_QWORD *)(v4 + 16) = 0LL;
    *(_QWORD *)(v4 + 24) = 0LL;
  }
  else
  {
    v5 = 0LL;
  }
  *a1 = v5 + 16;
  a1[1] = v5;
  return a1;
}


// ===== 函数: sub_180038CC0 (0x180038CC0) =====
_QWORD *__fastcall sub_180038CC0(_QWORD *a1, __int64 a2, void **a3)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdx

  v4 = sub_180031D20((ai *)0x30, a2, a3);
  v5 = v4;
  if ( v4 )
  {
    *(_OWORD *)v4 = 0LL;
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)(v4 + 12) = 1;
    *(_QWORD *)v4 = &std::_Ref_count_obj2<std::string>::`vftable';
    *(_QWORD *)(v4 + 16) = 0LL;
    *(_BYTE *)(v4 + 16) = 0;
    *(_QWORD *)(v4 + 32) = 0LL;
    *(_QWORD *)(v4 + 40) = 15LL;
  }
  else
  {
    v5 = 0LL;
  }
  a1[1] = v5;
  *a1 = v5 + 16;
  return a1;
}


// ===== 函数: sub_180041F70 (0x180041F70) =====
__int64 __fastcall sub_180041F70(__int64 a1)
{
  __int64 result; // rax

  sub_180007340(a1, 2LL);
  *(_DWORD *)(a1 + 8) = 100000;
  *(_QWORD *)(a1 + 32) = 0LL;
  result = a1;
  *(_DWORD *)(a1 + 12) = -100000;
  *(_DWORD *)(a1 + 16) = -100000;
  *(_QWORD *)(a1 + 20) = 100000LL;
  return result;
}


// ===== 函数: sub_180041070 (0x180041070) =====
void __fastcall sub_180041070(__int64 a1)
{
  *(_DWORD *)(a1 + 8) = 1;
}


// ===== 函数: sub_18002B3B0 (0x18002B3B0) =====
__int64 __fastcall sub_18002B3B0(__int64 a1, _QWORD **a2, void **a3)
{
  unsigned __int64 v5; // rdx
  __int128 *v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int128 v11; // [rsp+48h] [rbp-40h] BYREF
  _QWORD v12[2]; // [rsp+60h] [rbp-28h] BYREF
  char v13; // [rsp+70h] [rbp-18h] BYREF
  unsigned __int8 v14; // [rsp+A0h] [rbp+18h]

  v11 = 0LL;
  v5 = sub_180031D20((ai *)0x20, (__int64)a2, a3);
  *(_QWORD *)v5 = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)(v5 + 16) = v5;
  *(_WORD *)(v5 + 24) = 257;
  *(_QWORD *)&v11 = v5;
  v6 = (__int128 *)(a1 + 64);
  if ( &v11 != v6 )
  {
    *(_QWORD *)(v5 + 8) = v5;
    *(_QWORD *)v5 = v5;
    *(_QWORD *)(v5 + 16) = v5;
    *((_QWORD *)&v11 + 1) = 0LL;
    sub_18000B000(&v11, v6, v14);
    v5 = v11;
  }
  v12[0] = a2;
  v12[1] = **a2;
  sub_180026B40(
    (unsigned int)&v13,
    *(_QWORD *)v5,
    v5,
    (unsigned int)&unk_180058410,
    (__int64)&unk_180058413,
    (__int64)v12);
  v7 = v11;
  v8 = *(_QWORD *)(v11 + 8);
  if ( !*(_BYTE *)(v8 + 25) )
  {
    do
    {
      sub_18000B870(&v11, &v11, *(_QWORD *)(v8 + 16));
      v9 = v8;
      v8 = *(_QWORD *)v8;
      sub_18001AE10(v9);
    }
    while ( !*(_BYTE *)(v8 + 25) );
    v7 = v11;
  }
  return sub_18001AE10(v7);
}


// ===== 函数: sub_180026B40 (0x180026B40) =====
_OWORD *__fastcall sub_180026B40(
        _OWORD *a1,
        __int64 *a2,
        __int64 *a3,
        unsigned __int8 *a4,
        unsigned __int8 *a5,
        __int128 *a6)
{
  __int64 *v8; // rbx
  unsigned __int8 v10; // al
  __int64 **v11; // rax
  __int64 *k; // rax
  __int64 *m; // rcx
  __int64 v14; // rax
  __int64 v15; // rdx
  void **v16; // r8
  __int64 v17; // rax
  __int64 v18; // rbp
  unsigned __int64 v19; // rax
  __int64 **v20; // rax
  __int64 *i; // rax
  __int64 *j; // rcx
  __int64 v24; // [rsp+20h] [rbp-98h]
  __int128 v25; // [rsp+28h] [rbp-90h] BYREF
  __int64 v26; // [rsp+38h] [rbp-80h]
  __int64 v27; // [rsp+40h] [rbp-78h]
  __int128 v28; // [rsp+50h] [rbp-68h] BYREF
  __int128 v29; // [rsp+60h] [rbp-58h]
  __int64 v30; // [rsp+70h] [rbp-48h]
  _BYTE v31[24]; // [rsp+78h] [rbp-40h] BYREF

  v24 = -2LL;
  v8 = a2;
  v25 = *a6;
  while ( v8 != a3 )
  {
    if ( a4 == a5 )
      break;
    v10 = *((_BYTE *)v8 + 26);
    if ( v10 >= *a4 )
    {
      if ( v10 <= *a4 )
      {
        v14 = sub_180026260(v25, v31, *((_QWORD *)&v25 + 1), (char *)v8 + 26, v24);
        v28 = *(_OWORD *)v14;
        v29 = v28;
        v30 = *(_QWORD *)(v14 + 16);
        if ( (_BYTE)v30 )
        {
          v17 = v29;
        }
        else
        {
          if ( *(_QWORD *)(v25 + 8) == 0x7FFFFFFFFFFFFFFLL )
            std::vector<void *>::_Xlen();
          v18 = *(_QWORD *)v25;
          v26 = v25;
          v27 = 0LL;
          v19 = sub_180031D20((ai *)0x20, v15, v16);
          *(_BYTE *)(v19 + 26) = *((_BYTE *)v8 + 26);
          *(_QWORD *)v19 = v18;
          *(_QWORD *)(v19 + 8) = v18;
          *(_QWORD *)(v19 + 16) = v18;
          *(_WORD *)(v19 + 24) = 0;
          v27 = 0LL;
          v17 = sub_180013B10((_QWORD *)v25, (__int64)&v28, v19);
        }
        *((_QWORD *)&v25 + 1) = v17;
        sub_180027C30((char *)&v25 + 8);
        v20 = (__int64 **)v8[2];
        if ( *((_BYTE *)v20 + 25) )
        {
          for ( i = (__int64 *)v8[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
          {
            if ( v8 != (__int64 *)i[2] )
              break;
            v8 = i;
          }
          v8 = i;
        }
        else
        {
          v8 = (__int64 *)v8[2];
          for ( j = *v20; !*((_BYTE *)j + 25); j = (__int64 *)*j )
            v8 = j;
        }
      }
      ++a4;
    }
    else
    {
      v11 = (__int64 **)v8[2];
      if ( *((_BYTE *)v11 + 25) )
      {
        for ( k = (__int64 *)v8[1]; !*((_BYTE *)k + 25); k = (__int64 *)k[1] )
        {
          if ( v8 != (__int64 *)k[2] )
            break;
          v8 = k;
        }
        v8 = k;
      }
      else
      {
        v8 = (__int64 *)v8[2];
        for ( m = *v11; !*((_BYTE *)m + 25); m = (__int64 *)*m )
          v8 = m;
      }
    }
  }
  *a1 = v25;
  return a1;
}


// ===== 函数: sub_180026260 (0x180026260) =====
__int64 __fastcall sub_180026260(__int64 **a1, __int64 a2, __int64 *a3, unsigned __int8 *a4)
{
  __int64 *v5; // rbp
  unsigned __int8 v8; // r8
  unsigned __int8 v9; // si
  unsigned __int8 v10; // al
  __int64 *v11; // rdx
  __int64 *v12; // rax
  __int64 *v13; // rcx
  __int64 *v14; // r9
  __int64 *v15; // r10
  __int64 *i; // rax
  char v17; // cl
  __int64 result; // rax
  __int64 v19; // rax
  __int64 v20; // rdx
  __int64 *v21; // rax
  char v22; // cl
  __int128 v23; // [rsp+20h] [rbp-38h]
  __int64 *v24; // [rsp+60h] [rbp+8h] BYREF

  v5 = *a1;
  if ( *((_BYTE *)a3 + 25) )
  {
    if ( *(_BYTE *)(v5[1] + 25) || (v8 = *a4, *(_BYTE *)(v5[2] + 26) < *a4) )
    {
      *(_QWORD *)a2 = v5[2];
      *(_BYTE *)(a2 + 16) = 0;
LABEL_39:
      *(_DWORD *)(a2 + 8) = 0;
      return a2;
    }
    goto LABEL_26;
  }
  v9 = *a4;
  v8 = *a4;
  v10 = *((_BYTE *)a3 + 26);
  if ( a3 == (__int64 *)*v5 )
  {
    if ( v9 < v10 )
    {
      *(_QWORD *)a2 = a3;
      *(_DWORD *)(a2 + 8) = 1;
      *(_BYTE *)(a2 + 16) = 0;
      return a2;
    }
    goto LABEL_26;
  }
  if ( v9 >= v10 )
  {
    if ( v9 <= v10 )
    {
      *(_QWORD *)a2 = a3;
      *(_BYTE *)(a2 + 16) = 1;
      goto LABEL_39;
    }
    v24 = a3;
    v19 = sub_180027C30(&v24);
    v20 = *(_QWORD *)v19;
    if ( !*(_BYTE *)(*(_QWORD *)v19 + 25LL) )
    {
      v8 = v9;
      if ( v9 >= *(_BYTE *)(v20 + 26) )
      {
LABEL_26:
        v21 = (__int64 *)v5[1];
        *(_QWORD *)&v23 = v21;
        DWORD2(v23) = 0;
        while ( !*((_BYTE *)v21 + 25) )
        {
          *(_QWORD *)&v23 = v21;
          if ( *((_BYTE *)v21 + 26) >= v8 )
          {
            v5 = v21;
            DWORD2(v23) = 1;
            v21 = (__int64 *)*v21;
          }
          else
          {
            v21 = (__int64 *)v21[2];
            DWORD2(v23) = 0;
          }
        }
        if ( *((_BYTE *)v5 + 25) || *a4 < *((_BYTE *)v5 + 26) )
        {
          *(_BYTE *)(a2 + 16) = 0;
          *(_OWORD *)a2 = v23;
        }
        else
        {
          *(_QWORD *)a2 = v5;
          *(_DWORD *)(a2 + 8) = 2;
          *(_BYTE *)(a2 + 16) = 1;
        }
        return a2;
      }
    }
    v22 = *(_BYTE *)(a3[2] + 25);
    result = a2;
    *(_BYTE *)(a2 + 16) = 0;
    if ( v22 )
    {
      *(_QWORD *)a2 = a3;
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      *(_QWORD *)a2 = v20;
      *(_DWORD *)(a2 + 8) = 1;
    }
  }
  else
  {
    v11 = (__int64 *)*a3;
    v12 = a3;
    if ( *(_BYTE *)(*a3 + 25) )
    {
      v11 = (__int64 *)a3[1];
      v13 = a3;
      if ( !*((_BYTE *)v11 + 25) )
      {
        v14 = a3;
        v15 = a3;
        do
        {
          v13 = v15;
          if ( v14 != (__int64 *)*v11 )
            break;
          v12 = v11;
          v11 = (__int64 *)v11[1];
          v14 = v12;
          v15 = v12;
          v13 = v12;
        }
        while ( !*((_BYTE *)v11 + 25) );
      }
      if ( *((_BYTE *)v12 + 25) )
        v11 = v13;
    }
    else
    {
      for ( i = (__int64 *)v11[2]; !*((_BYTE *)i + 25); i = (__int64 *)i[2] )
        v11 = i;
    }
    if ( *((_BYTE *)v11 + 26) >= v8 )
      goto LABEL_26;
    v17 = *(_BYTE *)(v11[2] + 25);
    result = a2;
    *(_BYTE *)(a2 + 16) = 0;
    if ( v17 )
    {
      *(_QWORD *)a2 = v11;
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      *(_QWORD *)a2 = a3;
      *(_DWORD *)(a2 + 8) = 1;
    }
  }
  return result;
}


// ===== 函数: sub_180013B10 (0x180013B10) =====
__int64 __fastcall sub_180013B10(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v4; // r11
  _QWORD *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rax
  __int64 v9; // rdx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rdx
  _QWORD *v16; // r8
  __int64 v17; // rcx
  _QWORD *v18; // rcx
  _QWORD *v19; // r8
  __int64 v20; // rcx
  _QWORD *v21; // rcx
  _QWORD *v22; // rcx

  ++a1[1];
  v4 = (_QWORD *)*a1;
  v6 = *(_QWORD **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 24) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (_QWORD *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (_QWORD *)v4[2] )
      v4[2] = a3;
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 24LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 24) )
      {
        v13 = *(_QWORD **)(v9 + 16);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 16) = *v13;
          if ( !*(_BYTE *)(*v13 + 25LL) )
            *(_QWORD *)(*v13 + 8LL) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == *(_QWORD *)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 16LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 25) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == *(_QWORD **)(*a1 + 8LL) )
        {
          *(_QWORD *)(*a1 + 8LL) = v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 24) )
      {
        v19 = *(_QWORD **)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = v19[2];
          v20 = v19[2];
          if ( !*(_BYTE *)(v20 + 25) )
            *(_QWORD *)(v20 + 8) = v9;
          v19[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == *(_QWORD *)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v19;
          }
          else
          {
            v21 = *(_QWORD **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          v19[2] = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 25LL) )
          *(_QWORD *)(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == *(_QWORD **)(*a1 + 8LL) )
        {
          *(_QWORD *)(*a1 + 8LL) = v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v11 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 24LL) = 1;
  return a3;
}


// ===== 函数: ?_Xlen@?$vector@PEAXV?$allocator@PEAX@std@@@std@@IEBAXXZ_1 (0x180013D70) =====
void __noreturn std::vector<void *>::_Xlen()
{
  std::_Xlength_error("map/set too long");
}


// ===== 函数: sub_180027C30 (0x180027C30) =====
__int64 *__fastcall sub_180027C30(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 **v3; // r9
  __int64 i; // rax
  __int64 *j; // rcx

  v1 = *a1;
  v3 = *(__int64 ***)(*a1 + 16);
  if ( *((_BYTE *)v3 + 25) )
  {
    for ( i = *(_QWORD *)(v1 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
    {
      if ( v1 != *(_QWORD *)(i + 16) )
        break;
      *a1 = i;
      v1 = i;
    }
    *a1 = i;
    return a1;
  }
  else
  {
    for ( j = *v3; !*((_BYTE *)j + 25); j = (__int64 *)*j )
      v3 = (__int64 **)j;
    *a1 = (__int64)v3;
    return a1;
  }
}


// ===== 函数: sub_180017D30 (0x180017D30) =====
__int64 __fastcall sub_180017D30(__int64 a1)
{
  __int64 v2; // rcx
  char v4; // [rsp+20h] [rbp-48h]
  _BYTE v5[16]; // [rsp+38h] [rbp-30h] BYREF
  _QWORD v6[4]; // [rsp+48h] [rbp-20h] BYREF
  char v7; // [rsp+70h] [rbp+8h]

  v2 = *(_QWORD *)(a1 + 112);
  if ( !v2 || (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v2 + 8LL))(v2) )
    return 0LL;
  (*(void (__fastcall **)(_QWORD, _BYTE *))(**(_QWORD **)(a1 + 112) + 16LL))(*(_QWORD *)(a1 + 112), v5);
  v4 = v7;
  sub_1800175C0(a1 + 88, *(_QWORD *)(a1 + 96), v6[0], v6[1], v4);
  sub_18000E3B0(v6);
  return 1128353364LL;
}


// ===== 函数: sub_1800175C0 (0x1800175C0) =====
unsigned __int64 __fastcall sub_1800175C0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  _QWORD *v6; // rdi
  unsigned __int64 v8; // r14
  _QWORD *v9; // r11
  _QWORD *v10; // rbx
  _QWORD *v11; // rsi
  __int64 v12; // rdx
  unsigned __int64 result; // rax
  __int64 v14; // rcx
  __int64 v15; // r15
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rcx
  __int64 v19; // rax
  __int64 v20; // r12
  __int64 v21; // rax
  __int64 v22; // r13
  __int64 v23; // rdx
  __int64 v24; // rdx
  __int64 v25; // r13
  unsigned __int64 v26; // rax
  __int64 v27; // r10
  _QWORD *v28; // rdx
  _QWORD *v29; // r9
  _QWORD *v30; // r8
  __int64 v31; // rcx
  _QWORD *v32; // rbx
  _QWORD *i; // rsi
  _QWORD *v34; // r8
  _QWORD *v35; // rdx
  _QWORD *v36; // rbx
  _QWORD *v37; // [rsp+20h] [rbp-68h]
  unsigned __int64 v38; // [rsp+28h] [rbp-60h]
  __int64 v39; // [rsp+30h] [rbp-58h]
  __int64 v40; // [rsp+38h] [rbp-50h]
  __int64 v41; // [rsp+40h] [rbp-48h]
  __int64 v44; // [rsp+98h] [rbp+10h]
  _QWORD *v47; // [rsp+A8h] [rbp+20h]

  v6 = a2;
  v8 = (a4 - a3) >> 3;
  v9 = (_QWORD *)(a1 + 8);
  v37 = (_QWORD *)(a1 + 8);
  v10 = *(_QWORD **)a1;
  v11 = *(_QWORD **)(a1 + 8);
  v12 = *(_QWORD *)(a1 + 16);
  result = (v12 - (__int64)v11) >> 3;
  if ( v8 )
  {
    if ( v8 <= result )
    {
      v26 = v11 - v6;
      v27 = 8 * v8;
      if ( v8 >= v26 )
      {
        v34 = &v6[(unsigned __int64)v27 / 8];
        v47 = &v6[(unsigned __int64)v27 / 8];
        if ( v6 == v11 )
        {
          *v9 = v34;
        }
        else
        {
          v35 = v6;
          do
          {
            *v34 = *v35;
            *v35 = 0LL;
            ++v34;
            ++v35;
          }
          while ( v35 != v11 );
          *v9 = v34;
          v36 = v6;
          do
            sub_180036A90(v36++);
          while ( v36 != v11 );
        }
        try
        {
          result = sub_1800178F0(a3, a4, v6, a1);
        }
        catch ( ... )
        {
          sub_180017960(v47, *v37, a2, a1);
          sub_180017410(v47, *v37, a1);
          *v37 = v11;
          throw;
        }
      }
      else
      {
        v28 = &v11[v27 / 0xFFFFFFFFFFFFFFF8uLL];
        v29 = *(_QWORD **)(a1 + 8);
        if ( &v11[v27 / 0xFFFFFFFFFFFFFFF8uLL] != v11 )
        {
          v30 = &v11[v27 / 0xFFFFFFFFFFFFFFF8uLL];
          do
          {
            *v29 = *v30;
            *v30 = 0LL;
            ++v29;
            ++v30;
          }
          while ( v30 != v11 );
        }
        for ( *v9 = v29; v28 != v6; *v28 = v31 )
        {
          --v28;
          v31 = v28[(unsigned __int64)v27 / 8];
          v28[(unsigned __int64)v27 / 8] = *v28;
        }
        v32 = v6;
        for ( i = &v6[(unsigned __int64)v27 / 8]; v32 != i; ++v32 )
          sub_180036A90(v32);
        return sub_1800178F0(a3, a4, v6, a1);
      }
    }
    else
    {
      v14 = v11 - v10;
      v15 = 0x1FFFFFFFFFFFFFFFLL;
      if ( v8 > 0x1FFFFFFFFFFFFFFFLL - v14 )
        std::vector<void *>::_Xlen();
      v16 = v14 + v8;
      v38 = v14 + v8;
      v17 = (v12 - (__int64)v10) >> 3;
      v18 = v17 >> 1;
      if ( v17 <= 0x1FFFFFFFFFFFFFFFLL - (v17 >> 1) )
      {
        v15 = v18 + v17;
        if ( v18 + v17 < v16 )
          v15 = v16;
      }
      v19 = sub_1800182F0(a1, v15);
      try
      {
        v20 = v19;
        v41 = v19;
        v21 = v6 - v10;
        v22 = 8 * (v21 + v8);
        v40 = v20 + v22;
        v39 = v20 + 8 * v21;
        sub_1800178F0(a3, a4, v39, a1);
        v44 = v39;
        if ( v8 == 1 && v6 == v11 )
        {
          if ( v10 != v11 )
          {
            v23 = v20 - (_QWORD)v10;
            do
            {
              *(_QWORD *)((char *)v10 + v23) = *v10;
              *v10++ = 0LL;
            }
            while ( v10 != v11 );
          }
        }
        else
        {
          if ( v10 != v6 )
          {
            v24 = v20 - (_QWORD)v10;
            do
            {
              *(_QWORD *)((char *)v10 + v24) = *v10;
              *v10++ = 0LL;
            }
            while ( v10 != v6 );
          }
          v44 = v20;
          if ( v6 != v11 )
          {
            v25 = v22 - (_QWORD)v6;
            do
            {
              *(_QWORD *)((char *)v6 + v20 + v25) = *v6;
              *v6++ = 0LL;
            }
            while ( v6 != v11 );
          }
        }
        result = sub_180018240(a1, v20, v38, v15);
      }
      catch ( ... )
      {
        sub_180017410(v44, v40, a1);
        sub_18000E4E0(a1, v41, v15);
        throw;
      }
    }
  }
  return result;
}


// ===== 函数: sub_180018240 (0x180018240) =====
__int64 __fastcall sub_180018240(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rdi
  __int64 v10; // rcx
  __int64 result; // rax

  v4 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v4 != i; ++v4 )
      sub_180036A90(v4);
    v10 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v10 - *(_QWORD *)(v10 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v10 = *(_QWORD *)(v10 - 8);
    }
    sub_18001AE10(v10);
  }
  *a1 = a2;
  a1[1] = a2 + 8 * a3;
  result = a2 + 8 * a4;
  a1[2] = result;
  return result;
}


// ===== 函数: sub_1800178F0 (0x1800178F0) =====
_QWORD *__fastcall sub_1800178F0(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 i; // rbx

  for ( i = a1; i != a2; i += 8LL )
    sub_180036480(a3++, i);
  return a3;
}


// ===== 函数: sub_18000E3B0 (0x18000E3B0) =====
__int64 __fastcall sub_18000E3B0(__int64 *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rdi
  __int64 v4; // rcx
  __int64 result; // rax

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; ++v1 )
      sub_180036A90(v1);
    v4 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
    {
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_18001AE10(v4);
    result = 0LL;
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }
  return result;
}


// ===== 函数: sub_180025F40 (0x180025F40) =====
__int64 __fastcall sub_180025F40(__int64 *a1, __int64 a2, void **a3)
{
  __int64 v3; // rdi
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rcx
  __int64 i; // rbp
  __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int64 result; // rax
  unsigned __int64 v15; // rdx
  __int64 v16; // rbx
  _QWORD *v17; // rbp
  _QWORD *v18; // rdi
  _QWORD *v19; // rbx

  v3 = *a1;
  v7 = ((__int64)a3 - a2) / 40;
  v8 = (a1[2] - *a1) / 40;
  if ( v7 <= v8 )
  {
    v15 = (a1[1] - v3) / 40;
    if ( v7 <= v15 )
    {
      v17 = (_QWORD *)(v3 + 40 * v7);
      result = sub_180026160(a2, a3, v3);
      v18 = (_QWORD *)a1[1];
      if ( v17 != v18 )
      {
        v19 = v17 + 1;
        do
        {
          sub_180036A90(v19 + 1);
          sub_180036A90(v19);
          v19 += 5;
          result = (__int64)(v19 - 1);
        }
        while ( v19 - 1 != v18 );
      }
      a1[1] = (__int64)v17;
    }
    else
    {
      v16 = a2 + 40 * v15;
      sub_180026160(a2, v16, v3);
      result = sub_18000B8D0(v16, (__int64)a3, a1[1]);
      a1[1] = result;
    }
  }
  else
  {
    v9 = 0x666666666666666LL;
    if ( v7 > 0x666666666666666LL )
      std::vector<void *>::_Xlen();
    v10 = v8 >> 1;
    if ( v8 <= 0x666666666666666LL - (v8 >> 1) )
    {
      v9 = v10 + v8;
      if ( v10 + v8 < v7 )
        v9 = v7;
    }
    if ( v3 )
    {
      for ( i = a1[1]; v3 != i; v3 += 40LL )
      {
        sub_180036A90((_QWORD *)(v3 + 16));
        sub_180036A90((_QWORD *)(v3 + 8));
      }
      v12 = *a1;
      if ( (unsigned __int64)(40 * ((a1[2] - *a1) / 40)) >= 0x1000 )
      {
        if ( (unsigned __int64)(v12 - *(_QWORD *)(v12 - 8) - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v12 = *(_QWORD *)(v12 - 8);
      }
      sub_18001AE10(v12);
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }
    v13 = sub_18000E460((__int64)a1, v9, a3);
    *a1 = v13;
    a1[1] = v13;
    a1[2] = v13 + 40 * v9;
    result = sub_18000B8D0(a2, (__int64)a3, v13);
    a1[1] = result;
  }
  return result;
}


// ===== 函数: sub_180026160 (0x180026160) =====
__int64 __fastcall sub_180026160(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rdi
  int v6; // eax

  if ( a1 != a2 )
  {
    v5 = a1 + 16;
    do
    {
      *(_QWORD *)a3 = *(_QWORD *)(v5 - 16);
      sub_180036B40(a3 + 8, v5 - 8);
      sub_180036B40(a3 + 16, v5);
      *(_BYTE *)(a3 + 24) = *(_BYTE *)(v5 + 8);
      *(_DWORD *)(a3 + 28) = *(_DWORD *)(v5 + 12);
      *(_DWORD *)(a3 + 32) = *(_DWORD *)(v5 + 16);
      v6 = *(_DWORD *)(v5 + 20);
      v5 += 40LL;
      *(_DWORD *)(a3 + 36) = v6;
      a3 += 40LL;
    }
    while ( v5 - 16 != a2 );
  }
  return a3;
}


// ===== 函数: sub_180023850 (0x180023850) =====
__int64 __fastcall sub_180023850(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 *a5)
{
  unsigned int v9; // esi
  unsigned int v10; // esi
  __int64 *v11; // rdi
  __int64 *v12; // rbx
  __int64 *v13; // rax
  bool v14; // zf
  bool v15; // r8
  void **v16; // r8
  __int64 v17; // rbx
  _QWORD *v18; // rax
  volatile signed __int32 *v19; // rbx
  volatile signed __int32 *v20; // rbx
  volatile signed __int32 *v21; // rbx
  int v23; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v24; // [rsp+28h] [rbp-D8h] BYREF
  int v25; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v26; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v27; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v28; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v29; // [rsp+50h] [rbp-B0h] BYREF
  char v30; // [rsp+58h] [rbp-A8h]
  __int64 v31; // [rsp+5Ch] [rbp-A4h]
  int v32; // [rsp+64h] [rbp-9Ch]
  _QWORD v33[3]; // [rsp+68h] [rbp-98h] BYREF
  _BYTE v34[8]; // [rsp+80h] [rbp-80h] BYREF
  _QWORD v35[13]; // [rsp+88h] [rbp-78h] BYREF
  volatile signed __int32 *v36; // [rsp+F0h] [rbp-10h]
  volatile signed __int32 *v37; // [rsp+100h] [rbp+0h]
  _BYTE v38[16]; // [rsp+120h] [rbp+20h] BYREF
  _QWORD v39[20]; // [rsp+130h] [rbp+30h] BYREF

  v33[1] = -2LL;
  v33[2] = a5;
  v9 = sub_18002BFB0(a3);
  v23 = 1;
  (*(void (__fastcall **)(_QWORD, const char *, int *))gAIPreferenceSuite)(0LL, "AlignToPixelGridDuringExport", &v23);
  if ( v23 != v9 )
    (*(void (__fastcall **)(_QWORD, const char *, _QWORD))(gAIPreferenceSuite + 8))(
      0LL,
      "AlignToPixelGridDuringExport",
      v9);
  v27 = 0x3FF0000000000000LL;
  unknown_libname_2(&v28);
  unknown_libname_2(&v29);
  v30 = 0;
  v31 = 0LL;
  v32 = 0;
  sub_180039170((__int64)v34);
  v27 = *(_QWORD *)a3;
  sub_180036B40((__int64)&v28, a3 + 8);
  sub_180036B40((__int64)&v29, a3 + 16);
  v30 = *(_BYTE *)(a3 + 24);
  v31 = *(_QWORD *)(a3 + 28);
  v32 = *(_DWORD *)(a3 + 36);
  sub_180006E90((__int64)&v27);
  sub_180006AB0((__int64)&v27);
  if ( (unsigned int)(*(_DWORD *)(a3 + 28) - 1) <= 1 )
    sub_180005350(a3, a1, (__int64)&v27);
  sub_18002B190((__int64)&v27, (__int64)v34);
  unknown_libname_2(&v26);
  sub_180032600(&v26, (_QWORD *)a4);
  unknown_libname_2(&v24);
  v10 = BuildExportFilePath(a1, a3, &v26, &v24);
  if ( v10 )
  {
    v17 = *a5;
    if ( *a5 )
    {
      v18 = sub_180032AF0((__int64)&v24, v33, 0);
      sub_180017CF0(v17, (__int64)v18);
      sub_180036A90(v33);
    }
  }
  else
  {
    v11 = *(__int64 **)(a4 + 16);
    v12 = (__int64 *)v11[1];
    v13 = v11;
    if ( !*((_BYTE *)v12 + 25) )
    {
      do
      {
        if ( sub_1800326E0((__int64)(v12 + 4), (__int64)&v24) )
        {
          v12 = (__int64 *)v12[2];
        }
        else
        {
          v11 = v12;
          v12 = (__int64 *)*v12;
        }
      }
      while ( !*((_BYTE *)v12 + 25) );
      v13 = *(__int64 **)(a4 + 16);
    }
    if ( *((_BYTE *)v11 + 25)
      || (v14 = !sub_1800326E0((__int64)&v24, (__int64)(v11 + 4)), v13 = *(__int64 **)(a4 + 16), !v14) )
    {
      v11 = v13;
    }
    v15 = 1;
    if ( *(_DWORD *)(a4 + 8) )
      v15 = v11 != v13;
    if ( v15 )
    {
      sub_180039540((__int64)v34, &v24);
      sub_18003CDF0(v38, v34);
      sub_18003D250(a2, (__int64)v38, v16);
      sub_180027890(v39);
    }
  }
  sub_180032550(&v24);
  sub_180032550(&v26);
  v19 = v37;
  if ( v37 )
  {
    if ( _InterlockedExchangeAdd(v37 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v19)(v19);
      if ( _InterlockedExchangeAdd(v19 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v19 + 8LL))(v19);
    }
  }
  v20 = v36;
  if ( v36 )
  {
    if ( _InterlockedExchangeAdd(v36 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v20)(v20);
      if ( _InterlockedExchangeAdd(v20 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v20 + 8LL))(v20);
    }
  }
  sub_180032550(v35);
  sub_180036A90(&v29);
  sub_180036A90(&v28);
  v25 = 1;
  (*(void (__fastcall **)(_QWORD, const char *, int *))gAIPreferenceSuite)(0LL, "AlignToPixelGridDuringExport", &v25);
  if ( v23 != v25 )
    (*(void (__fastcall **)(_QWORD, const char *))(gAIPreferenceSuite + 8))(0LL, "AlignToPixelGridDuringExport");
  v21 = (volatile signed __int32 *)a5[1];
  if ( v21 )
  {
    if ( _InterlockedExchangeAdd(v21 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v21)(v21);
      if ( _InterlockedExchangeAdd(v21 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v21 + 8LL))(v21);
    }
  }
  return v10;
}


// ===== 函数: sub_18002B190 (0x18002B190) =====
__int64 __fastcall sub_18002B190(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rax
  __int64 v5; // rax
  _QWORD *v6; // rax
  __int64 v7; // rax
  _QWORD *v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+28h] [rbp-E0h] BYREF
  int v12; // [rsp+30h] [rbp-D8h] BYREF
  char v13; // [rsp+34h] [rbp-D4h]
  __int64 v14; // [rsp+38h] [rbp-D0h]
  int v15; // [rsp+40h] [rbp-C8h]
  int v16; // [rsp+44h] [rbp-C4h]
  _BYTE v17[16]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v18; // [rsp+58h] [rbp-B0h]
  _QWORD v19[3]; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v20; // [rsp+78h] [rbp-90h]
  __int64 v21; // [rsp+80h] [rbp-88h]
  __int128 v22; // [rsp+88h] [rbp-80h]
  __int128 v23; // [rsp+98h] [rbp-70h]
  char v24; // [rsp+A8h] [rbp-60h]
  int v25; // [rsp+AAh] [rbp-5Eh]
  __int16 v26; // [rsp+AEh] [rbp-5Ah]
  _QWORD v27[20]; // [rsp+B8h] [rbp-50h] BYREF

  v18 = -2LL;
  if ( gAIPixelPerfectionSuite )
    (*(void (**)(void))(gAIPixelPerfectionSuite + 16))();
  sub_180039250(v17);
  switch ( *(_BYTE *)(a1 + 24) )
  {
    case 0:
      *(_OWORD *)&v19[1] = 0LL;
      v20 = 0LL;
      v21 = 0LL;
      v24 = 1;
      v22 = 0LL;
      v23 = 0LL;
      v25 = 0;
      v26 = 0;
      sub_1800060B0(a1, &v19[1], v17);
      v8 = unknown_libname_2(&v11);
      v9 = sub_180038D40(v27, &v19[1], v17, v8);
      sub_180027AB0(a2, v9);
      sub_180027890(v27);
      goto LABEL_9;
    case 1:
      *(_OWORD *)&v19[1] = 0LL;
      v20 = 0LL;
      v21 = 0LL;
      v24 = 1;
      v22 = 0LL;
      v23 = 0LL;
      v25 = 0;
      v26 = 0;
      sub_180006080(a1, &v19[1], v17);
      v6 = unknown_libname_2(&v11);
      v7 = sub_180038E90(v27, &v19[1], v17, v6);
      sub_180027AB0(a2, v7);
      sub_180027890(v27);
      goto LABEL_9;
    case 0xC:
      v12 = 16868353;
      v13 = 2;
      v14 = 0x4052000000000000LL;
      v15 = -1;
      v16 = 0xFFFF;
      sub_180006170(a1, &v12, v17);
      v4 = unknown_libname_2(&v11);
      v5 = sub_180038FD0(v27, &v12, v17, v4);
      sub_180027AB0(a2, v5);
      sub_180027890(v27);
LABEL_9:
      sub_180032550(&v11);
      break;
  }
  return sub_1800394A0(a2, *(unsigned int *)(a1 + 32));
}


// ===== 函数: sub_180006080 (0x180006080) =====
__int64 __fastcall sub_180006080(__int64 a1, __int64 a2, __int64 a3)
{
  sub_1800388B0(0LL);
  return sub_1800060E0(a1, a3);
}


// ===== 函数: sub_180038D40 (0x180038D40) =====
__int64 __fastcall sub_180038D40(__int64 a1, unsigned __int8 *a2, _OWORD *a3, __int64 a4)
{
  __int64 v7; // rdx
  void **v8; // r8
  __int64 v9; // rdx
  void **v10; // r8
  int v11; // ecx
  int v12; // eax
  int v14; // [rsp+58h] [rbp+10h] BYREF

  *(_DWORD *)a1 = 0;
  sub_180032460((_QWORD *)(a1 + 8), a4);
  *(_DWORD *)(a1 + 16) = a2[64];
  *(_OWORD *)(a1 + 24) = 0LL;
  *(_OWORD *)(a1 + 40) = 0LL;
  *(_DWORD *)(a1 + 56) = *a2;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = *((_DWORD *)a2 + 1);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 66);
  *(_WORD *)(a1 + 72) = *((_WORD *)a2 + 35);
  *(_OWORD *)(a1 + 80) = *a3;
  *(_QWORD *)(a1 + 96) = 1LL;
  sub_180038C40((_QWORD *)(a1 + 104), v7, v8);
  sub_180038CC0((_QWORD *)(a1 + 120), v9, v10);
  *(_DWORD *)(a1 + 136) = a2[64] != 0 ? 4 : 0;
  *(_WORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = 1;
  *(_QWORD *)(a1 + 148) = 2LL;
  v11 = *((_DWORD *)a2 + 7);
  v12 = 1;
  if ( !a2[64] && !*((_WORD *)a2 + 33) && !*((_WORD *)a2 + 35) && !*((_WORD *)a2 + 34) )
  {
    v12 = 3;
    *(_DWORD *)(a1 + 144) = 3;
  }
  if ( v11 )
  {
    *(_WORD *)(a1 + 140) = 4;
    if ( v11 == 2 )
      *(_DWORD *)(a1 + 144) = v12 | 0x10;
  }
  else
  {
    *(_WORD *)(a1 + 140) = 0;
  }
  v14 = 1;
  (*(void (__fastcall **)(_QWORD, const char *, int *))gAIPreferenceSuite)(0LL, "AlignToPixelGridDuringExport", &v14);
  if ( !v14 )
    *(_DWORD *)(a1 + 144) |= 4u;
  return a1;
}


// ===== 函数: sub_1800394A0 (0x1800394A0) =====
void __fastcall sub_1800394A0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 152) = a2;
}


// ===== 函数: sub_180039250 (0x180039250) =====
__int64 __fastcall sub_180039250(__int64 a1, double a2)
{
  __int64 result; // rax

  *(double *)(a1 + 8) = a2;
  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 1;
  return result;
}


// ===== 函数: sub_180006170 (0x180006170) =====
__int64 __fastcall sub_180006170(__int64 a1, __int64 a2, __int64 a3)
{
  (*(void (__fastcall **)(__int64))(gImageDecoderEncoder + 112))(a2);
  return sub_1800060E0(a1, a3);
}


// ===== 函数: sub_180027AB0 (0x180027AB0) =====
__int64 __fastcall sub_180027AB0(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  volatile signed __int32 *v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rcx
  volatile signed __int32 *v10; // rsi

  v3 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v3;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_WORD *)(a1 + 72) = *(_WORD *)(a2 + 72);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a2 + 100);
  v5 = *(_QWORD *)(a2 + 104);
  v6 = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 104) = 0LL;
  *(_QWORD *)(a2 + 112) = 0LL;
  v7 = *(volatile signed __int32 **)(a1 + 112);
  *(_QWORD *)(a1 + 104) = v5;
  *(_QWORD *)(a1 + 112) = v6;
  if ( v7 )
  {
    if ( _InterlockedExchangeAdd(v7 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v7)(v7);
      if ( _InterlockedExchangeAdd(v7 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8LL))(v7);
    }
  }
  v8 = *(_QWORD *)(a2 + 120);
  v9 = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 120) = 0LL;
  *(_QWORD *)(a2 + 128) = 0LL;
  v10 = *(volatile signed __int32 **)(a1 + 128);
  *(_QWORD *)(a1 + 120) = v8;
  *(_QWORD *)(a1 + 128) = v9;
  if ( v10 )
  {
    if ( _InterlockedExchangeAdd(v10 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v10)(v10);
      if ( _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
    }
  }
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(_WORD *)(a1 + 140) = *(_WORD *)(a2 + 140);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 148);
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  return a1;
}


// ===== 函数: sub_180038FD0 (0x180038FD0) =====
__int64 __fastcall sub_180038FD0(__int64 a1, unsigned __int8 *a2, _OWORD *a3, __int64 a4)
{
  int v7; // ebp
  __int64 v8; // rdx
  void **v9; // r8
  __int64 v10; // rdx
  void **v11; // r8
  int *v12; // rbx
  int v13; // eax
  int v14; // eax
  __int64 v15; // rbx
  unsigned int v16; // eax
  __int64 v18; // [rsp+68h] [rbp+10h] BYREF

  v7 = 3;
  *(_DWORD *)a1 = 3;
  sub_180032460((_QWORD *)(a1 + 8), a4);
  *(_DWORD *)(a1 + 16) = a2[2];
  *(_OWORD *)(a1 + 24) = 0LL;
  *(_OWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = *((_DWORD *)a2 + 4);
  *(_WORD *)(a1 + 72) = *((_WORD *)a2 + 10);
  *(_OWORD *)(a1 + 80) = *a3;
  *(_DWORD *)(a1 + 96) = *a2;
  *(_DWORD *)(a1 + 100) = a2[1];
  sub_180038C40((_QWORD *)(a1 + 104), v8, v9);
  sub_180038CC0((_QWORD *)(a1 + 120), v10, v11);
  *(_DWORD *)(a1 + 136) = a2[2] != 0 ? 4 : 0;
  v12 = (int *)(a1 + 144);
  *(_DWORD *)(a1 + 144) = 1;
  *(_QWORD *)(a1 + 148) = 2LL;
  *(_WORD *)(a1 + 140) = a2[4] != 0 ? 4 : 0;
  if ( a2[4] == 2 )
  {
    v7 = 19;
    v13 = 17;
  }
  else
  {
    v13 = 1;
  }
  *(_DWORD *)(a1 + 144) = v13;
  if ( !a2[2] && !*((_WORD *)a2 + 8) && !*((_WORD *)a2 + 10) )
  {
    v14 = *v12;
    if ( !*((_WORD *)a2 + 9) )
      v14 = v7;
    *v12 = v14;
  }
  LODWORD(v18) = 1;
  (*(void (__fastcall **)(_QWORD, const char *, __int64 *))gAIPreferenceSuite)(
    0LL,
    "AlignToPixelGridDuringExport",
    &v18);
  if ( !(_DWORD)v18 )
    *v12 |= 4u;
  if ( a2[3] )
  {
    unknown_libname_2(&v18);
    v15 = *(_QWORD *)(a1 + 104);
    v16 = sub_18001E370(1LL);
    sub_18003B680(2LL, v16, v15, &v18, -2LL);
    sub_180036A90(&v18);
  }
  sub_18003CAD0(*(void **)(a1 + 120));
  return a1;
}


// ===== 函数: sub_180027890 (0x180027890) =====
void __fastcall sub_180027890(_QWORD *a1)
{
  volatile signed __int32 *v1; // rbx
  volatile signed __int32 *v3; // rbx

  v1 = (volatile signed __int32 *)a1[16];
  if ( v1 )
  {
    if ( _InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  v3 = (volatile signed __int32 *)a1[14];
  if ( v3 )
  {
    if ( _InterlockedExchangeAdd(v3 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v3)(v3);
      if ( _InterlockedExchangeAdd(v3 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v3 + 8LL))(v3);
    }
  }
  sub_180032550(a1 + 1);
}


// ===== 函数: sub_180038E90 (0x180038E90) =====
__int64 __fastcall sub_180038E90(__int64 a1, unsigned __int8 *a2, _OWORD *a3, __int64 a4)
{
  __int64 v7; // rdx
  void **v8; // r8
  __int64 v9; // rdx
  void **v10; // r8
  int v11; // ecx
  int v12; // eax
  int v14; // [rsp+58h] [rbp+10h] BYREF

  *(_DWORD *)a1 = 1;
  sub_180032460((_QWORD *)(a1 + 8), a4);
  *(_DWORD *)(a1 + 16) = a2[64];
  *(_OWORD *)(a1 + 24) = 0LL;
  *(_OWORD *)(a1 + 40) = 0LL;
  *(_DWORD *)(a1 + 56) = *a2;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = *((_DWORD *)a2 + 1);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 66);
  *(_WORD *)(a1 + 72) = *((_WORD *)a2 + 35);
  *(_OWORD *)(a1 + 80) = *a3;
  *(_QWORD *)(a1 + 96) = 1LL;
  sub_180038C40((_QWORD *)(a1 + 104), v7, v8);
  sub_180038CC0((_QWORD *)(a1 + 120), v9, v10);
  *(_DWORD *)(a1 + 136) = 4;
  *(_WORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = 1;
  *(_QWORD *)(a1 + 148) = 2LL;
  v11 = *((_DWORD *)a2 + 7);
  v12 = 1;
  if ( !a2[64] && !*((_WORD *)a2 + 33) && !*((_WORD *)a2 + 35) && !*((_WORD *)a2 + 34) )
  {
    v12 = 3;
    *(_DWORD *)(a1 + 144) = 3;
  }
  if ( v11 )
  {
    *(_WORD *)(a1 + 140) = 4;
    if ( v11 == 2 )
      *(_DWORD *)(a1 + 144) = v12 | 0x10;
  }
  else
  {
    *(_WORD *)(a1 + 140) = 0;
  }
  v14 = 1;
  (*(void (__fastcall **)(_QWORD, const char *, int *))gAIPreferenceSuite)(0LL, "AlignToPixelGridDuringExport", &v14);
  if ( !v14 )
    *(_DWORD *)(a1 + 144) |= 4u;
  return a1;
}


// ===== 函数: sub_1800060B0 (0x1800060B0) =====
__int64 __fastcall sub_1800060B0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_180038A00(0LL);
  return sub_1800060E0(a1, a3);
}


// ===== 函数: sub_18002BFB0 (0x18002BFB0) =====
__int64 __fastcall sub_18002BFB0(__int64 a1)
{
  unsigned int v1; // esi
  ai *v3; // rcx
  struct ai::IFeatureManager *FeatureManager; // rdi
  __int64 (__fastcall *v5)(struct ai::IFeatureManager *, char **); // rbx
  __int64 v6; // rdx
  void **v7; // r8
  char *v8; // rax
  __int64 v9; // rcx
  char *v10; // [rsp+28h] [rbp-30h] BYREF
  __int64 v11; // [rsp+38h] [rbp-20h]
  unsigned __int64 v12; // [rsp+40h] [rbp-18h]

  if ( (unsigned int)(*(_DWORD *)(a1 + 28) - 1) <= 1 || (v1 = 1, (unsigned __int8)sub_180006A00(a1)) )
    v1 = 0;
  if ( dword_1800743BC > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                   + 4LL) )
  {
    Init_thread_header(&dword_1800743BC);
    if ( dword_1800743BC == -1 )
    {
      FeatureManager = ai::GetFeatureManager(v3);
      v5 = *(__int64 (__fastcall **)(struct ai::IFeatureManager *, char **))(*(_QWORD *)FeatureManager + 8LL);
      v8 = (char *)sub_180031D20((ai *)0x30, v6, v7);
      v11 = 38LL;
      v12 = 47LL;
      strcpy(v8, "DisableAlignToPixelGridForRasterExport");
      v10 = v8;
      byte_1800743B8 = v5(FeatureManager, &v10);
      if ( v12 >= 0x10 )
      {
        v9 = (__int64)v10;
        if ( v12 + 1 >= 0x1000 )
        {
          v9 = *((_QWORD *)v10 - 1);
          if ( (unsigned __int64)&v10[-v9 - 8] > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v9);
      }
      v11 = 0LL;
      v12 = 15LL;
      LOBYTE(v10) = 0;
      Init_thread_footer(&dword_1800743BC);
    }
  }
  if ( byte_1800743B8 )
    return 0;
  return v1;
}


// ===== 函数: sub_180039540 (0x180039540) =====
_QWORD *__fastcall sub_180039540(__int64 a1, _QWORD *a2)
{
  return sub_180032600((_QWORD *)(a1 + 8), a2);
}


// ===== 函数: sub_180005350 (0x180005350) =====
__int64 __fastcall sub_180005350(__int64 a1, __int64 a2, __int64 a3)
{
  _OWORD v6[2]; // [rsp+20h] [rbp-38h] BYREF

  v6[0] = xmmword_180054530;
  v6[1] = xmmword_180054540;
  sub_1800395D0(v6, 1LL);
  return sub_1800053C0(a1, v6, a3);
}


// ===== 函数: sub_1800395D0 (0x1800395D0) =====
__int64 __fastcall sub_1800395D0(int a1, int a2)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 result; // rax
  unsigned int v9; // ecx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // [rsp+30h] [rbp-28h] BYREF
  _QWORD v18[4]; // [rsp+38h] [rbp-20h] BYREF
  int v19; // [rsp+70h] [rbp+18h] BYREF
  __int64 v20; // [rsp+78h] [rbp+20h] BYREF

  v18[1] = -2LL;
  v4 = sub_180007D50(&unk_1800748C6);
  if ( !(unsigned __int8)sub_180037F00(v4) )
    return 1128353364LL;
  v5 = sub_180039810(&unk_1800748BE);
  if ( !(unsigned __int8)sub_180037F00(v5) )
    return 1128353364LL;
  v20 = 0LL;
  v18[0] = 0LL;
  v6 = sub_180039810(&unk_1800748BE);
  v7 = sub_180007790(v6);
  result = (*(__int64 (__fastcall **)(__int64 *))(v7 + 32))(&v20);
  v9 = result;
  if ( !(_DWORD)result )
  {
    if ( v20 )
    {
      while ( 1 )
      {
        v19 = 0;
        v10 = sub_180039810(&unk_1800748BE);
        v11 = sub_180007790(v10);
        v9 = (*(__int64 (__fastcall **)(__int64, int *))(v11 + 96))(v20, &v19);
        if ( !v9 )
        {
          if ( !v19 )
            goto LABEL_9;
          v17 = 0LL;
          v12 = sub_180007D50(&unk_1800748C6);
          v13 = sub_180007790(v12);
          v9 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v13 + 32))(v20, &v17);
          if ( !v9 )
            break;
        }
LABEL_10:
        v16 = 0LL;
        if ( !v9 )
          v16 = v18[0];
        v20 = v16;
        if ( !v16 )
          return v9;
      }
      sub_180039A20(v17, a1, a2, 0, 0LL, 80);
LABEL_9:
      v14 = sub_180039810(&unk_1800748BE);
      v15 = sub_180007790(v14);
      v9 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(v15 + 40))(v20, v18);
      goto LABEL_10;
    }
    return v9;
  }
  return result;
}


// ===== 函数: sub_18003D250 (0x18003D250) =====
__int64 __fastcall sub_18003D250(_QWORD *a1, __int64 a2, void **a3)
{
  __int64 *v5; // rsi
  __int64 *v6; // rbx
  __int64 *v7; // rdi
  char v8; // al
  __int64 *v10; // rbx
  __int64 *v11; // rdi
  unsigned __int64 v12; // rbx
  __int128 v13; // [rsp+30h] [rbp-38h] BYREF
  __int128 v14; // [rsp+40h] [rbp-28h]

  v5 = (__int64 *)*a1;
  v6 = *(__int64 **)(*a1 + 8LL);
  v7 = (__int64 *)*a1;
  if ( !*((_BYTE *)v6 + 25) )
  {
    do
    {
      if ( (unsigned __int8)sub_18003CF30(v6 + 4, a2) )
      {
        v6 = (__int64 *)v6[2];
      }
      else
      {
        v5 = v6;
        v6 = (__int64 *)*v6;
      }
    }
    while ( !*((_BYTE *)v6 + 25) );
    v7 = (__int64 *)*a1;
  }
  if ( !*((_BYTE *)v5 + 25) )
  {
    v8 = sub_18003CF30(a2, v5 + 4);
    v7 = (__int64 *)*a1;
    if ( !v8 && v5 != v7 )
      return 0LL;
  }
  v10 = (__int64 *)v7[1];
  *(_QWORD *)&v14 = v10;
  DWORD2(v14) = 0;
  while ( !*((_BYTE *)v10 + 25) )
  {
    *(_QWORD *)&v14 = v10;
    if ( (unsigned __int8)sub_18003CF30(v10 + 4, a2) )
    {
      DWORD2(v14) = 0;
      v10 = (__int64 *)v10[2];
    }
    else
    {
      DWORD2(v14) = 1;
      v7 = v10;
      v10 = (__int64 *)*v10;
    }
  }
  if ( *((_BYTE *)v7 + 25) || (unsigned __int8)sub_18003CF30(a2, v7 + 4) )
  {
    if ( a1[1] == 0x13B13B13B13B13BLL )
      std::vector<void *>::_Xlen();
    v11 = (__int64 *)*a1;
    *(_QWORD *)&v13 = a1;
    v12 = sub_180031D20((ai *)0xD0, a2, a3);
    *((_QWORD *)&v13 + 1) = v12;
    *(_DWORD *)(v12 + 32) = *(_DWORD *)a2;
    *(_QWORD *)(v12 + 40) = *(_QWORD *)(a2 + 8);
    sub_1800271C0(v12 + 48, a2 + 16);
    *(_QWORD *)v12 = v11;
    *(_QWORD *)(v12 + 8) = v11;
    *(_QWORD *)(v12 + 16) = v11;
    *(_WORD *)(v12 + 24) = 0;
    v13 = v14;
    sub_180013B10(a1, (__int64)&v13, v12);
  }
  return 1LL;
}


// ===== 函数: sub_18003CF30 (0x18003CF30) =====
char __fastcall sub_18003CF30(_DWORD *a1, _DWORD *a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _QWORD *v7; // rdx
  bool v8; // si
  volatile signed __int32 *v9; // rdi
  volatile signed __int32 *v10; // rdi
  volatile signed __int32 *v11; // rdi
  volatile signed __int32 *v12; // rdi
  __int64 v14; // [rsp+20h] [rbp-198h] BYREF
  __int64 v15; // [rsp+28h] [rbp-190h] BYREF
  __int64 v16; // [rsp+30h] [rbp-188h] BYREF
  __int64 v17; // [rsp+38h] [rbp-180h] BYREF
  __int64 v18; // [rsp+40h] [rbp-178h] BYREF
  _QWORD v19[3]; // [rsp+48h] [rbp-170h] BYREF
  _BYTE v20[8]; // [rsp+60h] [rbp-158h] BYREF
  _QWORD v21[13]; // [rsp+68h] [rbp-150h] BYREF
  volatile signed __int32 *v22; // [rsp+D0h] [rbp-E8h]
  volatile signed __int32 *v23; // [rsp+E0h] [rbp-D8h]
  _BYTE v24[8]; // [rsp+100h] [rbp-B8h] BYREF
  _QWORD v25[13]; // [rsp+108h] [rbp-B0h] BYREF
  volatile signed __int32 *v26; // [rsp+170h] [rbp-48h]
  volatile signed __int32 *v27; // [rsp+180h] [rbp-38h]

  v19[1] = -2LL;
  if ( *a2 != *a1 )
    return 1;
  unknown_libname_2(v19);
  unknown_libname_2(&v18);
  sub_1800271C0((__int64)v24, (__int64)(a1 + 4));
  sub_1800271C0((__int64)v20, (__int64)(a2 + 4));
  v4 = sub_180039350((__int64)v24, &v17);
  v5 = sub_180032BF0((__int64)v4, &v16, 0);
  v6 = sub_180039350((__int64)v20, &v15);
  v7 = sub_180032BF0((__int64)v6, &v14, 0);
  v8 = (int)sub_1800372B0((__int64)v5, (__int64)v7) < 0;
  sub_180036A90(&v14);
  sub_180032550(&v15);
  sub_180036A90(&v16);
  sub_180032550(&v17);
  v9 = v23;
  if ( v23 )
  {
    if ( _InterlockedExchangeAdd(v23 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v9)(v9);
      if ( _InterlockedExchangeAdd(v9 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v9 + 8LL))(v9);
    }
  }
  v10 = v22;
  if ( v22 )
  {
    if ( _InterlockedExchangeAdd(v22 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v10)(v10);
      if ( _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
    }
  }
  sub_180032550(v21);
  v11 = v27;
  if ( v27 )
  {
    if ( _InterlockedExchangeAdd(v27 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v11)(v11);
      if ( _InterlockedExchangeAdd(v11 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v11 + 8LL))(v11);
    }
  }
  v12 = v26;
  if ( v26 && _InterlockedExchangeAdd(v26 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v12)(v12);
    if ( _InterlockedExchangeAdd(v12 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v12 + 8LL))(v12);
  }
  sub_180032550(v25);
  sub_180032550(&v18);
  sub_180032550(v19);
  return v8;
}


// ===== 函数: sub_1800326E0 (0x1800326E0) =====
bool __fastcall sub_1800326E0(__int64 a1, __int64 a2)
{
  __int128 *v4; // rax
  __int128 *v5; // rbx
  int v6; // eax
  _QWORD *v7; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v4 = sub_180032E90();
  v5 = v4;
  if ( !*((_QWORD *)v4 + 1) && qword_1800740D8 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v4 + 2),
           *((unsigned int *)v4 + 6),
           (__int64)v4 + 8);
    if ( v6 )
    {
      sub_180003F80((__int64)pExceptionObject, v6, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v5 + 28) )
    {
      v7 = sub_180012E90();
      *(_QWORD *)v5 = *v7;
      *v7 = v5;
    }
  }
  return (*(unsigned __int8 (__fastcall **)(__int64, __int64))(*((_QWORD *)v5 + 1) + 48LL))(a1, a2) != 0;
}


// ===== 函数: sub_18003CDF0 (0x18003CDF0) =====
__int64 __fastcall sub_18003CDF0(__int64 a1, __int64 a2)
{
  *(_DWORD *)a1 = 5;
  sub_1800271C0(a1 + 16, a2);
  *(_QWORD *)(a1 + 8) = 0LL;
  return a1;
}


// ===== 函数: sub_180017CF0 (0x180017CF0) =====
_QWORD *__fastcall sub_180017CF0(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  _QWORD *result; // rax

  v3 = a1 + 88;
  if ( *(_QWORD *)(a1 + 96) == *(_QWORD *)(a1 + 104) )
    return (_QWORD *)sub_180017450(v3, *(_QWORD *)(a1 + 96), a2);
  result = sub_180036480(*(_QWORD **)(a1 + 96), a2);
  *(_QWORD *)(a1 + 96) += 8LL;
  return result;
}


// ===== 函数: sub_1800261E0 (0x1800261E0) =====
__int64 __fastcall sub_1800261E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx
  __int64 v6; // rdi
  __int64 result; // rax

  for ( i = a3; !*(_BYTE *)(i + 25); result = sub_18001AE10(v6) )
  {
    sub_1800261E0(a1, a2, *(_QWORD *)(i + 16));
    v6 = i;
    i = *(_QWORD *)i;
    sub_180027890(v6 + 48);
  }
  return result;
}


// ===== 函数: sub_180025880 (0x180025880) =====
__int64 __fastcall sub_180025880(__int64 a1, __int64 a2, void **a3, __int64 a4)
{
  _QWORD *v6; // r15
  __int64 v7; // rsi
  unsigned int v8; // r13d
  unsigned __int64 v9; // rax
  void **v10; // r8
  __int64 *v11; // rbx
  __int64 *v12; // r8
  __int64 *v13; // rcx
  __int64 *v14; // rdx
  char v15; // r10
  __int64 *v16; // rax
  __int64 v17; // rsi
  __int64 v18; // rax
  __int64 v19; // r15
  _QWORD *v20; // r14
  _QWORD *v21; // rsi
  __int64 v22; // r14
  volatile signed __int32 *v23; // rax
  __int64 (__fastcall *v24)(__int64); // r14
  __int64 (__fastcall *v25)(__int64, __int64); // rsi
  __int64 v26; // rax
  __int64 v27; // rax
  int v28; // edx
  _QWORD *v29; // r14
  _QWORD *v30; // rsi
  __int64 v31; // rax
  const char *v32; // rdx
  __int64 **v33; // rax
  __int64 *i; // rax
  __int64 *j; // rcx
  __int64 v36; // rcx
  __int64 v37; // rbx
  __int64 v38; // rcx
  __int64 v40; // r8
  _QWORD *v41; // rdi
  _QWORD *v42; // rbx
  __int64 v43; // rax
  const char *v44; // rdx
  unsigned __int8 v45[8]; // [rsp+28h] [rbp-69h] BYREF
  __int128 v46; // [rsp+30h] [rbp-61h] BYREF
  __int64 v47; // [rsp+40h] [rbp-51h]
  unsigned int v48; // [rsp+48h] [rbp-49h]
  int v49; // [rsp+50h] [rbp-41h] BYREF
  __int64 v50; // [rsp+54h] [rbp-3Dh]
  __int64 v51; // [rsp+5Ch] [rbp-35h]
  __int64 v52; // [rsp+64h] [rbp-2Dh]
  int v53; // [rsp+6Ch] [rbp-25h]
  __int128 v54; // [rsp+70h] [rbp-21h] BYREF
  __int64 v55; // [rsp+80h] [rbp-11h] BYREF
  __int128 v56; // [rsp+88h] [rbp-9h] BYREF
  __int64 v57; // [rsp+98h] [rbp+7h] BYREF
  __int64 v58; // [rsp+A0h] [rbp+Fh]
  __int64 v59; // [rsp+A8h] [rbp+17h]
  __int64 v60; // [rsp+B0h] [rbp+1Fh]

  v60 = -2LL;
  v6 = (_QWORD *)a2;
  v7 = 0LL;
  v8 = 0;
  v48 = 2;
  if ( gASUserInteractionSuite )
  {
    v48 = (*(__int64 (**)(void))gASUserInteractionSuite)();
    (*(void (__fastcall **)(__int64))(gASUserInteractionSuite + 8))(0xFFFFFFFFLL);
  }
  v54 = 0LL;
  v9 = sub_180031D20((ai *)0x20, a2, a3);
  *(_QWORD *)v9 = v9;
  *(_QWORD *)(v9 + 8) = v9;
  *(_QWORD *)(v9 + 16) = v9;
  *(_WORD *)(v9 + 24) = 257;
  *(_QWORD *)&v54 = v9;
  sub_18002B810((__int64)v6, (unsigned __int64 *)&v54, v10);
  v49 = sub_18000CDB0(a4);
  v50 = 0LL;
  v51 = 0LL;
  v52 = 0LL;
  v53 = 0;
  v11 = *(__int64 **)v54;
  if ( !*(_BYTE *)(*(_QWORD *)v54 + 25LL) )
  {
    do
    {
      if ( gAIDevUtilsSuite )
      {
        v59 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
        v58 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
      }
      sub_1800272D0(v45, *((_BYTE *)v11 + 26));
      v46 = 0LL;
      v47 = v7;
      v12 = (__int64 *)v6[6];
      v13 = (__int64 *)v12[1];
      v14 = v12;
      v15 = *((_BYTE *)v13 + 25);
      if ( !v15 )
      {
        v16 = (__int64 *)v12[1];
        do
        {
          if ( *((_BYTE *)v16 + 32) >= *((_BYTE *)v11 + 26) )
          {
            v14 = v16;
            v16 = (__int64 *)*v16;
          }
          else
          {
            v16 = (__int64 *)v16[2];
          }
        }
        while ( !*((_BYTE *)v16 + 25) );
      }
      if ( *((_BYTE *)v14 + 25) || *((_BYTE *)v11 + 26) < *((_BYTE *)v14 + 32) || v14 == v12 )
      {
        *((_QWORD *)&v46 + 1) = v7;
      }
      else
      {
        if ( !v15 )
        {
          do
          {
            if ( *((_BYTE *)v13 + 32) >= *((_BYTE *)v11 + 26) )
            {
              v12 = v13;
              v13 = (__int64 *)*v13;
            }
            else
            {
              v13 = (__int64 *)v13[2];
            }
          }
          while ( !*((_BYTE *)v13 + 25) );
        }
        if ( *((_BYTE *)v12 + 25) || *((_BYTE *)v11 + 26) < *((_BYTE *)v12 + 32) )
        {
          std::_Xout_of_range("invalid map<K, T> key");
          __debugbreak();
        }
        if ( &v46 != (__int128 *)(v12 + 5) )
          sub_180025F40((__int64 *)&v46, v12[5], (void **)v12[6]);
        v17 = *((_QWORD *)&v46 + 1);
        sub_180026D90(&v57, v46, *((__int64 *)&v46 + 1));
        if ( v57 != v17 )
        {
          v18 = sub_1800267D0(v17, *((__int64 *)&v46 + 1), v57);
          v19 = v18;
          v20 = (_QWORD *)*((_QWORD *)&v46 + 1);
          if ( v18 != *((_QWORD *)&v46 + 1) )
          {
            v21 = (_QWORD *)(v18 + 8);
            do
            {
              sub_180036A90(v21 + 1);
              sub_180036A90(v21);
              v21 += 5;
            }
            while ( v21 - 1 != v20 );
          }
          *((_QWORD *)&v46 + 1) = v19;
          v6 = (_QWORD *)a2;
        }
      }
      v22 = *((_QWORD *)&v46 + 1);
      v7 = v46;
      if ( (_QWORD)v46 != *((_QWORD *)&v46 + 1) )
      {
        while ( 1 )
        {
          unknown_libname_2(&v55);
          sub_180032600(&v55, v6);
          v56 = 0LL;
          v23 = (volatile signed __int32 *)a3[1];
          if ( v23 )
            _InterlockedIncrement(v23 + 2);
          v56 = *(_OWORD *)a3;
          v8 = sub_1800243B0(a1, v7, v6, &v56);
          sub_180032550(&v55);
          if ( v8 == 1398034256 )
            break;
          v7 += 40LL;
          if ( v7 == v22 )
          {
            v7 = v46;
            goto LABEL_36;
          }
        }
        v40 = v46;
        if ( (_QWORD)v46 )
        {
          v41 = (_QWORD *)*((_QWORD *)&v46 + 1);
          if ( (_QWORD)v46 != *((_QWORD *)&v46 + 1) )
          {
            v42 = (_QWORD *)(v46 + 8);
            do
            {
              sub_180036A90(v42 + 1);
              sub_180036A90(v42);
              v42 += 5;
            }
            while ( v42 - 1 != v41 );
            v40 = v46;
          }
          v43 = v40;
          if ( (unsigned __int64)(40 * ((v47 - v40) / 40)) >= 0x1000 )
          {
            v40 = *(_QWORD *)(v40 - 8);
            if ( (unsigned __int64)(v43 - v40 - 8) > 0x1F )
LABEL_90:
              invalid_parameter_noinfo_noreturn();
          }
          sub_18001AE10(v40);
          v46 = 0LL;
          v47 = 0LL;
        }
        switch ( v45[0] )
        {
          case 2u:
          case 3u:
          case 4u:
          case 5u:
            (*(void (__fastcall **)(const char *, const char *, const char *))(gAIPreferenceSuite + 56))(
              "SmartExport",
              "JPEGFormatToExport",
              "JPG File Format");
            break;
          case 6u:
            v44 = "SVGFormatSmartExport";
            goto LABEL_89;
          case 7u:
            v44 = "PDFFormatSmartExport";
LABEL_89:
            (*(void (__fastcall **)(const char *, const char *, _QWORD))(gAIPreferenceSuite + 8))(
              "SmartExport",
              v44,
              0LL);
            break;
          default:
            goto LABEL_71;
        }
        goto LABEL_71;
      }
LABEL_36:
      if ( gAIDevUtilsSuite )
      {
        v24 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
        v25 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
        v26 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v58);
        v27 = v25(v26, v59);
        v28 = v24(v27);
        v7 = v46;
      }
      else
      {
        v28 = 0;
      }
      if ( *((_BYTE *)v11 + 26) >= 2u )
      {
        switch ( *((_BYTE *)v11 + 26) )
        {
          case 2:
          case 3:
          case 4:
          case 5:
            LODWORD(v50) = v28 + v50;
            break;
          case 6:
            LODWORD(v51) = v28 + v51;
            break;
          case 7:
            HIDWORD(v50) += v28;
            break;
          case 8:
            HIDWORD(v51) += v28;
            break;
          case 9:
            LODWORD(v52) = v28 + v52;
            break;
          case 0xA:
            HIDWORD(v52) += v28;
            break;
          case 0xB:
            v53 += v28;
            break;
          default:
            break;
        }
      }
      if ( v7 )
      {
        v29 = (_QWORD *)*((_QWORD *)&v46 + 1);
        if ( v7 != *((_QWORD *)&v46 + 1) )
        {
          v30 = (_QWORD *)(v7 + 8);
          do
          {
            sub_180036A90(v30 + 1);
            sub_180036A90(v30);
            v30 += 5;
          }
          while ( v30 - 1 != v29 );
          v7 = v46;
        }
        v31 = v7;
        if ( (unsigned __int64)(40 * ((v47 - v7) / 40)) >= 0x1000 )
        {
          v7 = *(_QWORD *)(v7 - 8);
          if ( (unsigned __int64)(v31 - v7 - 8) > 0x1F )
            goto LABEL_90;
        }
        sub_18001AE10(v7);
        v46 = 0LL;
        v7 = 0LL;
        v47 = 0LL;
      }
      switch ( v45[0] )
      {
        case 2u:
        case 3u:
        case 4u:
        case 5u:
          (*(void (__fastcall **)(const char *, const char *, const char *))(gAIPreferenceSuite + 56))(
            "SmartExport",
            "JPEGFormatToExport",
            "JPG File Format");
          break;
        case 6u:
          v32 = "SVGFormatSmartExport";
          goto LABEL_60;
        case 7u:
          v32 = "PDFFormatSmartExport";
LABEL_60:
          (*(void (__fastcall **)(const char *, const char *, _QWORD))(gAIPreferenceSuite + 8))("SmartExport", v32, 0LL);
          break;
        default:
          break;
      }
      v33 = (__int64 **)v11[2];
      if ( *((_BYTE *)v33 + 25) )
      {
        for ( i = (__int64 *)v11[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
        {
          if ( v11 != (__int64 *)i[2] )
            break;
          v11 = i;
        }
        v11 = i;
      }
      else
      {
        v11 = (__int64 *)v11[2];
        for ( j = *v33; !*((_BYTE *)j + 25); j = (__int64 *)*j )
          v11 = j;
      }
    }
    while ( !*((_BYTE *)v11 + 25) );
    if ( v8 )
      goto LABEL_71;
  }
  sub_18002BBC0(&v49);
LABEL_71:
  v36 = v54;
  v37 = *(_QWORD *)(v54 + 8);
  if ( !*(_BYTE *)(v37 + 25) )
  {
    do
    {
      sub_18000B870((__int64)&v54, (__int64)&v54, *(_QWORD *)(v37 + 16));
      v38 = v37;
      v37 = *(_QWORD *)v37;
      sub_18001AE10(v38);
    }
    while ( !*(_BYTE *)(v37 + 25) );
    v36 = v54;
  }
  sub_18001AE10(v36);
  if ( gASUserInteractionSuite )
    (*(void (__fastcall **)(_QWORD))(gASUserInteractionSuite + 8))(v48);
  return v8;
}


// ===== 函数: sub_18002BBC0 (0x18002BBC0) =====
void __fastcall sub_18002BBC0(_DWORD *a1)
{
  int v2; // ecx
  unsigned int v3; // edx
  void (__fastcall *v4)(const char *, const char *, _QWORD *); // rdi
  _QWORD *v5; // rax
  __int64 v6; // rcx
  int v7; // ecx
  unsigned int v8; // edx
  void (__fastcall *v9)(const char *, const char *, _QWORD *); // rdi
  _QWORD *v10; // rax
  __int64 v11; // rcx
  int v12; // ecx
  unsigned int v13; // edx
  void (__fastcall *v14)(const char *, const char *, _QWORD *); // rdi
  _QWORD *v15; // rax
  __int64 v16; // rcx
  int v17; // ecx
  unsigned int v18; // edx
  void (__fastcall *v19)(const char *, const char *, _QWORD *); // rdi
  _QWORD *v20; // rax
  __int64 v21; // rcx
  int v22; // ecx
  unsigned int v23; // edx
  void (__fastcall *v24)(const char *, const char *, _QWORD *); // rdi
  _QWORD *v25; // rax
  __int64 v26; // rcx
  int v27; // ecx
  unsigned int v28; // edx
  void (__fastcall *v29)(const char *, const char *, _QWORD *); // rdi
  _QWORD *v30; // rax
  __int64 v31; // rcx
  int v32; // ecx
  unsigned int v33; // edx
  void (__fastcall *v34)(const char *, const char *, _QWORD *); // rbx
  _QWORD *v35; // rax
  __int64 v36; // rcx
  _QWORD v37[3]; // [rsp+28h] [rbp-30h] BYREF
  unsigned __int64 v38; // [rsp+40h] [rbp-18h]

  v2 = a1[1];
  if ( v2 )
  {
    v3 = v2 + *a1;
    a1[1] = v3;
    if ( gAIAdobePIPSuite )
    {
      v4 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
      v5 = sub_18002CA00(v37, v3);
      if ( v5[3] >= 0x10uLL )
        v5 = (_QWORD *)*v5;
      v4("Smart Export", "TimeOnMainThreadForJPEGFormat", v5);
      if ( v38 >= 0x10 )
      {
        v6 = v37[0];
        if ( v38 + 1 >= 0x1000 )
        {
          v6 = *(_QWORD *)(v37[0] - 8LL);
          if ( (unsigned __int64)(v37[0] - v6 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v6);
      }
    }
  }
  v7 = a1[2];
  if ( v7 )
  {
    v8 = v7 + *a1;
    a1[2] = v8;
    if ( gAIAdobePIPSuite )
    {
      v9 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
      v10 = sub_18002CA00(v37, v8);
      if ( v10[3] >= 0x10uLL )
        v10 = (_QWORD *)*v10;
      v9("Smart Export", "TimeOnMainThreadForPDFFormat", v10);
      if ( v38 >= 0x10 )
      {
        v11 = v37[0];
        if ( v38 + 1 >= 0x1000 )
        {
          v11 = *(_QWORD *)(v37[0] - 8LL);
          if ( (unsigned __int64)(v37[0] - v11 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v11);
      }
    }
  }
  v12 = a1[3];
  if ( v12 )
  {
    v13 = v12 + *a1;
    a1[3] = v13;
    if ( gAIAdobePIPSuite )
    {
      v14 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
      v15 = sub_18002CA00(v37, v13);
      if ( v15[3] >= 0x10uLL )
        v15 = (_QWORD *)*v15;
      v14("Smart Export", "TimeOnMainThreadForSVGFormat", v15);
      if ( v38 >= 0x10 )
      {
        v16 = v37[0];
        if ( v38 + 1 >= 0x1000 )
        {
          v16 = *(_QWORD *)(v37[0] - 8LL);
          if ( (unsigned __int64)(v37[0] - v16 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v16);
      }
    }
  }
  v17 = a1[4];
  if ( v17 )
  {
    v18 = v17 + *a1;
    a1[4] = v18;
    if ( gAIAdobePIPSuite )
    {
      v19 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
      v20 = sub_18002CA00(v37, v18);
      if ( v20[3] >= 0x10uLL )
        v20 = (_QWORD *)*v20;
      v19("Smart Export", "TimeOnMainThreadForOBJFormat", v20);
      if ( v38 >= 0x10 )
      {
        v21 = v37[0];
        if ( v38 + 1 >= 0x1000 )
        {
          v21 = *(_QWORD *)(v37[0] - 8LL);
          if ( (unsigned __int64)(v37[0] - v21 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v21);
      }
    }
  }
  v22 = a1[5];
  if ( v22 )
  {
    v23 = v22 + *a1;
    a1[5] = v23;
    if ( gAIAdobePIPSuite )
    {
      v24 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
      v25 = sub_18002CA00(v37, v23);
      if ( v25[3] >= 0x10uLL )
        v25 = (_QWORD *)*v25;
      v24("Smart Export", "TimeOnMainThreadForUSDFormat", v25);
      if ( v38 >= 0x10 )
      {
        v26 = v37[0];
        if ( v38 + 1 >= 0x1000 )
        {
          v26 = *(_QWORD *)(v37[0] - 8LL);
          if ( (unsigned __int64)(v37[0] - v26 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v26);
      }
    }
  }
  v27 = a1[6];
  if ( v27 )
  {
    v28 = v27 + *a1;
    a1[6] = v28;
    if ( gAIAdobePIPSuite )
    {
      v29 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
      v30 = sub_18002CA00(v37, v28);
      if ( v30[3] >= 0x10uLL )
        v30 = (_QWORD *)*v30;
      v29("Smart Export", "TimeOnMainThreadForUSDFormat", v30);
      if ( v38 >= 0x10 )
      {
        v31 = v37[0];
        if ( v38 + 1 >= 0x1000 )
        {
          v31 = *(_QWORD *)(v37[0] - 8LL);
          if ( (unsigned __int64)(v37[0] - v31 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v31);
      }
    }
  }
  v32 = a1[7];
  if ( v32 )
  {
    v33 = v32 + *a1;
    a1[7] = v33;
    if ( gAIAdobePIPSuite )
    {
      v34 = *(void (__fastcall **)(const char *, const char *, _QWORD *))gAIAdobePIPSuite;
      v35 = sub_18002CA00(v37, v33);
      if ( v35[3] >= 0x10uLL )
        v35 = (_QWORD *)*v35;
      v34("Smart Export", "TimeOnMainThreadForGLTFFormat", v35);
      if ( v38 >= 0x10 )
      {
        v36 = v37[0];
        if ( v38 + 1 >= 0x1000 )
        {
          v36 = *(_QWORD *)(v37[0] - 8LL);
          if ( (unsigned __int64)(v37[0] - v36 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v36);
      }
    }
  }
}


// ===== 函数: sub_18002B810 (0x18002B810) =====
__int64 __fastcall sub_18002B810(__int64 a1, unsigned __int64 *a2, void **a3)
{
  unsigned __int64 v5; // rsi
  char *v6; // r15
  __int64 v7; // rdi
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rbx
  char v10; // r8
  unsigned __int64 v11; // r14
  unsigned __int8 v12; // dl
  unsigned __int8 v13; // cl
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  unsigned __int64 v16; // rdx
  unsigned __int64 *v17; // r8
  unsigned __int64 *v18; // rcx
  unsigned __int64 i; // rax
  unsigned __int64 v20; // rcx
  unsigned __int64 v21; // rax
  unsigned __int64 j; // rcx
  __int64 *v23; // rcx
  __int64 v24; // rax
  _QWORD *v25; // rdi
  __int64 v26; // rbx
  __int64 v27; // rcx
  _QWORD *v28; // r8
  __int64 **v29; // rdx
  __int64 *k; // rcx
  __int64 v31; // rcx
  __int64 m; // rax
  __int64 v33; // rbx
  __int64 v34; // rcx
  unsigned __int64 v36; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v37; // [rsp+30h] [rbp-38h]
  unsigned __int8 v38; // [rsp+80h] [rbp+18h]

  v37 = 0LL;
  v5 = sub_180031D20((ai *)0x20, (__int64)a2, a3);
  *(_QWORD *)v5 = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)(v5 + 16) = v5;
  *(_WORD *)(v5 + 24) = 257;
  v36 = v5;
  if ( &v36 != (unsigned __int64 *)(a1 + 64) )
  {
    *(_QWORD *)(v5 + 8) = v5;
    *(_QWORD *)v5 = v5;
    *(_QWORD *)(v5 + 16) = v5;
    v37 = 0LL;
    sub_18000B000(&v36, (_QWORD *)(a1 + 64), v38);
    v5 = v36;
  }
  v6 = (char *)&unk_180058410;
  do
  {
    v7 = *(_QWORD *)(v5 + 8);
    v8 = v7;
    v9 = v5;
    v10 = *(_BYTE *)(v7 + 25);
    v11 = v5;
    if ( !v10 )
    {
      v12 = *v6;
      do
      {
        v13 = *(_BYTE *)(v8 + 26);
        if ( v13 >= v12 )
        {
          if ( *(_BYTE *)(v11 + 25) && v12 < v13 )
            v11 = v8;
          v9 = v8;
          v8 = *(_QWORD *)v8;
        }
        else
        {
          v8 = *(_QWORD *)(v8 + 16);
        }
      }
      while ( !*(_BYTE *)(v8 + 25) );
    }
    v14 = *(_QWORD *)(v5 + 8);
    if ( !*(_BYTE *)(v11 + 25) )
      v14 = *(_QWORD *)v11;
    while ( !*(_BYTE *)(v14 + 25) )
    {
      if ( (unsigned __int8)*v6 >= *(_BYTE *)(v14 + 26) )
      {
        v14 = *(_QWORD *)(v14 + 16);
      }
      else
      {
        v11 = v14;
        v14 = *(_QWORD *)v14;
      }
    }
    if ( v9 == *(_QWORD *)v5 && *(_BYTE *)(v11 + 25) )
    {
      if ( !v10 )
      {
        do
        {
          sub_18000B870((__int64)&v36, (__int64)&v36, *(_QWORD *)(v7 + 16));
          v15 = v7;
          v7 = *(_QWORD *)v7;
          sub_18001AE10(v15);
        }
        while ( !*(_BYTE *)(v7 + 25) );
      }
      *(_QWORD *)(v5 + 8) = v5;
      *(_QWORD *)v5 = v5;
      *(_QWORD *)(v5 + 16) = v5;
      v37 = 0LL;
    }
    else
    {
      if ( v9 == v11 )
        goto LABEL_41;
      do
      {
        v16 = v9;
        v17 = *(unsigned __int64 **)(v9 + 16);
        if ( *((_BYTE *)v17 + 25) )
        {
          v18 = (unsigned __int64 *)(v9 + 8);
          for ( i = *(_QWORD *)(v9 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
          {
            if ( v9 != *(_QWORD *)(i + 16) )
              break;
            v9 = i;
          }
          v9 = i;
          v20 = *v18;
          if ( !*(_BYTE *)(v20 + 25) )
          {
            v21 = v16;
            do
            {
              if ( v21 != *(_QWORD *)(v20 + 16) )
                break;
              v21 = v20;
              v20 = *(_QWORD *)(v20 + 8);
            }
            while ( !*(_BYTE *)(v20 + 25) );
          }
        }
        else
        {
          v9 = *(_QWORD *)(v9 + 16);
          for ( j = *v17; !*(_BYTE *)(j + 25); j = *(_QWORD *)j )
            v9 = j;
          v23 = (__int64 *)*v17;
          if ( !*(_BYTE *)(*v17 + 25) )
          {
            do
              v23 = (__int64 *)*v23;
            while ( !*((_BYTE *)v23 + 25) );
          }
        }
        v24 = sub_18002C1F0(&v36, v16);
        sub_18001AE10(v24);
      }
      while ( v9 != v11 );
    }
    v5 = v36;
LABEL_41:
    ++v6;
  }
  while ( v6 != (char *)&unk_180058413 );
  if ( a2 != &v36 )
  {
    v25 = (_QWORD *)*a2;
    v26 = *(_QWORD *)(*a2 + 8);
    while ( !*(_BYTE *)(v26 + 25) )
    {
      sub_18000B870((__int64)a2, (__int64)a2, *(_QWORD *)(v26 + 16));
      v27 = v26;
      v26 = *(_QWORD *)v26;
      sub_18001AE10(v27);
    }
    v25[1] = v25;
    *v25 = v25;
    v25[2] = v25;
    a2[1] = 0LL;
    *(_QWORD *)(*a2 + 8) = sub_18000B3E0(a2, *(_QWORD *)(v36 + 8), (void **)*a2, v38);
    a2[1] = v37;
    v28 = (_QWORD *)*a2;
    v29 = *(__int64 ***)(*a2 + 8);
    if ( *((_BYTE *)v29 + 25) )
    {
      *v28 = v28;
      *(_QWORD *)(*a2 + 16) = *a2;
    }
    else
    {
      for ( k = *v29; !*((_BYTE *)k + 25); k = (__int64 *)*k )
        v29 = (__int64 **)k;
      *v28 = v29;
      v31 = *(_QWORD *)(*a2 + 8);
      for ( m = *(_QWORD *)(v31 + 16); !*(_BYTE *)(m + 25); m = *(_QWORD *)(m + 16) )
        v31 = m;
      *(_QWORD *)(*a2 + 16) = v31;
    }
    v5 = v36;
  }
  v33 = *(_QWORD *)(v5 + 8);
  if ( !*(_BYTE *)(v33 + 25) )
  {
    do
    {
      sub_18000B870((__int64)&v36, (__int64)&v36, *(_QWORD *)(v33 + 16));
      v34 = v33;
      v33 = *(_QWORD *)v33;
      sub_18001AE10(v34);
    }
    while ( !*(_BYTE *)(v33 + 25) );
    v5 = v36;
  }
  return sub_18001AE10(v5);
}


// ===== 函数: sub_1800272D0 (0x1800272D0) =====
unsigned __int8 *__fastcall sub_1800272D0(unsigned __int8 *a1, unsigned __int8 a2)
{
  void (__fastcall *v3)(const char *, const char *, char *); // rdi
  void **v4; // r8
  char *v5; // rcx
  char *v6; // r8
  __int64 v7; // rcx
  char *v9; // [rsp+30h] [rbp-38h] BYREF
  __int64 v10; // [rsp+40h] [rbp-28h]
  unsigned __int64 v11; // [rsp+48h] [rbp-20h]

  *a1 = a2;
  switch ( a2 )
  {
    case 2u:
    case 3u:
    case 4u:
    case 5u:
      v3 = *(void (__fastcall **)(const char *, const char *, char *))(gAIPreferenceSuite + 56);
      v9 = 0LL;
      v10 = 0LL;
      v11 = 15LL;
      if ( a2 == 2 )
      {
        v5 = (char *)sub_180031D20((ai *)0x20, 0x180000000LL, (void **)((unsigned int)a2 - 2));
        v10 = 19LL;
        v11 = 31LL;
        strcpy(v5, "JPG File Format 100");
      }
      else if ( a2 == 3 )
      {
        v5 = (char *)sub_180031D20((ai *)0x20, 0x180000000LL, (void **)((unsigned int)a2 - 3));
        v10 = 18LL;
        v11 = 31LL;
        strcpy(v5, "JPG File Format 80");
      }
      else
      {
        v4 = (void **)((unsigned int)a2 - 4);
        if ( a2 == 4 )
        {
          v5 = (char *)sub_180031D20((ai *)0x20, 0x180000000LL, v4);
          v10 = 18LL;
          v11 = 31LL;
          strcpy(v5, "JPG File Format 50");
        }
        else
        {
          if ( a2 != 5 )
          {
            v5 = v9;
            goto LABEL_12;
          }
          v5 = (char *)sub_180031D20((ai *)0x20, 0x180000000LL, v4);
          v10 = 18LL;
          v11 = 31LL;
          strcpy(v5, "JPG File Format 20");
        }
      }
      v9 = v5;
LABEL_12:
      v6 = (char *)&v9;
      if ( v11 >= 0x10 )
        v6 = v5;
      v3("SmartExport", "JPEGFormatToExport", v6);
      if ( v11 >= 0x10 )
      {
        v7 = (__int64)v9;
        if ( v11 + 1 >= 0x1000 )
        {
          v7 = *((_QWORD *)v9 - 1);
          if ( (unsigned __int64)&v9[-v7 - 8] > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v7);
      }
      return a1;
    case 6u:
      (*(void (__fastcall **)(const char *, const char *, __int64))(gAIPreferenceSuite + 8))(
        "SmartExport",
        "SVGFormatSmartExport",
        1LL);
      return a1;
    case 7u:
      (*(void (__fastcall **)(const char *, const char *, __int64))(gAIPreferenceSuite + 8))(
        "SmartExport",
        "PDFFormatSmartExport",
        1LL);
      return a1;
    default:
      return a1;
  }
}


// ===== 函数: sub_1800243B0 (0x1800243B0) =====
__int64 __fastcall sub_1800243B0(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  unsigned int v8; // ebx
  __int64 v9; // rbx
  unsigned int v10; // r12d
  __int64 *v11; // rsi
  __int64 *v12; // rdi
  __int64 *v13; // rcx
  __int64 *v14; // rax
  bool v15; // dl
  __int64 v16; // rcx
  __int64 v17; // rbx
  _QWORD *v18; // rax
  volatile signed __int32 *v19; // rbx
  __int64 v21; // [rsp+20h] [rbp-50h] BYREF
  __int64 v22; // [rsp+28h] [rbp-48h] BYREF
  __int64 v23; // [rsp+30h] [rbp-40h] BYREF
  _QWORD v24[2]; // [rsp+38h] [rbp-38h] BYREF
  __int64 v25; // [rsp+48h] [rbp-28h] BYREF
  __int64 v26; // [rsp+50h] [rbp-20h] BYREF
  __int64 v27; // [rsp+58h] [rbp-18h] BYREF
  char v28; // [rsp+60h] [rbp-10h]
  __int64 v29; // [rsp+64h] [rbp-Ch]
  int v30; // [rsp+6Ch] [rbp-4h]
  int v31; // [rsp+B8h] [rbp+48h] BYREF
  int v32; // [rsp+C0h] [rbp+50h] BYREF
  __int64 *v33; // [rsp+C8h] [rbp+58h]

  v33 = a4;
  v24[1] = -2LL;
  v8 = sub_18002BFB0(a2);
  v31 = 1;
  (*(void (__fastcall **)(_QWORD, const char *, int *))gAIPreferenceSuite)(0LL, "AlignToPixelGridDuringExport", &v31);
  if ( v31 != v8 )
    (*(void (__fastcall **)(_QWORD, const char *, _QWORD))(gAIPreferenceSuite + 8))(
      0LL,
      "AlignToPixelGridDuringExport",
      v8);
  v25 = 0x3FF0000000000000LL;
  unknown_libname_2(&v26);
  unknown_libname_2(&v27);
  v28 = 0;
  v9 = 0LL;
  v29 = 0LL;
  v30 = 0;
  v25 = *(_QWORD *)a2;
  sub_180036B40((__int64)&v26, a2 + 8);
  sub_180036B40((__int64)&v27, a2 + 16);
  v28 = *(_BYTE *)(a2 + 24);
  v29 = *(_QWORD *)(a2 + 28);
  v30 = *(_DWORD *)(a2 + 36);
  sub_180006E90((__int64)&v25);
  if ( (unsigned int)(*(_DWORD *)(a2 + 28) - 1) <= 1 )
    sub_180005350(a2, a1, (__int64)&v25);
  unknown_libname_2(&v23);
  sub_180032600(&v23, (_QWORD *)a3);
  unknown_libname_2(&v21);
  v10 = BuildExportFilePath(a1, a2, &v23, &v21);
  if ( !v10 )
  {
    v11 = *(__int64 **)(a3 + 16);
    v12 = (__int64 *)v11[1];
    v13 = v11;
    if ( !*((_BYTE *)v12 + 25) )
    {
      do
      {
        if ( sub_1800326E0((__int64)(v12 + 4), (__int64)&v21) )
        {
          v12 = (__int64 *)v12[2];
        }
        else
        {
          v11 = v12;
          v12 = (__int64 *)*v12;
        }
      }
      while ( !*((_BYTE *)v12 + 25) );
      v13 = *(__int64 **)(a3 + 16);
    }
    if ( !*((_BYTE *)v11 + 25) )
    {
      if ( !sub_1800326E0((__int64)&v21, (__int64)(v11 + 4)) )
      {
        v14 = *(__int64 **)(a3 + 16);
LABEL_17:
        v15 = 1;
        if ( *(_DWORD *)(a3 + 8) )
          v15 = v11 != v14;
        if ( v15 )
        {
          v22 = 0LL;
          if ( gAIActionManagerSuite )
          {
            (*(void (__fastcall **)(__int64 *))(gAIActionManagerSuite + 248))(&v22);
            v9 = v22;
          }
          sub_180005C10(a1, &v25, &v21, v9);
          sub_180006CE0((__int64)&v25);
          v10 = (*(__int64 (__fastcall **)(__int64))(gAIFileFormatSuite + 184))(v22);
          if ( gAIActionManagerSuite )
            (*(void (__fastcall **)(__int64))(gAIActionManagerSuite + 256))(v22);
        }
        goto LABEL_24;
      }
      v13 = *(__int64 **)(a3 + 16);
    }
    v11 = v13;
    v14 = v13;
    goto LABEL_17;
  }
LABEL_24:
  v16 = *a4;
  if ( !*a4 )
  {
LABEL_29:
    sub_180032550(&v21);
    sub_180032550(&v23);
    sub_180036A90(&v27);
    sub_180036A90(&v26);
    v32 = 1;
    (*(void (__fastcall **)(_QWORD, const char *, int *))gAIPreferenceSuite)(0LL, "AlignToPixelGridDuringExport", &v32);
    if ( v31 != v32 )
      (*(void (__fastcall **)(_QWORD, const char *))(gAIPreferenceSuite + 8))(0LL, "AlignToPixelGridDuringExport");
    v19 = (volatile signed __int32 *)a4[1];
    if ( v19 && _InterlockedExchangeAdd(v19 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v19)(v19);
      if ( _InterlockedExchangeAdd(v19 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v19 + 8LL))(v19);
    }
    return v10;
  }
  if ( !*(_DWORD *)(v16 + 80) && (unsigned int)sub_180017E80(v16) )
  {
    if ( v10 )
    {
      v17 = *a4;
      v18 = sub_180032AF0((__int64)&v21, v24, 0);
      sub_180017CF0(v17, (__int64)v18);
      sub_180036A90(v24);
    }
    goto LABEL_29;
  }
  sub_180017D30(*a4);
  sub_180032550(&v21);
  sub_180032550(&v23);
  sub_180036A90(&v27);
  sub_180036A90(&v26);
  v32 = 1;
  (*(void (__fastcall **)(_QWORD, const char *, int *))gAIPreferenceSuite)(0LL, "AlignToPixelGridDuringExport", &v32);
  if ( v31 != v32 )
    (*(void (__fastcall **)(_QWORD, const char *))(gAIPreferenceSuite + 8))(0LL, "AlignToPixelGridDuringExport");
  sub_180004840((__int64)a4);
  return 1398034256LL;
}


// ===== 函数: sub_180006CE0 (0x180006CE0) =====
__int64 __fastcall sub_180006CE0(__int64 a1)
{
  double *v1; // r8
  unsigned __int64 v2; // rdx
  __int64 result; // rax
  __int16 v4; // cx
  __int64 v5; // rax
  const char *v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // [rsp+30h] [rbp-9h] BYREF
  _BYTE v9[32]; // [rsp+40h] [rbp+7h] BYREF
  __int64 v10; // [rsp+60h] [rbp+27h]
  _QWORD v11[2]; // [rsp+68h] [rbp+2Fh] BYREF
  __int64 v12; // [rsp+78h] [rbp+3Fh]
  __int64 v13; // [rsp+80h] [rbp+47h]

  v10 = -2LL;
  v1 = (double *)a1;
  v2 = 15LL;
  v13 = 15LL;
  v12 = 10LL;
  strcpy((char *)v11, "JPEGFormat");
  v8 = a1;
  result = *(unsigned __int8 *)(a1 + 24);
  switch ( *(_BYTE *)(a1 + 24) )
  {
    case 0:
      v6 = "PNGFileFormat";
      goto LABEL_10;
    case 1:
      v6 = "PNG8";
LABEL_10:
      result = (*(__int64 (__fastcall **)(const char *, const char *, _QWORD))(gAIPreferenceSuite + 24))(
                 v6,
                 "ResolutionR",
                 (unsigned int)(int)(*v1 * 72.0));
      goto LABEL_11;
    case 2:
      v12 = 13LL;
      memmove((char *)&v11[1] + 2, "100", 3uLL);
      BYTE5(v11[1]) = 0;
      goto LABEL_4;
    case 3:
      v4 = 12344;
      goto LABEL_3;
    case 4:
      v4 = 12341;
      goto LABEL_3;
    case 5:
      v4 = 12338;
LABEL_3:
      v12 = 12LL;
      WORD1(v11[1]) = v4;
      BYTE4(v11[1]) = 0;
LABEL_4:
      v5 = sub_180004430(v9, v11, v1);
      result = sub_180004A90(&v8, v5);
LABEL_11:
      v2 = v13;
      break;
    default:
      break;
  }
  if ( v2 >= 0x10 )
  {
    v7 = v11[0];
    if ( v2 + 1 >= 0x1000 )
    {
      v7 = *(_QWORD *)(v11[0] - 8LL);
      if ( (unsigned __int64)(v11[0] - v7 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    return sub_18001AE10(v7);
  }
  return result;
}


// ===== 函数: sub_180004430 (0x180004430) =====
_QWORD *__fastcall sub_180004430(_QWORD *a1, _QWORD *a2, void **a3)
{
  _QWORD *v3; // rax
  _OWORD *v4; // rdi
  unsigned __int64 v6; // rbp
  __int64 v7; // rsi
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rcx
  _QWORD *result; // rax

  v3 = 0LL;
  v4 = a2;
  *a1 = 0LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  v6 = a2[2];
  if ( a2[3] >= 0x10uLL )
    v4 = (_OWORD *)*a2;
  if ( v6 >= 0x10 )
  {
    v7 = v6 | 0xF;
    if ( (v6 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
      v7 = 0x7FFFFFFFFFFFFFFFLL;
    if ( (unsigned __int64)(v7 + 1) < 0x1000 )
    {
      if ( v7 != -1 )
        v3 = (_QWORD *)sub_180031D20((ai *)(v7 + 1), (__int64)a2, a3);
    }
    else
    {
      if ( v7 + 40 < (unsigned __int64)(v7 + 1) )
        Concurrency::cancel_current_task();
      v8 = sub_180031D20((ai *)(v7 + 40), (__int64)a2, a3);
      v9 = v8;
      if ( !v8 )
        invalid_parameter_noinfo_noreturn();
      v3 = (_QWORD *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v3 - 1) = v9;
    }
    *a1 = v3;
    memcpy(v3, v4, v6 + 1);
  }
  else
  {
    v7 = 15LL;
    *(_OWORD *)a1 = *v4;
  }
  a1[2] = v6;
  result = a1;
  a1[3] = v7;
  return result;
}


// ===== 函数: sub_180004A90 (0x180004A90) =====
__int64 __fastcall sub_180004A90(double **a1, __int64 *a2)
{
  __int64 v3; // r8
  __int64 *v4; // rcx
  __int64 *v5; // rcx
  __int64 result; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx

  v3 = (unsigned int)(int)(**a1 * 72.0 * 65536.0);
  v4 = a2;
  if ( (unsigned __int64)a2[3] >= 0x10 )
    v4 = (__int64 *)*a2;
  (*(void (__fastcall **)(__int64 *, const char *, __int64))(gAIPreferenceSuite + 104))(v4, "DPI", v3);
  v5 = a2;
  if ( (unsigned __int64)a2[3] >= 0x10 )
    v5 = (__int64 *)*a2;
  result = (*(__int64 (__fastcall **)(__int64 *, const char *, _QWORD))(gAIPreferenceSuite + 8))(v5, "DoImageMap", 0LL);
  v7 = a2[3];
  if ( v7 >= 0x10 )
  {
    v8 = *a2;
    if ( v7 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v8 - *(_QWORD *)(v8 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v8 = *(_QWORD *)(v8 - 8);
    }
    result = sub_18001AE10(v8);
  }
  a2[2] = 0LL;
  a2[3] = 15LL;
  *(_BYTE *)a2 = 0;
  return result;
}


// ===== 函数: sub_180017E80 (0x180017E80) =====
__int64 __fastcall sub_180017E80(__int64 a1)
{
  return sub_180017EA0(a1, (unsigned int)++*(_DWORD *)(a1 + 8));
}


// ===== 函数: sub_180004840 (0x180004840) =====
__int64 __fastcall sub_180004840(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = *(volatile signed __int32 **)(a1 + 8);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8LL))(v1);
    }
  }
  return result;
}


// ===== 函数: sub_180005C10 (0x180005C10) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_180005C10(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int8 v6; // cl
  void (__fastcall *v7)(__int64, __int64, _QWORD *); // rbx
  _QWORD *v8; // rax
  __int64 *v9; // r8
  __int64 *v10; // r8
  __int64 result; // rax
  __int64 v12; // rcx
  __int64 v13; // rcx
  _QWORD v14[2]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v15[2]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v16; // [rsp+40h] [rbp-40h]
  unsigned __int64 v17; // [rsp+48h] [rbp-38h]
  __int64 v18[3]; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int64 v19; // [rsp+68h] [rbp-18h]

  v14[1] = -2LL;
  v6 = *(_BYTE *)(a2 + 24);
  v18[0] = 0LL;
  v18[2] = 0LL;
  v19 = 15LL;
  v15[0] = 0LL;
  v16 = 0LL;
  v17 = 15LL;
  sub_1800067F0(v6, v18, v15);
  v7 = *(void (__fastcall **)(__int64, __int64, _QWORD *))(gAIActionManagerSuite + 504);
  v8 = sub_180032BF0(a3, v14, 0);
  v7(a4, 1851878757LL, v8);
  sub_180036A90(v14);
  v9 = v18;
  if ( v19 >= 0x10 )
    v9 = (__int64 *)v18[0];
  (*(void (__fastcall **)(__int64, __int64, __int64 *))(gAIActionManagerSuite + 352))(a4, 1718775156LL, v9);
  v10 = v15;
  if ( v17 >= 0x10 )
    v10 = (__int64 *)v15[0];
  (*(void (__fastcall **)(__int64, __int64, __int64 *))(gAIActionManagerSuite + 352))(a4, 1702392942LL, v10);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(gAIActionManagerSuite + 368))(a4, 1936548194LL, 0LL);
  (*(void (__fastcall **)(__int64, __int64, __int64))(gAIActionManagerSuite + 368))(a4, 1700947312LL, 1LL);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(gAIActionManagerSuite + 368))(a4, 1885761141LL, 1LL);
  if ( v17 >= 0x10 )
  {
    v12 = v15[0];
    if ( v17 + 1 >= 0x1000 )
    {
      v12 = *(_QWORD *)(v15[0] - 8);
      if ( (unsigned __int64)(v15[0] - v12 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    result = sub_18001AE10(v12);
  }
  v16 = 0LL;
  v17 = 15LL;
  LOBYTE(v15[0]) = 0;
  if ( v19 >= 0x10 )
  {
    v13 = v18[0];
    if ( v19 + 1 >= 0x1000 )
    {
      v13 = *(_QWORD *)(v18[0] - 8);
      if ( (unsigned __int64)(v18[0] - v13 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    return sub_18001AE10(v13);
  }
  return result;
}


// ===== 函数: sub_180032BF0 (0x180032BF0) =====
// Hidden C++ exception states: #wind=3
_QWORD *__fastcall sub_180032BF0(__int64 a1, _QWORD *a2, unsigned __int8 a3)
{
  __int128 *v6; // rax
  __int128 *v7; // rbx
  int v8; // eax
  _QWORD *v9; // rax
  int v10; // eax
  _BYTE pExceptionObject[48]; // [rsp+30h] [rbp-48h] BYREF

  unknown_libname_2(a2);
  v6 = sub_180032E90();
  v7 = v6;
  if ( !*((_QWORD *)v6 + 1) && qword_1800740D8 )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *((_QWORD *)v6 + 2),
           *((unsigned int *)v6 + 6),
           (__int64)v6 + 8);
    if ( v8 )
    {
      sub_180003F80((__int64)pExceptionObject, v8, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*((_BYTE *)v7 + 28) )
    {
      v9 = sub_180012E90();
      *(_QWORD *)v7 = *v9;
      *v9 = v7;
    }
  }
  v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD *))(*((_QWORD *)v7 + 1) + 160LL))(a1, a3, a2);
  if ( v10 )
  {
    sub_180003F80((__int64)pExceptionObject, v10, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  return a2;
}


// ===== 函数: sub_180027790 (0x180027790) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_180027790(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned __int8)byte_180073E5C;
  if ( *(_BYTE *)(a1 + 1) )
    result = 0LL;
  byte_180073E5C = result;
  return result;
}


// ===== 函数: sub_180028220 (0x180028220) =====
// Hidden C++ exception states: #wind=3
void __fastcall sub_180028220(__int64 *a1, _QWORD *a2, __int64 *a3)
{
  _QWORD *v4; // rsi
  __int64 v6; // rdx
  void **v7; // r8
  unsigned __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // r13
  __int64 v12; // r14
  __int64 *v13; // rbx
  __int64 *v14; // rdx
  __int64 *v15; // rcx
  __int64 *v16; // r8
  char v17; // r10
  __int64 *v18; // rax
  __int64 *v19; // rdx
  __int64 v20; // rsi
  __int64 v21; // rax
  _QWORD *v22; // r15
  _QWORD *v23; // r14
  _QWORD *v24; // rsi
  __int64 v25; // r14
  __int64 v26; // rax
  __int64 v27; // rsi
  _QWORD *v28; // rax
  _QWORD *v29; // rsi
  __int64 v30; // rax
  __int64 **v31; // rax
  __int64 *i; // rax
  __int64 *j; // rcx
  volatile signed __int32 *v34; // rbx
  __int64 v35; // rbx
  __int64 v36; // rcx
  __int128 v37; // [rsp+20h] [rbp-49h] BYREF
  __int64 v38; // [rsp+30h] [rbp-39h]
  __int128 v39; // [rsp+38h] [rbp-31h] BYREF
  __int64 v40; // [rsp+48h] [rbp-21h] BYREF
  __int64 v41; // [rsp+50h] [rbp-19h] BYREF
  __int64 v42; // [rsp+58h] [rbp-11h] BYREF
  __int64 v43; // [rsp+60h] [rbp-9h] BYREF
  __int64 v44; // [rsp+68h] [rbp-1h]
  __int64 v45; // [rsp+70h] [rbp+7h]
  __int64 v46; // [rsp+78h] [rbp+Fh] BYREF
  volatile signed __int32 *v47; // [rsp+80h] [rbp+17h]
  __int64 v48; // [rsp+88h] [rbp+1Fh]
  __int64 v50; // [rsp+E8h] [rbp+7Fh] BYREF

  v48 = -2LL;
  v4 = a2;
  unknown_libname_2(&v40);
  unknown_libname_2(&v50);
  sub_180032600(&v50, v4);
  v39 = 0LL;
  v8 = sub_180031D20((ai *)0x20, v6, v7);
  *(_QWORD *)v8 = v8;
  *(_QWORD *)(v8 + 8) = v8;
  *(_QWORD *)(v8 + 16) = v8;
  *(_WORD *)(v8 + 24) = 257;
  *(_QWORD *)&v39 = v8;
  if ( &v39 != (__int128 *)(v4 + 8) )
  {
    *(_QWORD *)(v8 + 8) = v8;
    *(_QWORD *)v8 = v8;
    *(_QWORD *)(v8 + 16) = v8;
    *((_QWORD *)&v39 + 1) = 0LL;
    sub_18000B000(&v39, v4 + 8, (unsigned __int8)a2);
  }
  v9 = sub_180016BE0(qword_180074190);
  v10 = sub_18001D820(v9);
  v45 = v10;
  v11 = *a1;
  v12 = a1[1];
  v44 = v12;
  if ( v11 != v12 )
  {
    while ( 1 )
    {
      sub_180021470(v10, &v46);
      v13 = *(__int64 **)v39;
      if ( !*(_BYTE *)(*(_QWORD *)v39 + 25LL) )
        break;
LABEL_51:
      v34 = v47;
      if ( v47 )
      {
        if ( _InterlockedExchangeAdd(v47 + 2, 0xFFFFFFFF) == 1 )
        {
          (**(void (__fastcall ***)(volatile signed __int32 *))v34)(v34);
          if ( _InterlockedExchangeAdd(v34 + 3, 0xFFFFFFFF) == 1 )
            (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v34 + 8LL))(v34);
        }
      }
      v11 += 8LL;
      if ( v11 == v12 )
        goto LABEL_58;
      v10 = v45;
    }
    while ( 1 )
    {
      v37 = 0LL;
      v38 = 0LL;
      v14 = (__int64 *)v4[6];
      v15 = (__int64 *)v14[1];
      v16 = v14;
      v17 = *((_BYTE *)v15 + 25);
      if ( !v17 )
      {
        v18 = (__int64 *)v14[1];
        do
        {
          if ( *((_BYTE *)v18 + 32) >= *((_BYTE *)v13 + 26) )
          {
            v16 = v18;
            v18 = (__int64 *)*v18;
          }
          else
          {
            v18 = (__int64 *)v18[2];
          }
        }
        while ( !*((_BYTE *)v18 + 25) );
      }
      if ( *((_BYTE *)v16 + 25) || *((_BYTE *)v13 + 26) < *((_BYTE *)v16 + 32) || v16 == v14 )
        break;
      if ( !v17 )
      {
        do
        {
          if ( *((_BYTE *)v15 + 32) >= *((_BYTE *)v13 + 26) )
          {
            v14 = v15;
            v15 = (__int64 *)*v15;
          }
          else
          {
            v15 = (__int64 *)v15[2];
          }
        }
        while ( !*((_BYTE *)v15 + 25) );
      }
      if ( *((_BYTE *)v14 + 25) || *((_BYTE *)v13 + 26) < *((_BYTE *)v14 + 32) )
      {
        std::_Xout_of_range("invalid map<K, T> key");
        JUMPOUT(0x1800286A0LL);
      }
      v19 = v14 + 5;
      if ( &v37 != (__int128 *)v19 )
        sub_180025F40((__int64 *)&v37, *v19, (void **)v19[1]);
      v20 = *((_QWORD *)&v37 + 1);
      sub_180026D90(&v41, v37, *((__int64 *)&v37 + 1));
      if ( v41 != v20 )
      {
        v21 = sub_1800267D0(v20, *((__int64 *)&v37 + 1), v41);
        v22 = (_QWORD *)v21;
        v23 = (_QWORD *)*((_QWORD *)&v37 + 1);
        if ( v21 != *((_QWORD *)&v37 + 1) )
        {
          v24 = (_QWORD *)(v21 + 8);
          do
          {
            sub_180036A90(v24 + 1);
            sub_180036A90(v24);
            v24 += 5;
          }
          while ( v24 - 1 != v23 );
        }
        goto LABEL_30;
      }
      v22 = (_QWORD *)*((_QWORD *)&v37 + 1);
LABEL_31:
      v25 = v37;
      if ( (_QWORD *)v37 != v22 )
      {
        do
        {
          v26 = sub_180032310(v46, &v42);
          BuildExportFilePath(v26, v25, &v50, &v40);
          sub_180036A90(&v42);
          v27 = *a3;
          v28 = sub_180032AF0((__int64)&v40, &v43, 0);
          sub_180017CF0(v27, (__int64)v28);
          sub_180036A90(&v43);
          v25 += 40LL;
        }
        while ( (_QWORD *)v25 != v22 );
        v22 = (_QWORD *)*((_QWORD *)&v37 + 1);
        v25 = v37;
      }
      if ( v25 )
      {
        if ( (_QWORD *)v25 != v22 )
        {
          v29 = (_QWORD *)(v25 + 8);
          do
          {
            sub_180036A90(v29 + 1);
            sub_180036A90(v29);
            v29 += 5;
          }
          while ( v29 - 1 != v22 );
          v25 = v37;
        }
        v30 = v25;
        if ( (unsigned __int64)(40 * ((v38 - v25) / 40)) >= 0x1000 )
        {
          v25 = *(_QWORD *)(v25 - 8);
          if ( (unsigned __int64)(v30 - v25 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v25);
      }
      v31 = (__int64 **)v13[2];
      if ( *((_BYTE *)v31 + 25) )
      {
        for ( i = (__int64 *)v13[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
        {
          if ( v13 != (__int64 *)i[2] )
            break;
          v13 = i;
        }
        v13 = i;
      }
      else
      {
        v13 = (__int64 *)v13[2];
        for ( j = *v31; !*((_BYTE *)j + 25); j = (__int64 *)*j )
          v13 = j;
      }
      v4 = a2;
      if ( *((_BYTE *)v13 + 25) )
      {
        v12 = v44;
        goto LABEL_51;
      }
    }
    v22 = 0LL;
LABEL_30:
    *((_QWORD *)&v37 + 1) = v22;
    goto LABEL_31;
  }
LABEL_58:
  v35 = *(_QWORD *)(v39 + 8);
  while ( !*(_BYTE *)(v35 + 25) )
  {
    sub_18000B870((__int64)&v39, (__int64)&v39, *(_QWORD *)(v35 + 16));
    v36 = v35;
    v35 = *(_QWORD *)v35;
    sub_18001AE10(v36);
  }
  sub_18001AE10(v39);
  sub_180032550(&v50);
  sub_180032550(&v40);
}


// ===== 函数: sub_180016BE0 (0x180016BE0) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_180016BE0(__int64 a1)
{
  return *(_QWORD *)(a1 + 376);
}


// ===== 函数: sub_180018A30 (0x180018A30) =====
// Hidden C++ exception states: #wind=3
__int64 *__fastcall sub_180018A30(__int64 *a1, __int64 *a2)
{
  _QWORD *v2; // r15
  __int64 v3; // r8
  _QWORD *v4; // r14
  _QWORD *v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 *v11; // r15
  __int64 *v12; // r14
  _QWORD *v13; // rbx
  __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 *v17; // r15
  __int64 *v18; // r14
  _QWORD *v19; // rbx
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 *v23; // r15
  __int64 *v24; // rdi
  _QWORD *v25; // r14
  __int64 v26; // rbx
  __int64 v27; // rcx
  __int64 v28; // rcx
  __int64 v29; // rax
  __int64 v30; // rcx

  v2 = a2 + 2;
  v3 = *a1;
  v4 = a1 + 2;
  *a1 = *a2;
  *a2 = v3;
  *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
  if ( a1 + 2 != a2 + 2 )
  {
    v7 = (_QWORD *)*v4;
    sub_18000B770((__int64)(a1 + 2), (__int64)(a1 + 2), *(_QWORD *)(*v4 + 8LL));
    v7[1] = v7;
    *v7 = v7;
    v7[2] = v7;
    v4[1] = 0LL;
    v8 = *v4;
    *v4 = *v2;
    v9 = v2[1];
    *v2 = v8;
    v10 = v4[1];
    v4[1] = v9;
    v2[1] = v10;
  }
  v11 = a2 + 4;
  v12 = a1 + 4;
  if ( a1 + 4 != a2 + 4 )
  {
    v13 = (_QWORD *)*v12;
    sub_18000B7F0((__int64)(a1 + 4), (__int64)(a1 + 4), *(_QWORD *)(*v12 + 8));
    v13[1] = v13;
    *v13 = v13;
    v13[2] = v13;
    a1[5] = 0LL;
    v14 = *v12;
    *v12 = *v11;
    v15 = a2[5];
    *v11 = v14;
    v16 = a1[5];
    a1[5] = v15;
    a2[5] = v16;
  }
  v17 = a2 + 6;
  v18 = a1 + 6;
  if ( a1 + 6 != a2 + 6 )
  {
    v19 = (_QWORD *)*v18;
    sub_18000B6F0((__int64)(a1 + 6), (__int64)(a1 + 6), *(_QWORD *)(*v18 + 8));
    v19[1] = v19;
    *v19 = v19;
    v19[2] = v19;
    a1[7] = 0LL;
    v20 = *v18;
    *v18 = *v17;
    v21 = a2[7];
    *v17 = v20;
    v22 = a1[7];
    a1[7] = v21;
    a2[7] = v22;
  }
  v23 = a2 + 8;
  v24 = a1 + 8;
  if ( a1 + 8 != v23 )
  {
    v25 = (_QWORD *)*v24;
    v26 = *(_QWORD *)(*v24 + 8);
    while ( !*(_BYTE *)(v26 + 25) )
    {
      sub_18000B870((__int64)(a1 + 8), (__int64)(a1 + 8), *(_QWORD *)(v26 + 16));
      v27 = v26;
      v26 = *(_QWORD *)v26;
      sub_18001AE10(v27);
    }
    v25[1] = v25;
    *v25 = v25;
    v25[2] = v25;
    a1[9] = 0LL;
    v28 = *v24;
    *v24 = *v23;
    v29 = v23[1];
    *v23 = v28;
    v30 = a1[9];
    a1[9] = v29;
    v23[1] = v30;
  }
  return a1;
}


// ===== 函数: sub_18001E230 (0x18001E230) =====
// Hidden C++ exception states: #wind=3
__int64 sub_18001E230()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  int v2; // eax
  _QWORD *v3; // rax
  _BYTE pExceptionObject[56]; // [rsp+20h] [rbp-38h] BYREF

  v0 = sub_18001E2C0(&unk_180074222);
  v1 = v0;
  if ( !*(_QWORD *)(v0 + 8) && qword_1800740D8 )
  {
    v2 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))qword_1800740D8)(
           *(_QWORD *)(v0 + 16),
           *(unsigned int *)(v0 + 24),
           v0 + 8);
    if ( v2 )
    {
      sub_180003F80((__int64)pExceptionObject, v2, 0LL);
      throw (ai::Error *)pExceptionObject;
    }
    if ( !*(_BYTE *)(v1 + 28) )
    {
      v3 = sub_180012E90();
      *(_QWORD *)v1 = *v3;
      *v3 = v1;
    }
  }
  return *(_QWORD *)(v1 + 8);
}


// ===== 函数: sub_18001E2C0 (0x18001E2C0) =====
// Hidden C++ exception states: #wind=3
__int128 *sub_18001E2C0()
{
  _QWORD *v1; // rax

  if ( dword_180074248 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180074228;
  Init_thread_header(&dword_180074248);
  if ( dword_180074248 != -1 )
    return &xmmword_180074228;
  xmmword_180074228 = 0LL;
  qword_180074238 = (__int64)"AI Counted Object Suite";
  dword_180074240 = 3;
  byte_180074244 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180074228 = *v1;
  *v1 = &xmmword_180074228;
  Init_thread_footer(&dword_180074248);
  return &xmmword_180074228;
}


// ===== 函数: sub_18002C840 (0x18002C840) =====
// Hidden C++ exception states: #wind=3
char sub_18002C840()
{
  return 0;
}


// ===== 函数: sub_180026840 (0x180026840) =====
// Hidden C++ exception states: #wind=3
char *__fastcall sub_180026840(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // r12
  unsigned __int64 v5; // rcx
  __int64 v6; // rdx
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rax
  _QWORD *v10; // rbx
  _QWORD *v11; // rcx
  char *result; // rax
  unsigned __int64 v14; // [rsp+68h] [rbp+10h]
  _QWORD *v15; // [rsp+78h] [rbp+20h]

  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    std::vector<void *>::_Xlen();
  v4 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  v5 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3;
  v6 = v5 >> 1;
  if ( v5 > 0x1FFFFFFFFFFFFFFFLL - (v5 >> 1) )
    goto LABEL_21;
  v7 = v6 + v5;
  if ( v6 + v5 >= a2 )
  {
    if ( v7 > 0x1FFFFFFFFFFFFFFFLL )
      goto LABEL_21;
  }
  else
  {
    v7 = a2;
  }
  v8 = 8 * v7;
  v14 = v7;
  if ( 8 * v7 >= 0x1000 )
  {
    if ( v8 + 39 >= v8 )
    {
      v9 = sub_180031D20((ai *)(v8 + 39), v6, (void **)0x1FFFFFFFFFFFFFFFLL);
      if ( !v9 )
        goto LABEL_20;
      v10 = (_QWORD *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v10 - 1) = v9;
      goto LABEL_13;
    }
LABEL_21:
    Concurrency::cancel_current_task();
  }
  if ( v8 )
  {
    v10 = (_QWORD *)sub_180031D20((ai *)(8 * v7), v6, (void **)0x1FFFFFFFFFFFFFFFLL);
    v15 = v10;
    v14 = v7;
    goto LABEL_24;
  }
  v10 = 0LL;
  v14 = v7;
LABEL_13:
  v15 = v10;
LABEL_24:
  try
  {
    memset(&v10[v4], 0, 8 * (a2 - v4));
    memmove(v10, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  }
  catch ( ... )
  {
    sub_18000E4E0(a1, v15, v14);
    throw;
  }
  v11 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 16) - (_QWORD)v11) & 0xFFFFFFFFFFFFFFF8uLL) < 0x1000 )
    {
LABEL_18:
      sub_18001AE10((__int64)v11);
      goto LABEL_19;
    }
    if ( (unsigned __int64)v11 - *(v11 - 1) - 8 <= 0x1F )
    {
      v11 = (_QWORD *)*(v11 - 1);
      goto LABEL_18;
    }
LABEL_20:
    invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = &v10[a2];
  result = (char *)&v10[v8 / 8];
  *(_QWORD *)(a1 + 16) = &v10[v8 / 8];
  return result;
}


// ===== 函数: sub_18002CC60 (0x18002CC60) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_18002CC60(__int64 a1)
{
  char v2; // bl
  __int64 v3; // rdi
  __int64 v4; // rax
  BOOL v5; // r14d
  __int64 v6; // rsi
  __int64 result; // rax
  __int64 v8; // rdx
  void **v9; // r8
  void (__fastcall *v10)(char **, _QWORD); // r15
  __int64 (__fastcall *v11)(__int64); // r14
  __int64 (__fastcall *v12)(__int64, __int64); // rbx
  __int64 v13; // rax
  unsigned int v14; // ebx
  char *v15; // rax
  __int64 v16; // rcx
  __int16 v17; // [rsp+20h] [rbp-60h] BYREF
  __int64 v18; // [rsp+28h] [rbp-58h] BYREF
  int v19; // [rsp+30h] [rbp-50h] BYREF
  __int64 v20; // [rsp+38h] [rbp-48h] BYREF
  _QWORD v21[2]; // [rsp+40h] [rbp-40h] BYREF
  char *v22; // [rsp+50h] [rbp-30h] BYREF
  __int64 v23; // [rsp+60h] [rbp-20h]
  unsigned __int64 v24; // [rsp+68h] [rbp-18h]

  v21[1] = -2LL;
  v2 = 1;
  if ( gAIDevUtilsSuite )
    v3 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
  else
    v3 = v18;
  v4 = sub_18000D970();
  v5 = v4 != 0;
  if ( v4 )
  {
    if ( gAIDevUtilsSuite )
      v6 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
    else
      v6 = v18;
    v2 = 0;
  }
  else
  {
    v6 = v18;
  }
  v17 = -1;
  result = (*(__int64 (__fastcall **)(__int16 *))(gAIDocumentSuite + 240))(&v17);
  if ( !(_DWORD)result )
  {
    v18 = 0LL;
    v21[0] = 0LL;
    v20 = 0LL;
    result = (*(__int64 (__fastcall **)(__int64 *, _QWORD *, __int64 *))(gAIDocumentSuite + 256))(&v18, v21, &v20);
    if ( !(_DWORD)result )
    {
      v19 = (v17 != 2) + 4;
      result = (*(__int64 (__fastcall **)(__int64, int *))(gAIDocumentListPrivateSuite + 8))(a1, &v19);
      if ( !(_DWORD)result )
      {
        result = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(gAIDocumentSuite + 264))(v18, v21[0], v20);
        if ( !(_DWORD)result )
        {
          if ( v5 && gAISmartExportUISuite )
          {
            v10 = *(void (__fastcall **)(char **, _QWORD))(gAISmartExportUISuite + 16);
            if ( gAIDevUtilsSuite )
            {
              v11 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
              if ( !v2 )
              {
                v12 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
                v13 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v6);
                v3 = v12(v13, v3);
              }
              v14 = v11(v3);
            }
            else
            {
              v14 = 0;
            }
            v22 = 0LL;
            v23 = 0LL;
            v24 = 15LL;
            v15 = (char *)sub_180031D20((ai *)0x20, v8, v9);
            v23 = 24LL;
            v24 = 31LL;
            strcpy(v15, "Create Headless Document");
            v22 = v15;
            v10(&v22, v14);
            if ( v24 >= 0x10 )
            {
              v16 = (__int64)v22;
              if ( v24 + 1 >= 0x1000 )
              {
                v16 = *((_QWORD *)v22 - 1);
                if ( (unsigned __int64)&v22[-v16 - 8] > 0x1F )
                  invalid_parameter_noinfo_noreturn();
              }
              sub_18001AE10(v16);
            }
          }
          return 0LL;
        }
      }
    }
  }
  return result;
}


// ===== 函数: sub_180027CA0 (0x180027CA0) =====
// Hidden C++ exception states: #wind=3
__int64 sub_180027CA0()
{
  __int64 (__fastcall *v0)(__int64 *, char *, size_t); // rbx
  unsigned __int64 v1; // r9
  unsigned __int64 v2; // r8
  char *v3; // rdx
  size_t v4; // r8
  __int64 *v5; // rcx
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 v9; // [rsp+50h] [rbp-B8h]
  _QWORD v10[2]; // [rsp+58h] [rbp-B0h] BYREF
  void *v11; // [rsp+68h] [rbp-A0h] BYREF
  void **v12; // [rsp+70h] [rbp-98h] BYREF
  _BYTE v13[16]; // [rsp+78h] [rbp-90h] BYREF
  char **v14; // [rsp+88h] [rbp-80h]
  char **v15; // [rsp+90h] [rbp-78h]
  _QWORD *v16; // [rsp+A8h] [rbp-60h]
  unsigned __int64 *v17; // [rsp+B0h] [rbp-58h]
  int *v18; // [rsp+C0h] [rbp-48h]
  unsigned __int64 v19; // [rsp+D8h] [rbp-30h]
  int v20; // [rsp+E0h] [rbp-28h]
  _BYTE v21[104]; // [rsp+F0h] [rbp-18h] BYREF
  __int64 v22[2]; // [rsp+158h] [rbp+50h] BYREF
  __int64 v23; // [rsp+168h] [rbp+60h]
  unsigned __int64 v24; // [rsp+170h] [rbp+68h]

  v10[0] = &unk_180058C10;
  v11 = &unk_180058C18;
  std::ios::ios(v21);
  std::iostream::basic_iostream<char>(v10, &v12, 0LL);
  *(_QWORD *)((char *)v10 + *(int *)(v10[0] + 4LL)) = &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  *(_DWORD *)((char *)&v9 + *(int *)(v10[0] + 4LL) + 4) = *(_DWORD *)(v10[0] + 4LL) - 152;
  std::streambuf::streambuf(&v12);
  v12 = &std::stringbuf::`vftable';
  v19 = 0LL;
  v20 = 0;
  std::ostream::operator<<(&v11);
  v0 = *(__int64 (__fastcall **)(__int64 *, char *, size_t))(gAIDictionarySuite + 64);
  v22[0] = 0LL;
  v23 = 0LL;
  v1 = 15LL;
  v24 = 15LL;
  if ( (v20 & 0x22) == 2 || (v2 = *v17) == 0 )
  {
    if ( (v20 & 4) != 0 || !*v16 )
    {
      v4 = 0LL;
      v3 = 0LL;
    }
    else
    {
      v3 = *v14;
      v4 = *v16 + *v18 - (_QWORD)*v14;
    }
  }
  else
  {
    v3 = *v15;
    if ( v2 < v19 )
      v2 = v19;
    v4 = v2 - (_QWORD)v3;
  }
  if ( v3 )
  {
    sub_180006EF0(v22, v3, v4);
    v1 = v24;
  }
  v5 = v22;
  if ( v1 >= 0x10 )
    v5 = (__int64 *)v22[0];
  v6 = v0(v5, v3, v4);
  if ( v24 >= 0x10 )
  {
    v7 = v22[0];
    if ( v24 + 1 >= 0x1000 )
    {
      v7 = *(_QWORD *)(v22[0] - 8);
      if ( (unsigned __int64)(v22[0] - v7 - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10(v7);
  }
  v23 = 0LL;
  v24 = 15LL;
  LOBYTE(v22[0]) = 0;
  *(_QWORD *)((char *)v10 + *(int *)(v10[0] + 4LL)) = &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  *(_DWORD *)((char *)&v9 + *(int *)(v10[0] + 4LL) + 4) = *(_DWORD *)(v10[0] + 4LL) - 152;
  sub_180012EA0(&v12);
  std::iostream::~basic_iostream<char,std::char_traits<char>>(v13);
  std::ios::~ios<char,std::char_traits<char>>(v21);
  return v6;
}


// ===== 函数: sub_180012EA0 (0x180012EA0) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_180012EA0(__int64 a1)
{
  bool v1; // zf
  __int64 v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // rcx

  v1 = (*(_BYTE *)(a1 + 112) & 1) == 0;
  *(_QWORD *)a1 = &std::stringbuf::`vftable';
  if ( !v1 )
  {
    v3 = **(_QWORD **)(a1 + 64);
    if ( v3 )
      v4 = v3 + **(int **)(a1 + 88);
    else
      v4 = **(_QWORD **)(a1 + 56) + **(int **)(a1 + 80);
    v5 = **(_QWORD **)(a1 + 24);
    if ( (unsigned __int64)(v4 - v5) >= 0x1000 )
    {
      if ( (unsigned __int64)(v5 - *(_QWORD *)(v5 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v5 = *(_QWORD *)(v5 - 8);
    }
    sub_18001AE10(v5);
  }
  **(_QWORD **)(a1 + 24) = 0LL;
  **(_QWORD **)(a1 + 56) = 0LL;
  **(_DWORD **)(a1 + 80) = 0;
  **(_QWORD **)(a1 + 32) = 0LL;
  **(_QWORD **)(a1 + 64) = 0LL;
  **(_DWORD **)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 112) &= ~1u;
  *(_QWORD *)(a1 + 104) = 0LL;
  return std::streambuf::~streambuf<char,std::char_traits<char>>(a1);
}


// ===== 函数: sub_18002CEB0 (0x18002CEB0) =====
// Hidden C++ exception states: #wind=3
__int64 sub_18002CEB0()
{
  unsigned int v0; // ebx

  v0 = (*(__int64 (**)(void))(gAIDocumentListPrivateSuite + 16))();
  (*(void (**)(void))(gAIDocumentListPrivateSuite + 104))();
  return v0;
}


// ===== 函数: sub_18002B4E0 (0x18002B4E0) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_18002B4E0(__int64 a1, __int64 *a2, void **a3)
{
  __int64 v4; // r14
  unsigned __int64 v5; // rax
  void **v6; // r8
  __int64 v7; // rcx
  __int64 *v8; // rbx
  __int64 *v9; // rdx
  __int64 *v10; // rcx
  __int64 *v11; // r8
  char v12; // r10
  __int64 *v13; // rax
  __int64 *v14; // rdx
  __int64 v15; // r14
  __int64 v16; // rax
  __int64 v17; // r15
  _QWORD *v18; // r12
  _QWORD *v19; // r14
  __int64 v20; // r8
  _QWORD *v21; // r15
  _QWORD *v22; // r14
  __int64 v23; // rax
  __int64 **v24; // rax
  __int64 *i; // rax
  __int64 *j; // rcx
  __int64 v27; // rbx
  __int64 v28; // rcx
  __int128 v30; // [rsp+38h] [rbp-28h] BYREF
  __int128 v31; // [rsp+48h] [rbp-18h] BYREF
  __int64 v32; // [rsp+58h] [rbp-8h]
  __int64 v34; // [rsp+B0h] [rbp+50h] BYREF

  v4 = a1;
  v30 = 0LL;
  v5 = sub_180031D20((ai *)0x20, (__int64)a2, a3);
  *(_QWORD *)v5 = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)(v5 + 16) = v5;
  *(_WORD *)(v5 + 24) = 257;
  *(_QWORD *)&v30 = v5;
  sub_18002B810(v4, (unsigned __int64 *)&v30, v6);
  v7 = v30;
  v8 = *(__int64 **)v30;
  if ( !*(_BYTE *)(*(_QWORD *)v30 + 25LL) )
  {
    while ( 1 )
    {
      v31 = 0LL;
      v32 = 0LL;
      v9 = *(__int64 **)(v4 + 48);
      v10 = (__int64 *)v9[1];
      v11 = v9;
      v12 = *((_BYTE *)v10 + 25);
      if ( !v12 )
      {
        v13 = (__int64 *)v9[1];
        do
        {
          if ( *((_BYTE *)v13 + 32) >= *((_BYTE *)v8 + 26) )
          {
            v11 = v13;
            v13 = (__int64 *)*v13;
          }
          else
          {
            v13 = (__int64 *)v13[2];
          }
        }
        while ( !*((_BYTE *)v13 + 25) );
      }
      if ( *((_BYTE *)v11 + 25) || *((_BYTE *)v8 + 26) < *((_BYTE *)v11 + 32) || v11 == v9 )
      {
        v17 = 0LL;
      }
      else
      {
        if ( !v12 )
        {
          do
          {
            if ( *((_BYTE *)v10 + 32) >= *((_BYTE *)v8 + 26) )
            {
              v9 = v10;
              v10 = (__int64 *)*v10;
            }
            else
            {
              v10 = (__int64 *)v10[2];
            }
          }
          while ( !*((_BYTE *)v10 + 25) );
        }
        if ( *((_BYTE *)v9 + 25) || *((_BYTE *)v8 + 26) < *((_BYTE *)v9 + 32) )
        {
          std::_Xout_of_range("invalid map<K, T> key");
          JUMPOUT(0x18002B80CLL);
        }
        v14 = v9 + 5;
        if ( &v31 != (__int128 *)v14 )
          sub_180025F40((__int64 *)&v31, *v14, (void **)v14[1]);
        v15 = *((_QWORD *)&v31 + 1);
        sub_180026D90(&v34, v31, *((__int64 *)&v31 + 1));
        if ( v34 == v15 )
        {
          v17 = *((_QWORD *)&v31 + 1);
          goto LABEL_28;
        }
        v16 = sub_1800267D0(v15, *((__int64 *)&v31 + 1), v34);
        v17 = v16;
        v18 = (_QWORD *)*((_QWORD *)&v31 + 1);
        if ( v16 != *((_QWORD *)&v31 + 1) )
        {
          v19 = (_QWORD *)(v16 + 8);
          do
          {
            sub_180036A90(v19 + 1);
            sub_180036A90(v19);
            v19 += 5;
          }
          while ( v19 - 1 != v18 );
        }
      }
      *((_QWORD *)&v31 + 1) = v17;
LABEL_28:
      sub_180026470(a2, a2[1], v31, v17);
      v20 = v31;
      if ( (_QWORD)v31 )
      {
        v21 = (_QWORD *)*((_QWORD *)&v31 + 1);
        if ( (_QWORD)v31 != *((_QWORD *)&v31 + 1) )
        {
          v22 = (_QWORD *)(v31 + 8);
          do
          {
            sub_180036A90(v22 + 1);
            sub_180036A90(v22);
            v22 += 5;
          }
          while ( v22 - 1 != v21 );
          v20 = v31;
        }
        v23 = v20;
        if ( (unsigned __int64)(40 * ((v32 - v20) / 40)) >= 0x1000 )
        {
          v20 = *(_QWORD *)(v20 - 8);
          if ( (unsigned __int64)(v23 - v20 - 8) > 0x1F )
            invalid_parameter_noinfo_noreturn();
        }
        sub_18001AE10(v20);
      }
      v24 = (__int64 **)v8[2];
      if ( *((_BYTE *)v24 + 25) )
      {
        for ( i = (__int64 *)v8[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
        {
          if ( v8 != (__int64 *)i[2] )
            break;
          v8 = i;
        }
        v8 = i;
      }
      else
      {
        v8 = (__int64 *)v8[2];
        for ( j = *v24; !*((_BYTE *)j + 25); j = (__int64 *)*j )
          v8 = j;
      }
      if ( *((_BYTE *)v8 + 25) )
      {
        v7 = v30;
        break;
      }
      v4 = a1;
    }
  }
  v27 = *(_QWORD *)(v7 + 8);
  if ( !*(_BYTE *)(v27 + 25) )
  {
    do
    {
      sub_18000B870((__int64)&v30, (__int64)&v30, *(_QWORD *)(v27 + 16));
      v28 = v27;
      v27 = *(_QWORD *)v27;
      sub_18001AE10(v28);
    }
    while ( !*(_BYTE *)(v27 + 25) );
    v7 = v30;
  }
  return sub_18001AE10(v7);
}


// ===== 函数: sub_18000E4E0 (0x18000E4E0) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_18000E4E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax

  v3 = a2;
  if ( (unsigned __int64)(8 * a3) >= 0x1000 )
  {
    if ( (unsigned __int64)(a2 - *(_QWORD *)(a2 - 8) - 8) > 0x1F )
      invalid_parameter_noinfo_noreturn();
    v3 = *(_QWORD *)(a2 - 8);
  }
  return sub_18001AE10(v3);
}


// ===== 函数: sub_1800064F0 (0x1800064F0) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_1800064F0(__int64 a1, __int64 a2, _QWORD *a3)
{
  void (__fastcall *v5)(__int64, __int64); // rbx
  __int64 v6; // rax
  void (__fastcall *v7)(__int64, __int64, __int64); // rbx
  __int64 v8; // rax
  void (__fastcall *v9)(__int64, __int64, _QWORD *); // rbx
  __int64 v10; // rax
  __int64 v11; // rcx
  char v13; // [rsp+68h] [rbp+20h] BYREF

  sub_180007340((__int64)&v13, 2);
  v5 = *(void (__fastcall **)(__int64, __int64))(gAIDictionarySuite + 88);
  v6 = sub_180008570((__int64)&v13);
  v5(v6, a2);
  v7 = *(void (__fastcall **)(__int64, __int64, __int64))(gAIDictionarySuite + 136);
  v8 = sub_180008570((__int64)&v13);
  v7(v8, a2, 1LL);
  v9 = *(void (__fastcall **)(__int64, __int64, _QWORD *))(gAIDictionarySuite + 128);
  v10 = sub_180008570((__int64)&v13);
  v9(v10, a2, a3);
  DispatchAssetProcessingTask(v11, *a3);
  return sub_180007420(&v13);
}


// ===== 函数: DispatchAssetProcessingTask (0x1800122F0) =====
// 函数分析报告: sub_1800122F0
// 分析时间: 2025-09-23 19:35:27.659770
// 
// 1. 核心功能概述
// 目标函数 sub_1800122F0 的主要功能是：在一个与 Adobe Illustrator 文档相关的数据结构中，根据一个双精度浮点数（double a1）查找一个对应的对象，并对该对象执行一项异步操作。
// 
// 该函数涉及到与文档句柄、哈希表、智能指针（引用计数）以及一个私有的文档处理套件（gAIDocumentListPrivateSuite）的交互。
// 
// 2. 执行流程详解
// 函数 sub_1800122F0 接收一个 double 类型的参数 a1 和一个 __int64 类型的参数 a2，其执行流程如下：
// 
// 获取文档相关数据结构:
// 
// 调用 sub_180016BE0 从一个全局对象 qword_180074190 中获取一个偏移量为 +376 的指针。这可能是获取当前活动文档的特定数据区。
// 
// 调用 sub_18001D820 对上一步获取的指针进行处理。sub_18001D820 内部会获取一个文档句柄 (sub_1800065C0)，并利用它从一个类似于哈希表（std::unordered_map）的结构中查找或创建一个条目，最终返回一个指向该条目数据的指针。
// 
// 查找目标对象:
// 
// 使用上一步返回的指针和输入的 double 值 a1，调用 sub_180021470。
// 
// sub_180021470 在一个数组或向量中进行线性搜索，通过 sub_1800322F0 函数比较每个元素的成员（偏移量 +72 处）是否与 a1 相等。
// 
// 如果找到匹配的元素，函数会返回一个包含该元素信息的智能指针（通过 _InterlockedIncrement 增加引用计数）到局部变量 v8。
// 
// 处理查找结果:
// 
// 如果找到对象 ((_QWORD)v8 不为 0):
// 
// 函数将找到的对象（封装在智能指针 v8 中）传递给 sub_180006320。
// 
// sub_180006320 内部使用 gAIDocumentListPrivateSuite 的函数（偏移 +112）来分派一个异步任务 (sub_1800061B0)，并将对象和参数 a2 传递给该任务。这表明函数的核心逻辑是触发一个后台或延迟执行的操作。
// 
// 函数返回 0，表示成功。
// 
// 如果未找到对象:
// 
// 函数将返回一个错误码 1346458189 (十六进制为 0x5044424D)。
// 
// 资源清理:
// 
// 无论是否找到对象，函数最后都会对 v8 中持有的智能指针进行引用计数递减 (_InterlockedExchangeAdd with -1)。当引用计数降为 0 时，会触发对象的析构和内存释放逻辑。
// 
// 3. 关键子函数分析
// sub_18001D820 & sub_18001C060: 这组函数是与一个复杂的哈希表（std::unordered_map）进行交互的核心。
// 
// sub_18001C060 实现了哈希表的查找与插入逻辑。它首先计算输入键值 a3 的 FNV-1a 哈希值 (0x100000001B3 是 FNV-1a 算法的乘法质数)，然后在对应的哈希桶中查找。
// 
// 如果找不到，它会分配新节点 (sub_180031D20)，并可能在负载因子 (v17 / v19 > v15) 超过阈值时触发哈希表的扩容 (sub_18001DD90)。
// 
// sub_18001D820 负责调用这个哈希表逻辑，并返回找到或创建的节点中存储的数据的指针（偏移 +24）。
// 
// sub_1800065C0: 该函数通过 gAIDocumentSuite API 获取当前的文档句柄 (v3)，这在与 Adobe Illustrator SDK 交互时非常常见，用于指定操作的目标文档。
// 
// sub_180021470: 这是一个简单的线性搜索函数。它遍历一个由 sub_18001D820 返回的结构内部的数组/列表，通过调用 sub_1800322F0 来比较每个对象的 double 成员值。
// 
// sub_180006320: 这是任务分派函数。它接收查找到的对象，并使用一个看起来是私有的 gAIDocumentListPrivateSuite 接口来调度一个在后台处理该对象的回调函数 (sub_1800061B0)。参数 a2 很可能被传递给这个后台任务。
// 
// 智能指针管理 (引用计数):
// 
// 在 sub_1800122F0 和 sub_180006320 中，_InterlockedIncrement 和 _InterlockedExchangeAdd 被广泛用于原子地增加和减少引用计数。
// 
// 当引用计数减至 1 时（_InterlockedExchangeAdd 返回 1），会触发对象的析构 (**(void (__fastcall ***)(volatile signed __int32 *))v6)(v6)) 和内存的最终释放。这是一种典型的侵入式智能指针实现。
// 
// 4. 结论
// 函数 sub_1800122F0 是一个高级别的调度函数。它将一个 double 值作为唯一标识符，在当前 Illustrator 文档的特定数据集合中查找一个资源或对象。如果找到，它会启动一个与该对象相关的异步操作，并将一个额外的参数 a2 传递给该操作。整个过程通过引用计数来安全地管理对象的生命周期。
// 
// 可能的应用场景:
// 这个函数可能用于处理文档中的特定资源，例如：根据时间戳、唯一 ID（以 double 形式存储）或其他浮点数标识符来查找某个图形、图层或嵌入式资源，并对其应用一个后台更新、导出或处理操作。
// Hidden C++ exception states: #wind=3
__int64 __fastcall DispatchAssetProcessingTask(double a1, __int64 a2)
{
  unsigned int v3; // edi
  __int64 v4; // rax
  __int64 v5; // rax
  volatile signed __int32 *v6; // rbx
  __int128 v8; // [rsp+30h] [rbp-38h] BYREF
  __int128 v9; // [rsp+40h] [rbp-28h] BYREF

  v3 = 0;
  v4 = sub_180016BE0(qword_180074190);
  v5 = sub_18001D820(v4);
  sub_180021470(v5, &v8, a1);
  if ( (_QWORD)v8 )
  {
    v9 = 0LL;
    if ( *((_QWORD *)&v8 + 1) )
      _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)&v8 + 1) + 8LL));
    v9 = v8;
    sub_180006320((__int64 *)&v9, a2);
  }
  else
  {
    v3 = 1346458189;
  }
  v6 = (volatile signed __int32 *)*((_QWORD *)&v8 + 1);
  if ( *((_QWORD *)&v8 + 1) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v8 + 1) + 8LL), 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v6)(v6);
      if ( _InterlockedExchangeAdd(v6 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v6 + 8LL))(v6);
    }
  }
  return v3;
}


// ===== 函数: sub_180007420 (0x180007420) =====
// Hidden C++ exception states: #wind=3
void __fastcall sub_180007420(ai **a1, void *a2)
{
  ai *v2; // rbx
  __int64 v3; // rax

  v2 = *a1;
  if ( *a1 )
  {
    if ( *((_QWORD *)v2 + 2) )
    {
      v3 = sub_18001E230();
      (*(void (__fastcall **)(_QWORD))(v3 + 8))(*((_QWORD *)v2 + 2));
    }
    sub_180031DC0(v2, a2);
  }
}


// ===== 函数: sub_180026F00 (0x180026F00) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_180026F00(__int64 a1, int a2)
{
  if ( a2 )
  {
    *(_QWORD *)a1 = &unk_180058C10;
    *(_QWORD *)(a1 + 16) = &unk_180058C18;
    std::ios::ios(a1 + 152);
  }
  std::iostream::basic_iostream<char>(a1, a1 + 24, 0LL);
  *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4LL) + a1) = &std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable';
  *(_DWORD *)(*(int *)(*(_QWORD *)a1 + 4LL) + a1 - 4) = *(_DWORD *)(*(_QWORD *)a1 + 4LL) - 152;
  std::streambuf::streambuf(a1 + 24);
  *(_QWORD *)(a1 + 24) = &std::stringbuf::`vftable';
  *(_QWORD *)(a1 + 128) = 0LL;
  *(_DWORD *)(a1 + 136) = 0;
  return a1;
}


// ===== 函数: sub_180016310 (0x180016310) =====
// Hidden C++ exception states: #wind=3
__int64 *__fastcall sub_180016310(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 *v5; // rsi
  unsigned int v6; // ebx
  __int64 v7; // r9
  __int64 v8; // rdi
  unsigned __int64 v9; // rdi
  __int64 *v10; // r14
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rax
  bool v14; // al
  __int64 *v15; // rax
  __int64 v16; // r8
  __int64 v17; // rcx
  int v21; // [rsp+88h] [rbp+20h]

  v5 = a1;
  v6 = 0;
  v21 = 0;
  v7 = *(int *)(*a1 + 4);
  v8 = *(__int64 *)((char *)a1 + v7 + 40);
  if ( v8 <= 0 || v8 <= a3 )
    v9 = 0LL;
  else
    v9 = v8 - a3;
  v10 = a1;
  v11 = *(__int64 *)((char *)a1 + v7 + 72);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
  v12 = *v5;
  v13 = *(int *)(*v5 + 4);
  if ( *(_DWORD *)((char *)v5 + v13 + 16) )
  {
    v14 = 0;
  }
  else
  {
    v15 = *(__int64 **)((char *)v5 + v13 + 80);
    if ( !v15 || v15 == v5 )
    {
      v14 = 1;
    }
    else
    {
      std::ostream::flush(v15);
      v12 = *v5;
      v14 = *(_DWORD *)((char *)v5 + *(int *)(*v5 + 4) + 16) == 0;
    }
  }
  if ( v14 )
  {
    try
    {
      if ( (*(_DWORD *)((_BYTE *)v5 + *(int *)(v12 + 4) + 24) & 0x1C0) != 0x40 )
      {
        while ( v9 )
        {
          if ( (unsigned int)std::streambuf::sputc(
                               *(__int64 *)((char *)v5 + *(int *)(*v5 + 4) + 72),
                               *((unsigned __int8 *)v5 + *(int *)(*v5 + 4) + 88)) == -1 )
          {
            v6 = 4;
            v21 = 4;
            goto LABEL_21;
          }
          --v9;
        }
      }
      if ( std::streambuf::sputn(*(__int64 *)((char *)v5 + *(int *)(*v5 + 4) + 72), a2, a3) == a3 )
      {
LABEL_21:
        while ( v9 )
        {
          if ( (unsigned int)std::streambuf::sputc(
                               *(__int64 *)((char *)v5 + *(int *)(*v5 + 4) + 72),
                               *((unsigned __int8 *)v5 + *(int *)(*v5 + 4) + 88)) == -1 )
            goto LABEL_24;
          --v9;
        }
      }
      else
      {
LABEL_24:
        v6 |= 4u;
        v21 = v6;
      }
      *(__int64 *)((char *)v5 + *(int *)(*v5 + 4) + 40) = 0LL;
    }
    catch ( ... )
    {
      LOBYTE(v16) = 1;
      std::ios::setstate((char *)a1 + *(int *)(*a1 + 4), 4LL, v16);
      v5 = a1;
      v6 = v21;
      v10 = a1;
    }
  }
  else
  {
    v6 = 4;
  }
  std::ios::setstate((char *)v5 + *(int *)(*v5 + 4), v6, 0LL);
  if ( !std::uncaught_exception() )
    std::ostream::_Osfx(v10);
  v17 = *(__int64 *)((char *)v10 + *(int *)(*v10 + 4) + 72);
  if ( v17 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 16LL))(v17);
  return v5;
}


// ===== 函数: ?uncaught_exception@std@@YA_NXZ (0x18004BCE8) =====
// Hidden C++ exception states: #wind=3
// attributes: thunk
bool std::uncaught_exception(void)
{
  return __imp_?uncaught_exception@std@@YA_NXZ();
}


// ===== 函数: sub_180037530 (0x180037530) =====
// Hidden C++ exception states: #wind=3
_QWORD *__fastcall sub_180037530(__int64 a1, _QWORD *a2, unsigned int a3)
{
  _QWORD *v6; // r14
  __int128 *v7; // rax
  __int64 v8; // rax
  int v9; // eax
  __int64 v10; // rdx
  void **v11; // r8
  size_t v12; // rbx
  void *v13; // rbp
  __int64 v14; // rdi
  ai *v15; // rax
  unsigned __int64 v16; // rax
  __int64 v18; // [rsp+30h] [rbp-58h] BYREF
  void *Src; // [rsp+38h] [rbp-50h]
  _BYTE pExceptionObject[48]; // [rsp+40h] [rbp-48h] BYREF
  size_t Size; // [rsp+A8h] [rbp+20h] BYREF

  v6 = 0LL;
  v18 = 0LL;
  Src = 0LL;
  Size = 0LL;
  v7 = sub_180036EE0();
  v8 = sub_180007790((__int64)v7);
  v9 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64 *, size_t *))(v8 + 296))(a1, a3, &v18, &Size);
  if ( v9 )
  {
    sub_180003F80((__int64)pExceptionObject, v9, 0LL);
    throw (ai::Error *)pExceptionObject;
  }
  v12 = Size;
  *a2 = 0LL;
  a2[2] = 0LL;
  a2[3] = 15LL;
  *(_BYTE *)a2 = 0;
  if ( v12 )
  {
    v13 = Src;
    if ( v12 <= 0xF )
    {
      a2[2] = v12;
      memmove(a2, v13, v12);
      *((_BYTE *)a2 + v12) = 0;
      goto LABEL_19;
    }
    v14 = 0x7FFFFFFFFFFFFFFFLL;
    if ( v12 > 0x7FFFFFFFFFFFFFFFLL )
      std::vector<void *>::_Xlen();
    if ( (v12 | 0xF) <= 0x7FFFFFFFFFFFFFFFLL )
    {
      v14 = v12 | 0xF;
      if ( (v12 | 0xF) < 0x16 )
        v14 = 22LL;
      if ( (unsigned __int64)(v14 + 1) < 0x1000 )
      {
        if ( v14 != -1 )
          v6 = (_QWORD *)sub_180031D20((ai *)(v14 + 1), v10, v11);
        goto LABEL_18;
      }
      v15 = (ai *)(v14 + 40);
      if ( v14 + 40 < (unsigned __int64)(v14 + 1) )
        Concurrency::cancel_current_task();
    }
    else
    {
      v15 = (ai *)0x8000000000000027LL;
    }
    v16 = sub_180031D20(v15, v10, v11);
    if ( !v16 )
      invalid_parameter_noinfo_noreturn();
    v6 = (_QWORD *)((v16 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v6 - 1) = v16;
LABEL_18:
    a2[2] = v12;
    a2[3] = v14;
    memcpy(v6, v13, v12);
    *((_BYTE *)v6 + v12) = 0;
    *a2 = v6;
  }
LABEL_19:
  sub_18000C030(&v18);
  return a2;
}


// ===== 函数: sub_18002C930 (0x18002C930) =====
// Hidden C++ exception states: #wind=3
__int64 *__fastcall sub_18002C930(__int64 a1, __int64 *a2)
{
  int v3; // edx
  unsigned __int64 *v4; // rax
  unsigned __int64 v5; // r8
  char *v6; // rdx
  unsigned __int64 *v7; // rax
  __int64 *v8; // rcx
  void *v9; // r8
  __int64 v10; // r9
  unsigned __int64 v12; // [rsp+28h] [rbp-40h] BYREF
  void *Src[2]; // [rsp+30h] [rbp-38h]
  __int64 v14; // [rsp+48h] [rbp-20h]
  __int64 *v15; // [rsp+50h] [rbp-18h]

  v14 = -2LL;
  v15 = a2;
  *a2 = 0LL;
  a2[2] = 0LL;
  a2[3] = 15LL;
  *(_BYTE *)a2 = 0;
  *(_OWORD *)Src = 0LL;
  v3 = *(_DWORD *)(a1 + 136);
  if ( (v3 & 0x22) == 2 || (v4 = *(unsigned __int64 **)(a1 + 88), (v5 = *v4) == 0) )
  {
    if ( (v3 & 4) != 0 || (v10 = **(_QWORD **)(a1 + 80)) == 0 )
    {
      v9 = Src[1];
      v6 = (char *)Src[0];
    }
    else
    {
      v6 = **(char ***)(a1 + 48);
      v9 = (void *)(v10 + **(int **)(a1 + 104) - (_QWORD)v6);
    }
  }
  else
  {
    v6 = **(char ***)(a1 + 56);
    v12 = *v4;
    v7 = (unsigned __int64 *)(a1 + 128);
    v8 = (__int64 *)&v12;
    if ( v5 < *v7 )
      v8 = (__int64 *)v7;
    v9 = (void *)(*v8 - (_QWORD)v6);
  }
  if ( v6 )
    sub_180006EF0(a2, v6, (size_t)v9);
  return a2;
}


// ===== 函数: sub_180026D60 (0x180026D60) =====
// Hidden C++ exception states: #wind=3
void __fastcall __noreturn sub_180026D60(__int64 a1)
{
  _BYTE pExceptionObject[104]; // [rsp+20h] [rbp-68h] BYREF

  sub_1800269C0(pExceptionObject, a1);
  throw (boost::wrapexcept<boost::bad_function_call> *)pExceptionObject;
}


// ===== 函数: sub_1800269C0 (0x1800269C0) =====
// Hidden C++ exception states: #wind=3
_QWORD *__fastcall sub_1800269C0(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rcx
  char v4; // al
  __int64 v5; // rcx
  void **v7; // [rsp+30h] [rbp-58h] BYREF
  __int128 v8; // [rsp+38h] [rbp-50h] BYREF
  void **v9; // [rsp+48h] [rbp-40h] BYREF
  __int128 v10; // [rsp+50h] [rbp-38h]
  __int64 v11; // [rsp+60h] [rbp-28h]
  int v12; // [rsp+68h] [rbp-20h]

  v8 = 0LL;
  _std_exception_copy(a2 + 8, &v8);
  v10 = 0LL;
  v11 = 0LL;
  v12 = -1;
  v7 = &boost::exception_detail::error_info_injector<boost::bad_function_call>::`vftable';
  v9 = &boost::exception_detail::error_info_injector<boost::bad_function_call>::`vftable';
  a1[8] = &unk_180058F10;
  a1[10] = &boost::exception_detail::clone_base::`vftable';
  sub_180027050(a1, &v7);
  *a1 = &boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_function_call>>::`vftable';
  a1[3] = &boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_function_call>>::`vftable';
  *(_QWORD *)((char *)a1 + *(int *)(a1[8] + 4LL) + 64) = &boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_function_call>>::`vftable';
  *(_DWORD *)((char *)a1 + *(int *)(a1[8] + 4LL) + 60) = *(_DWORD *)(a1[8] + 4LL) - 16;
  sub_18002C780(a1 + 3, &v9);
  *a1 = &boost::wrapexcept<boost::bad_function_call>::`vftable';
  a1[3] = &boost::wrapexcept<boost::bad_function_call>::`vftable';
  *(_QWORD *)((char *)a1 + *(int *)(a1[8] + 4LL) + 64) = &boost::wrapexcept<boost::bad_function_call>::`vftable';
  v3 = *(int *)(a1[8] + 4LL);
  *(_DWORD *)((char *)a1 + v3 + 60) = v3 - 16;
  v7 = &boost::exception_detail::error_info_injector<boost::bad_function_call>::`vftable';
  v9 = &boost::exception::`vftable';
  if ( (_QWORD)v10 )
  {
    v4 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v10 + 32LL))(v10);
    v5 = v10;
    if ( v4 )
      v5 = 0LL;
    *(_QWORD *)&v10 = v5;
  }
  v7 = &std::exception::`vftable';
  _std_exception_destroy(&v8);
  return a1;
}


// ===== 函数: __std_exception_copy (0x18004D0D0) =====
// Hidden C++ exception states: #wind=3
// attributes: thunk
__int64 __fastcall _std_exception_copy(__int64 a1, __int64 a2)
{
  return __std_exception_copy(a1, a2);
}


// ===== 函数: sub_180027050 (0x180027050) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_180027050(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx

  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0LL;
  _std_exception_copy(a2 + 8, a1 + 8);
  *(_QWORD *)a1 = &boost::bad_function_call::`vftable';
  *(_QWORD *)(a1 + 24) = &boost::exception::`vftable';
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_QWORD *)a1 = &boost::exception_detail::error_info_injector<boost::bad_function_call>::`vftable';
  *(_QWORD *)(a1 + 24) = &boost::exception_detail::error_info_injector<boost::bad_function_call>::`vftable';
  return a1;
}


// ===== 函数: sub_18002C780 (0x18002C780) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_18002C780(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 result; // rax
  __int64 v7; // rcx
  __int64 v8; // [rsp+40h] [rbp+8h] BYREF
  __int64 v9; // [rsp+48h] [rbp+10h]

  v4 = 0LL;
  v9 = 0LL;
  v5 = *(_QWORD *)(a2 + 8);
  if ( v5 )
  {
    v4 = *(_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v5 + 40LL))(v5, &v8);
    v9 = v4;
    if ( v4 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
    if ( v8 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 32LL))(v8);
  }
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  result = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 16) = result;
  v7 = *(_QWORD *)(a1 + 8);
  if ( v7 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 32LL))(v7);
  *(_QWORD *)(a1 + 8) = v4;
  if ( v4 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 32LL))(v4);
  }
  return result;
}


// ===== 函数: __std_exception_destroy (0x18004D0D6) =====
// Hidden C++ exception states: #wind=3
// attributes: thunk
__int64 __fastcall _std_exception_destroy(__int64 a1)
{
  return __std_exception_destroy(a1);
}


// ===== 函数: sub_180008580 (0x180008580) =====
// Hidden C++ exception states: #wind=3
__int128 *sub_180008580()
{
  _QWORD *v1; // rax

  if ( dword_180073FB8 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180073F98;
  Init_thread_header(&dword_180073FB8);
  if ( dword_180073FB8 != -1 )
    return &xmmword_180073F98;
  xmmword_180073F98 = 0LL;
  qword_180073FA8 = (__int64)"AI Docuement Private Suite";
  dword_180073FB0 = 1;
  byte_180073FB4 = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180073F98 = *v1;
  *v1 = &xmmword_180073F98;
  Init_thread_footer(&dword_180073FB8);
  return &xmmword_180073F98;
}


// ===== 函数: sub_180004B80 (0x180004B80) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_180004B80(__int64 a1)
{
  void (__fastcall *v2)(__int64, __int64); // rbx
  __int64 v3; // rax
  void *v4; // rdx
  ai *v6; // [rsp+48h] [rbp+10h] BYREF
  __int64 v7; // [rsp+50h] [rbp+18h] BYREF

  sub_18001A2C0(&v7, *(_QWORD *)(qword_180074190 + 8), 0);
  sub_180007340((__int64)&v6, 2);
  v2 = *(void (__fastcall **)(__int64, __int64))(gAIDictionarySuite + 88);
  v3 = sub_180008570((__int64)&v6);
  v2(v3, a1);
  sub_180007420(&v6, v4);
  return sub_18001A320(&v7);
}


// ===== 函数: sub_180013D90 (0x180013D90) =====
// Hidden C++ exception states: #wind=3
__int64 *__fastcall sub_180013D90(__int64 *a1, __int64 a2)
{
  __int64 *v3; // rsi
  unsigned int v4; // ebx
  __int64 v5; // r14
  __int64 v6; // rcx
  __int64 v7; // rdi
  __int64 v8; // rdi
  __int64 *v9; // r15
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rax
  bool v13; // al
  __int64 *v14; // rax
  __int64 v15; // r8
  __int64 v16; // rcx
  __int64 *v18; // [rsp+28h] [rbp-40h]
  int v20; // [rsp+80h] [rbp+18h]

  v3 = a1;
  v4 = 0;
  v20 = 0;
  v5 = -1LL;
  do
    ++v5;
  while ( *(_BYTE *)(a2 + v5) );
  v6 = *(int *)(*a1 + 4);
  v7 = *(__int64 *)((char *)v3 + v6 + 40);
  if ( v7 <= 0 || v7 <= v5 )
    v8 = 0LL;
  else
    v8 = v7 - v5;
  v9 = v3;
  v18 = v3;
  v10 = *(__int64 *)((char *)v3 + v6 + 72);
  if ( v10 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
  v11 = *v3;
  v12 = *(int *)(*v3 + 4);
  if ( *(_DWORD *)((char *)v3 + v12 + 16) )
  {
    v13 = 0;
  }
  else
  {
    v14 = *(__int64 **)((char *)v3 + v12 + 80);
    if ( !v14 || v14 == v3 )
    {
      v13 = 1;
    }
    else
    {
      std::ostream::flush(v14);
      v11 = *v3;
      v13 = *(_DWORD *)((char *)v3 + *(int *)(*v3 + 4) + 16) == 0;
    }
  }
  if ( v13 )
  {
    try
    {
      if ( (*(_DWORD *)((_BYTE *)v3 + *(int *)(v11 + 4) + 24) & 0x1C0) != 0x40 )
      {
        while ( v8 > 0 )
        {
          if ( (unsigned int)std::streambuf::sputc(
                               *(__int64 *)((char *)v3 + *(int *)(*v3 + 4) + 72),
                               *((unsigned __int8 *)v3 + *(int *)(*v3 + 4) + 88)) == -1 )
          {
            v4 = 4;
            goto LABEL_27;
          }
          --v8;
        }
      }
      if ( std::streambuf::sputn(*(__int64 *)((char *)v3 + *(int *)(*v3 + 4) + 72), a2, v5) == v5 )
      {
        while ( v8 > 0 )
        {
          if ( (unsigned int)std::streambuf::sputc(
                               *(__int64 *)((char *)v3 + *(int *)(*v3 + 4) + 72),
                               *((unsigned __int8 *)v3 + *(int *)(*v3 + 4) + 88)) == -1 )
            goto LABEL_26;
          --v8;
        }
      }
      else
      {
LABEL_26:
        v4 = 4;
LABEL_27:
        v20 = 4;
      }
      *(__int64 *)((char *)v3 + *(int *)(*v3 + 4) + 40) = 0LL;
    }
    catch ( ... )
    {
      LOBYTE(v15) = 1;
      std::ios::setstate((char *)a1 + *(int *)(*a1 + 4), 4LL, v15);
      v3 = a1;
      v4 = v20;
      v9 = v18;
    }
  }
  else
  {
    v4 = 4;
  }
  std::ios::setstate((char *)v3 + *(int *)(*v3 + 4), v4, 0LL);
  if ( !std::uncaught_exception() )
    std::ostream::_Osfx(v9);
  v16 = *(__int64 *)((char *)v9 + *(int *)(*v9 + 4) + 72);
  if ( v16 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 16LL))(v16);
  return v3;
}


// ===== 函数: sub_180027590 (0x180027590) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_180027590(__int64 a1)
{
  const char *v3; // [rsp+20h] [rbp-18h] BYREF
  char v4; // [rsp+28h] [rbp-10h]

  v4 = 1;
  *(_QWORD *)a1 = &std::exception::`vftable';
  v3 = "call to empty boost::function";
  *(_OWORD *)(a1 + 8) = 0LL;
  _std_exception_copy((__int64)&v3, a1 + 8);
  *(_QWORD *)a1 = &boost::bad_function_call::`vftable';
  return a1;
}


// ===== 函数: sub_18003CDB0 (0x18003CDB0) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_18003CDB0(__int64 a1, _QWORD *a2)
{
  *(_DWORD *)a1 = 4;
  sub_1800271C0(a1 + 16, (__int64)(a2 + 1));
  *(_QWORD *)(a1 + 8) = *a2;
  return a1;
}


// ===== 函数: sub_1800183E0 (0x1800183E0) =====
// Hidden C++ exception states: #wind=3
unsigned __int64 __fastcall sub_1800183E0(__int64 *a1, __int64 a2, __int64 a3)
{
  void **v5; // r8
  __int64 v6; // rbx
  __int64 v7; // rdx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // r13
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rax
  _QWORD *v13; // r14
  unsigned __int64 v14; // rbx
  _QWORD *v15; // r12
  __int64 v16; // rdx
  __int64 v17; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v19; // [rsp+30h] [rbp-58h]
  _QWORD *v22; // [rsp+A8h] [rbp+20h]

  v5 = (void **)*a1;
  v6 = (a2 - *a1) / 40;
  v7 = (a1[1] - *a1) / 40;
  v8 = 0x666666666666666LL;
  if ( v7 == 0x666666666666666LL )
    std::vector<void *>::_Xlen();
  v9 = v7 + 1;
  v10 = (a1[2] - (__int64)v5) / 40;
  v11 = v10 >> 1;
  if ( v10 <= 0x666666666666666LL - (v10 >> 1) )
  {
    v8 = v11 + v10;
    if ( v11 + v10 < v9 )
      v8 = v9;
  }
  v12 = sub_18000E460((__int64)a1, v8, v5);
  v13 = (_QWORD *)v12;
  v19 = v12;
  v14 = v12 + 40 * v6;
  v15 = (_QWORD *)(v14 + 40);
  *(_QWORD *)v14 = *(_QWORD *)a3;
  try
  {
    sub_180036480((_QWORD *)(v14 + 8), a3 + 8);
    sub_180036480((_QWORD *)(v14 + 16), a3 + 16);
    *(_BYTE *)(v14 + 24) = *(_BYTE *)(a3 + 24);
    *(_DWORD *)(v14 + 28) = *(_DWORD *)(a3 + 28);
    *(_DWORD *)(v14 + 32) = *(_DWORD *)(a3 + 32);
    *(_DWORD *)(v14 + 36) = *(_DWORD *)(a3 + 36);
    v22 = (_QWORD *)v14;
    v16 = a1[1];
    v17 = *a1;
    if ( a2 == v16 )
    {
      v15 = v13;
    }
    else
    {
      sub_180018860(v17, a2, v13);
      v22 = v13;
      v17 = a2;
      v16 = a1[1];
    }
    sub_180018860(v17, v16, v15);
    sub_18001A0C0(a1, (__int64)v13, v9, v8);
    result = v14;
  }
  catch ( ... )
  {
    sub_180018360(v22, (_QWORD *)(v14 + 40));
    sub_18001A220(a1, v19, v8);
    throw;
  }
  return result;
}


// ===== 函数: sub_1800047E0 (0x1800047E0) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_1800047E0(__int64 *a1)
{
  unsigned __int64 v1; // rdx
  __int64 v3; // rcx
  __int64 result; // rax

  v1 = a1[3];
  if ( v1 >= 0x10 )
  {
    v3 = *a1;
    if ( v1 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        invalid_parameter_noinfo_noreturn();
      v3 = *(_QWORD *)(v3 - 8);
    }
    result = sub_18001AE10(v3);
  }
  a1[2] = 0LL;
  a1[3] = 15LL;
  *(_BYTE *)a1 = 0;
  return result;
}


// ===== 函数: sub_18000CFE0 (0x18000CFE0) =====
// Hidden C++ exception states: #wind=3
_BOOL8 __fastcall sub_18000CFE0(__int64 *a1)
{
  bool v1; // di
  __int64 v2; // r12
  __int64 v3; // r13
  __int64 v4; // r15
  __int64 *v5; // rbx
  __int64 *v6; // rbp
  __int64 v7; // rsi
  unsigned __int128 v8; // kr00_16
  __int64 v9; // r15
  __int64 v10; // rdi
  int v11; // eax
  _QWORD *v12; // rax
  int v13; // eax
  __int64 v14; // rax
  unsigned __int128 v16; // [rsp+28h] [rbp-70h] BYREF
  __int64 v17; // [rsp+38h] [rbp-60h]
  _BYTE pExceptionObject[48]; // [rsp+40h] [rbp-58h] BYREF

  v1 = 0;
  v2 = *a1;
  v3 = a1[1];
  if ( *a1 != v3 )
  {
    v4 = (unsigned int)TlsIndex;
    do
    {
      if ( !v1 )
      {
        v16 = 0LL;
        v17 = 0LL;
        fxGetArtHandlesFromAsset(a1, &v16);
        v8 = v16;
        v6 = (__int64 *)(v8 >> 64);
        v7 = v8;
        v5 = (__int64 *)v16;
        if ( (_QWORD)v16 != *((_QWORD *)&v16 + 1) )
        {
          v9 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + v4);
          do
          {
            v10 = *v5;
            if ( dword_1800740D0 > *(_DWORD *)(v9 + 4) )
            {
              Init_thread_header(&dword_1800740D0);
              if ( dword_1800740D0 == -1 )
              {
                xmmword_1800740B0 = 0LL;
                qword_1800740C0 = (__int64)"AI Repeat Private Suite";
                dword_1800740C8 = 1;
                byte_1800740CC = 0;
                Init_thread_footer(&dword_1800740D0);
              }
            }
            if ( !*((_QWORD *)&xmmword_1800740B0 + 1) && qword_1800740D8 )
            {
              v11 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
                      qword_1800740C0,
                      (unsigned int)dword_1800740C8,
                      (char *)&xmmword_1800740B0 + 8);
              if ( v11 )
              {
                sub_180003F80((__int64)pExceptionObject, v11, 0LL);
                throw (ai::Error *)pExceptionObject;
              }
              if ( !byte_1800740CC )
              {
                v12 = sub_180012E90();
                *(_QWORD *)&xmmword_1800740B0 = *v12;
                *v12 = &xmmword_1800740B0;
              }
            }
            v13 = (*(__int64 (__fastcall **)(__int64))(*((_QWORD *)&xmmword_1800740B0 + 1) + 304LL))(v10);
            v1 = v13 != 0;
            if ( v13 )
              break;
            ++v5;
          }
          while ( v5 != v6 );
          v4 = (unsigned int)TlsIndex;
        }
        if ( v7 )
        {
          v14 = v7;
          if ( ((v17 - v7) & 0xFFFFFFFFFFFFFFF8uLL) >= 0x1000 )
          {
            v7 = *(_QWORD *)(v7 - 8);
            if ( (unsigned __int64)(v14 - v7 - 8) > 0x1F )
              invalid_parameter_noinfo_noreturn();
          }
          sub_18001AE10(v7);
        }
      }
      v2 += 8LL;
    }
    while ( v2 != v3 );
  }
  return v1;
}


// ===== 函数: fxGetArtHandlesFromAsset (0x1800123D0) =====
// 根据对所提供伪代码的详细分析，该函数的实际行为与伪代码注释完全不符。注释描述了一个“全部不选”（Deselect All）的批量操作，但代码的逻辑和其调用的子函数 sub_1800211F0 指向了一个完全不同的功能。
// 
// 伪代码揭示的真实功能：
// 
// 函数 sub_1800123D0 接收一个参数 a1（可能是资产的唯一ID，虽然伪代码签名不明确）和一个输出参数 a2（一个指向 std::vector 类似结构的指针）。
// 
// 它调用 sub_1800211F0 作为其核心工作函数。
// 
// sub_1800211F0 的功能是：
// 
// 接收一个资产ID。
// 
// 在当前文档的资产列表中查找该ID对应的资产对象。
// 
// 如果找到，它会遍历该资产对象内部包含的所有“艺术对象”（Art Objects）。
// 
// 将每个艺术对象的句柄（AIArtHandle）收集到一个列表中。
// 
// sub_1800123D0 最终将这个收集到的艺术对象句柄列表返回给调用者（通过输出参数 a2）。
// 
// 函数末尾的性能日志记录事件名为 fxGetArtHandlesFromAsset，这进一步证实了其真实功能。
// 
// 结论：
// 该函数并非取消标记，而是一个查询函数，其作用是根据一个资产的ID，获取构成该资产的所有艺术对象的句柄列表。伪代码注释很可能是错误的，可能从其他函数复制而来。
// 
// 因此，建议的函数名应基于其真实的代码逻辑和日志事件名：
// 
// fxGetArtHandlesFromAsset
// 
// 理由: 这是最直接、最准确的命名，与函数末尾记录的性能日志事件完全一致，清晰地描述了函数的功能。
// 
// Asset_GetArtHandles
// 
// 理由: 这是一个更通用的C++风格命名，强调了这是“资产”对象的一个操作，用于获取其包含的“艺术对象句柄”。
// 
// GetArtHandlesByAssetID
// 
// 理由: 这个名称详细地描述了函数的输入（资产ID）和输出（艺术对象句柄列表），非常清晰易懂。
// 
// 总结：
// 
// fxGetArtHandlesFromAsset 是最推荐的名称，因为它直接来源于代码自身的日志信息，准确反映了该函数的查询和数据检索功能。
// Hidden C++ exception states: #wind=3
__int64 __fastcall fxGetAssetNameByID(double a1, __int64 *a2)
{
  __int64 v3; // rbp
  __int64 v4; // r14
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 *v7; // rsi
  unsigned int v8; // edi
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 (__fastcall *v12)(__int64); // rdi
  __int64 (__fastcall *v13)(__int64, __int64); // rbx
  __int64 v14; // rax
  __int64 v15; // rax
  void (*v16)(const char *, const char *, _QWORD, _QWORD, __int64, const char *, ...); // rbx
  __int64 v17; // rax
  _QWORD v19[3]; // [rsp+58h] [rbp-70h] BYREF
  char v20; // [rsp+70h] [rbp-58h]
  __int64 v21; // [rsp+78h] [rbp-50h]
  __int64 v22; // [rsp+80h] [rbp-48h]
  const char *v23; // [rsp+88h] [rbp-40h]
  const char *v24; // [rsp+90h] [rbp-38h]
  __int16 v25; // [rsp+98h] [rbp-30h]

  v20 = 0;
  if ( gAIDevUtilsSuite )
  {
    v3 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 152))();
    v21 = v3;
    v4 = (*(__int64 (**)(void))(gAIDevUtilsSuite + 56))();
    v22 = v4;
  }
  else
  {
    v4 = v22;
    v3 = v21;
  }
  v23 = "fxGetArtHandlesFromAsset";
  v24 = "SmartExport";
  v25 = 0;
  v5 = sub_180016BE0(qword_180074190);
  v6 = sub_18001D820(v5);
  v7 = (__int64 *)sub_1800211F0(v6, (__int64)v19, a1);
  v8 = 0;
  if ( a2 != v7 )
  {
    v9 = *a2;
    if ( *a2 )
    {
      if ( (unsigned __int64)(8 * ((a2[2] - v9) >> 3)) >= 0x1000 )
      {
        if ( (unsigned __int64)(v9 - *(_QWORD *)(v9 - 8) - 8) > 0x1F )
          goto LABEL_14;
        v9 = *(_QWORD *)(v9 - 8);
      }
      sub_18001AE10(v9);
      *a2 = 0LL;
      a2[1] = 0LL;
      a2[2] = 0LL;
    }
    *a2 = *v7;
    a2[1] = v7[1];
    a2[2] = v7[2];
    *v7 = 0LL;
    v7[1] = 0LL;
    v7[2] = 0LL;
  }
  v10 = v19[0];
  if ( v19[0] )
  {
    if ( (unsigned __int64)(8 * ((__int64)(v19[2] - v19[0]) >> 3)) >= 0x1000 )
    {
      v10 = *(_QWORD *)(v19[0] - 8LL);
      if ( (unsigned __int64)(v19[0] - v10 - 8) > 0x1F )
LABEL_14:
        invalid_parameter_noinfo_noreturn();
    }
    sub_18001AE10(v10);
  }
  v11 = gAIDevUtilsSuite;
  if ( gAIDevUtilsSuite )
  {
    v12 = *(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 80);
    v13 = *(__int64 (__fastcall **)(__int64, __int64))(gAIDevUtilsSuite + 64);
    v14 = (*(__int64 (__fastcall **)(__int64))(gAIDevUtilsSuite + 112))(v4);
    v15 = v13(v14, v3);
    v8 = v12(v15);
    v11 = gAIDevUtilsSuite;
  }
  v16 = *(void (**)(const char *, const char *, _QWORD, _QWORD, __int64, const char *, ...))(v11 + 248);
  v17 = sub_18000D970();
  v16(
    "SmartExport",
    "fxGetArtHandlesFromAsset",
    v8,
    0LL,
    v17,
    "%u,%s,%s",
    v8,
    "SmartExport",
    "fxGetArtHandlesFromAsset");
  return 0LL;
}


// ===== 函数: sub_1800211F0 (0x1800211F0) =====
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_1800211F0(__int64 a1, __int64 a2, double a3)
{
  __int64 *v4; // rbx
  __int64 *v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rcx
  volatile signed __int32 *v10; // rdi
  __int128 v12; // [rsp+58h] [rbp-29h]
  void **v13; // [rsp+78h] [rbp-9h] BYREF
  __int128 v14; // [rsp+80h] [rbp-1h]
  __int128 v15; // [rsp+90h] [rbp+Fh] BYREF
  __int128 v16; // [rsp+A0h] [rbp+1Fh]
  char v17; // [rsp+E8h] [rbp+67h] BYREF
  __int64 v18; // [rsp+F0h] [rbp+6Fh]
  __int64 v19; // [rsp+100h] [rbp+7Fh] BYREF

  v18 = a2;
  v4 = *(__int64 **)(a1 + 24);
  v5 = *(__int64 **)(a1 + 32);
  while ( 1 )
  {
    if ( v4 == v5 )
    {
      v12 = 0LL;
      v8 = 0LL;
      v7 = 0LL;
      goto LABEL_9;
    }
    if ( sub_1800322F0(*v4) == a3 )
      break;
    v4 += 2;
  }
  v6 = v4[1];
  if ( v6 )
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 8));
  v7 = *v4;
  *(_QWORD *)&v12 = *v4;
  v8 = v4[1];
  *((_QWORD *)&v12 + 1) = v8;
LABEL_9:
  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
  *(_QWORD *)(a2 + 16) = 0LL;
  if ( v7 )
  {
    sub_18001A2C0(&v19, *(_QWORD *)(qword_180074190 + 8), 0);
    if ( v8 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v8 + 8));
      v8 = *((_QWORD *)&v12 + 1);
    }
    sub_180045D30(&v13);
    v13 = &SmartExport::AssetArtFilter::`vftable';
    v14 = v12;
    v15 = 0LL;
    *(_QWORD *)&v16 = 0LL;
    sub_18000DE70((__int64)&v17);
    sub_180045EE0((unsigned int)&v17, (unsigned int)&v13, 0, 4, (__int64)sub_1800206F0, (__int64)sub_1800206B0);
    if ( (__int128 *)a2 != &v15 )
      sub_18001E690(a2, v15, *((_QWORD *)&v15 + 1), (unsigned __int8)v18);
    AIDE::PixelPartInfo::~PixelPartInfo((AIDE::PixelPartInfo *)&v17);
    v9 = v15;
    if ( (_QWORD)v15 )
    {
      if ( (unsigned __int64)(8 * ((__int64)(v16 - v15) >> 3)) >= 0x1000 )
      {
        v9 = *(_QWORD *)(v15 - 8);
        if ( (unsigned __int64)(v15 - v9 - 8) > 0x1F )
          invalid_parameter_noinfo_noreturn();
      }
      sub_18001AE10(v9);
      v15 = 0LL;
      *(_QWORD *)&v16 = 0LL;
    }
    v10 = (volatile signed __int32 *)*((_QWORD *)&v14 + 1);
    if ( *((_QWORD *)&v14 + 1) )
    {
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v14 + 1) + 8LL), 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v10)(v10);
        if ( _InterlockedExchangeAdd(v10 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v10 + 8LL))(v10);
      }
      v8 = *((_QWORD *)&v12 + 1);
    }
    sub_180045D40(&v13);
    sub_18001A320(&v19);
  }
  if ( v8 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 0xFFFFFFFF) == 1 )
    {
      (***((void (__fastcall ****)(_QWORD))&v12 + 1))(*((_QWORD *)&v12 + 1));
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*((_QWORD *)&v12 + 1) + 12LL), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(_QWORD))(**((_QWORD **)&v12 + 1) + 8LL))(*((_QWORD *)&v12 + 1));
    }
  }
  return a2;
}


// ===== 函数: sub_180045EE0 (0x180045EE0) =====
// Hidden C++ exception states: #wind=3
void __fastcall sub_180045EE0(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6)
{
  _DWORD *v9; // r12
  _QWORD *v10; // rax
  int v11; // ebx
  __int128 *v12; // rax
  __int64 v13; // rax
  __int128 *v14; // rax
  __int64 v15; // rax
  __int128 *v16; // rax
  __int64 v17; // rax
  __int64 *v18; // rdx
  __int128 *v19; // rax
  __int64 v20; // rax
  int v21; // eax
  __int128 *v22; // rax
  __int64 v23; // rax
  __int128 *v24; // rax
  __int64 v25; // rax
  int v26; // eax
  _QWORD *v27; // rax
  __int128 *v28; // rax
  __int64 v29; // rax
  __int128 *v30; // rax
  __int64 v31; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v32; // [rsp+48h] [rbp-B8h] BYREF
  int v33; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v34; // [rsp+58h] [rbp-A8h] BYREF
  _QWORD v35[2]; // [rsp+60h] [rbp-A0h] BYREF
  _BYTE pExceptionObject[48]; // [rsp+70h] [rbp-90h] BYREF
  int v37; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v38; // [rsp+A8h] [rbp-58h]
  __int64 v39; // [rsp+B0h] [rbp-50h]
  int v40; // [rsp+B8h] [rbp-48h]
  __int64 v41; // [rsp+C0h] [rbp-40h]
  __int64 v42; // [rsp+C8h] [rbp-38h]
  int v43; // [rsp+D0h] [rbp-30h]
  __int64 v44; // [rsp+D8h] [rbp-28h]
  __int64 v45; // [rsp+E0h] [rbp-20h]
  int v46; // [rsp+E8h] [rbp-18h]
  __int64 v47; // [rsp+F0h] [rbp-10h]
  __int64 v48; // [rsp+F8h] [rbp-8h]
  int v49; // [rsp+100h] [rbp+0h]
  __int64 v50; // [rsp+108h] [rbp+8h]
  __int64 v51; // [rsp+110h] [rbp+10h]
  int v52; // [rsp+118h] [rbp+18h]
  __int64 v53; // [rsp+120h] [rbp+20h]
  __int64 v54; // [rsp+128h] [rbp+28h]
  int v55; // [rsp+130h] [rbp+30h]
  __int64 v56; // [rsp+138h] [rbp+38h]
  __int64 v57; // [rsp+140h] [rbp+40h]
  int v58; // [rsp+148h] [rbp+48h]
  __int64 v59; // [rsp+150h] [rbp+50h]
  __int64 v60; // [rsp+158h] [rbp+58h]
  int v61; // [rsp+160h] [rbp+60h]
  __int64 v62; // [rsp+168h] [rbp+68h]
  __int64 v63; // [rsp+170h] [rbp+70h]
  int v64; // [rsp+178h] [rbp+78h]
  __int64 v65; // [rsp+180h] [rbp+80h]
  __int64 v66; // [rsp+188h] [rbp+88h]
  int v67; // [rsp+190h] [rbp+90h]
  __int64 v68; // [rsp+198h] [rbp+98h]
  __int64 v69; // [rsp+1A0h] [rbp+A0h]
  int v70; // [rsp+1A8h] [rbp+A8h]
  __int64 v71; // [rsp+1B0h] [rbp+B0h]
  __int64 v72; // [rsp+1B8h] [rbp+B8h]
  int v73; // [rsp+1C0h] [rbp+C0h]
  __int64 v74; // [rsp+1C8h] [rbp+C8h]
  __int64 v75; // [rsp+1D0h] [rbp+D0h]
  int v76; // [rsp+1D8h] [rbp+D8h]
  __int64 v77; // [rsp+1E0h] [rbp+E0h]
  __int64 v78; // [rsp+1E8h] [rbp+E8h]
  int v79; // [rsp+1F0h] [rbp+F0h]
  __int64 v80; // [rsp+1F8h] [rbp+F8h]
  __int64 v81; // [rsp+200h] [rbp+100h]
  int v82; // [rsp+208h] [rbp+108h]
  __int64 v83; // [rsp+210h] [rbp+110h]
  __int64 v84; // [rsp+218h] [rbp+118h]
  int v85; // [rsp+220h] [rbp+120h]
  __int64 v86; // [rsp+228h] [rbp+128h]
  __int64 v87; // [rsp+230h] [rbp+130h]
  int v88; // [rsp+238h] [rbp+138h]
  __int64 v89; // [rsp+240h] [rbp+140h]
  __int64 v90; // [rsp+248h] [rbp+148h]

  v35[1] = -2LL;
  v9 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4LL);
  if ( dword_180074CE8 > *v9 )
  {
    Init_thread_header(&dword_180074CE8);
    if ( dword_180074CE8 == -1 )
    {
      xmmword_180074CC8 = 0LL;
      qword_180074CD8 = (__int64)"AI Geometry Suite";
      dword_180074CE0 = 6;
      byte_180074CE4 = 0;
      Init_thread_footer(&dword_180074CE8);
    }
  }
  if ( !*((_QWORD *)&xmmword_180074CC8 + 1) && qword_1800740D8 )
  {
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
           qword_180074CD8,
           (unsigned int)dword_180074CE0,
           (char *)&xmmword_180074CC8 + 8) )
    {
      *((_QWORD *)&xmmword_180074CC8 + 1) = 0LL;
    }
    else if ( !byte_180074CE4 )
    {
      v10 = sub_180012E90();
      *(_QWORD *)&xmmword_180074CC8 = *v10;
      *v10 = &xmmword_180074CC8;
    }
  }
  if ( *((_QWORD *)&xmmword_180074CC8 + 1) )
  {
    v31 = 0LL;
    v34 = 0LL;
    v11 = a3 - 1;
    if ( !v11 )
    {
      v14 = sub_180046430();
      v15 = sub_180007790((__int64)v14);
      (*(void (__fastcall **)(__int64 *))(v15 + 32))(&v31);
      v16 = sub_180046430();
      v17 = sub_180007790((__int64)v16);
      v18 = &v34;
      goto LABEL_14;
    }
    v12 = sub_180046430();
    v13 = sub_180007790((__int64)v12);
    if ( v11 == 1 )
      (*(void (__fastcall **)(__int64 *))(v13 + 40))(&v31);
    else
      (*(void (__fastcall **)(__int64 *))(v13 + 32))(&v31);
    while ( v31 != v34 )
    {
      v32 = 0LL;
      v19 = sub_180046430();
      v20 = sub_180007790((__int64)v19);
      (*(void (__fastcall **)(__int64, __int64 *))(v20 + 64))(v31, &v32);
      while ( v32 )
      {
        v21 = 1;
        v33 = 1;
        if ( (a4 & 4) != 0 )
        {
          v22 = sub_180039810();
          v23 = sub_180007790((__int64)v22);
          (*(void (__fastcall **)(__int64, int *))(v23 + 96))(v32, &v33);
          v21 = v33;
        }
        if ( v21 )
        {
          v35[0] = 0LL;
          v24 = sub_180007D50();
          v25 = sub_180007790((__int64)v24);
          (*(void (__fastcall **)(__int64, _QWORD *))(v25 + 32))(v32, v35);
          v37 = 1;
          v38 = a6;
          v39 = 0LL;
          v40 = 2;
          v41 = a5;
          v42 = 0LL;
          v43 = 3;
          v44 = a5;
          v45 = 0LL;
          v46 = 4;
          v47 = a6;
          v48 = 0LL;
          v49 = 5;
          v50 = a6;
          v51 = 0LL;
          v52 = 6;
          v53 = a5;
          v54 = 0LL;
          v55 = 7;
          v56 = a6;
          v57 = 0LL;
          v58 = 9;
          v59 = a5;
          v60 = 0LL;
          v61 = 10;
          v62 = a5;
          v63 = 0LL;
          v64 = 11;
          v65 = a6;
          v66 = 0LL;
          v67 = 12;
          v68 = a5;
          v69 = 0LL;
          v70 = 13;
          v71 = a6;
          v72 = 0LL;
          v73 = 14;
          v74 = a6;
          v75 = 0LL;
          v76 = 15;
          v77 = a5;
          v78 = 0LL;
          v79 = 16;
          v80 = a5;
          v81 = 0LL;
          v82 = 17;
          v83 = a5;
          v84 = 0LL;
          v85 = 18;
          v86 = a6;
          v87 = 0LL;
          v88 = 0;
          v89 = 0LL;
          v90 = 0LL;
          if ( dword_180074CE8 > *v9 )
          {
            Init_thread_header(&dword_180074CE8);
            if ( dword_180074CE8 == -1 )
            {
              xmmword_180074CC8 = 0LL;
              qword_180074CD8 = (__int64)"AI Geometry Suite";
              dword_180074CE0 = 6;
              byte_180074CE4 = 0;
              Init_thread_footer(&dword_180074CE8);
            }
          }
          if ( !*((_QWORD *)&xmmword_180074CC8 + 1) && qword_1800740D8 )
          {
            v26 = (*(__int64 (__fastcall **)(__int64, _QWORD, char *))qword_1800740D8)(
                    qword_180074CD8,
                    (unsigned int)dword_180074CE0,
                    (char *)&xmmword_180074CC8 + 8);
            if ( v26 )
            {
              sub_180003F80((__int64)pExceptionObject, v26, 0LL);
              throw (ai::Error *)pExceptionObject;
            }
            if ( !byte_180074CE4 )
            {
              v27 = sub_180012E90();
              *(_QWORD *)&xmmword_180074CC8 = *v27;
              *v27 = &xmmword_180074CC8;
            }
          }
          (**((void (__fastcall ***)(_QWORD, int *, _QWORD, _QWORD, _QWORD, __int64, int))&xmmword_180074CC8 + 1))(
            v35[0],
            &v37,
            0LL,
            0LL,
            0LL,
            a2,
            a4);
        }
        v28 = sub_180046430();
        v29 = sub_180007790((__int64)v28);
        (*(void (__fastcall **)(__int64, __int64, __int64 *))(v29 + 80))(v31, v32, &v32);
      }
      v30 = sub_180046430();
      v17 = sub_180007790((__int64)v30);
      v18 = &v31;
LABEL_14:
      (*(void (__fastcall **)(__int64, __int64 *))(v17 + 48))(v31, v18);
    }
  }
}


// ===== 函数: sub_180039810 (0x180039810) =====
// Hidden C++ exception states: #wind=3
__int128 *sub_180039810()
{
  _QWORD *v1; // rax

  if ( dword_180074960[0] <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                       + 4LL) )
    return &xmmword_180074940;
  Init_thread_header(dword_180074960);
  if ( dword_180074960[0] != -1 )
    return &xmmword_180074940;
  xmmword_180074940 = 0LL;
  qword_180074950 = (__int64)"AI Layer Suite";
  dword_180074958 = 13;
  byte_18007495C = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180074940 = *v1;
  *v1 = &xmmword_180074940;
  Init_thread_footer(dword_180074960);
  return &xmmword_180074940;
}


// ===== 函数: sub_180046430 (0x180046430) =====
// Hidden C++ exception states: #wind=3
__int128 *sub_180046430()
{
  _QWORD *v1; // rax

  if ( dword_180074E60 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 4LL) )
    return &xmmword_180074E40;
  Init_thread_header(&dword_180074E60);
  if ( dword_180074E60 != -1 )
    return &xmmword_180074E40;
  xmmword_180074E40 = 0LL;
  qword_180074E50 = (__int64)"AI Layer List";
  dword_180074E58 = 4;
  byte_180074E5C = 1;
  v1 = sub_180012E90();
  *(_QWORD *)&xmmword_180074E40 = *v1;
  *v1 = &xmmword_180074E40;
  Init_thread_footer(&dword_180074E60);
  return &xmmword_180074E40;
}


// ===== 函数: sub_180045D40 (0x180045D40) =====
// Hidden C++ exception states: #wind=3
void **__fastcall sub_180045D40(_QWORD *a1)
{
  void **result; // rax

  result = &ArtConsumer::`vftable';
  *a1 = &ArtConsumer::`vftable';
  return result;
}


// ===== 函数: sub_180045D30 (0x180045D30) =====
// Hidden C++ exception states: #wind=3
_QWORD *__fastcall sub_180045D30(_QWORD *a1)
{
  *a1 = &ArtConsumer::`vftable';
  return a1;
}


// ===== 函数: sub_18001E690 (0x18001E690) =====
// Hidden C++ exception states: #wind=3
char *__fastcall sub_18001E690(__int64 a1, _BYTE *a2, void **a3)
{
  char *v3; // rdi
  size_t v5; // r12
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // r14
  unsigned __int64 v10; // rbp
  unsigned __int64 v11; // rdx
  char *v12; // rax
  char *v13; // rbx
  char *result; // rax
  unsigned __int64 v15; // rbx
  size_t v16; // rbx
  char *v17; // rdi
  signed __int64 v18; // rbp

  v3 = *(char **)a1;
  v5 = (char *)a3 - a2;
  v6 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3;
  v7 = ((char *)a3 - a2) >> 3;
  if ( v7 <= v6 )
  {
    v15 = (__int64)(*(_QWORD *)(a1 + 8) - (_QWORD)v3) >> 3;
    if ( v7 <= v15 )
    {
      memmove(v3, a2, (char *)a3 - a2);
      result = &v3[8 * v7];
    }
    else
    {
      v16 = 8 * v15;
      memmove(v3, a2, v16);
      v17 = *(char **)(a1 + 8);
      v18 = (char *)a3 - &a2[v16];
      memmove(v17, &a2[v16], v18);
      result = &v17[8 * (v18 >> 3)];
    }
  }
  else
  {
    v10 = 0x1FFFFFFFFFFFFFFFLL;
    if ( v7 > 0x1FFFFFFFFFFFFFFFLL )
      std::vector<void *>::_Xlen();
    v11 = v6 >> 1;
    if ( v6 <= 0x1FFFFFFFFFFFFFFFLL - (v6 >> 1) )
    {
      v10 = v11 + v6;
      if ( v11 + v6 < v7 )
        v10 = v7;
    }
    if ( v3 )
    {
      if ( 8 * v6 >= 0x1000 )
      {
        if ( (unsigned __int64)&v3[-*((_QWORD *)v3 - 1) - 8] > 0x1F )
          invalid_parameter_noinfo_noreturn();
        v3 = (char *)*((_QWORD *)v3 - 1);
      }
      sub_18001AE10((__int64)v3);
      *(_QWORD *)a1 = 0LL;
      *(_QWORD *)(a1 + 8) = 0LL;
      *(_QWORD *)(a1 + 16) = 0LL;
    }
    v12 = (char *)sub_1800182F0(a1, v10, a3);
    *(_QWORD *)a1 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    v13 = v12;
    *(_QWORD *)(a1 + 16) = &v12[8 * v10];
    memmove(v12, a2, v5);
    result = &v13[8 * v7];
  }
  *(_QWORD *)(a1 + 8) = result;
  return result;
}


// ===== 函数: ??1PixelPartInfo@AIDE@@QEAA@XZ (0x1800089B0) =====
// Hidden C++ exception states: #wind=3
void __fastcall AIDE::PixelPartInfo::~PixelPartInfo(AIDE::PixelPartInfo *this)
{
  ;
}


